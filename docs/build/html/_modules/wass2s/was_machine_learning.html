

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_machine_learning &mdash; wass2s 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">wass2s.was_download</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_machine_learning</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_machine_learning</h1><div class="highlight"><pre>
<span></span><span class="c1">########  This code was developed by Mandela Houngnibo et al. within the framework of AGRHYMET WAS-RCC S2S. #################### Version 1.0.0 #########################</span>

<span class="c1">######################################################## Modules ########################################################</span>

<span class="c1"># Machine Learning and Statistical Modeling</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">linear_model</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span><span class="p">,</span> <span class="n">StackingRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVR</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>
<span class="kn">import</span> <span class="nn">xgboost</span> <span class="k">as</span> <span class="nn">xgb</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.outliers_influence</span> <span class="kn">import</span> <span class="n">variance_inflation_factor</span> <span class="k">as</span> <span class="n">VIF</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.anova</span> <span class="kn">import</span> <span class="n">anova_lm</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="kn">import</span> <span class="n">MLPRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>

<span class="c1"># Data Manipulation and Analysis</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># Signal Processing and Interpolation</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sig</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">CubicSpline</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">lognorm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gamma</span>

<span class="c1"># EOF Analysis</span>
<span class="kn">import</span> <span class="nn">xeofs</span> <span class="k">as</span> <span class="nn">xe</span>

<span class="c1"># Parallel Computing</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVR</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">wass2s.utils</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="WAS_SVR">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_SVR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform Support Vector Regression (SVR) on spatiotemporal datasets for climate prediction.</span>

<span class="sd">    This class is designed to work with Dask and Xarray for parallelized, high-performance </span>
<span class="sd">    regression computations across large datasets with spatial and temporal dimensions. The primary </span>
<span class="sd">    methods are for fitting the SVR model, making predictions, and calculating probabilistic predictions </span>
<span class="sd">    for climate terciles.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int, optional</span>
<span class="sd">        The number of CPU cores to use for parallel computation (default is 1).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        The number of clusters to use in KMeans clustering (default is 5).</span>
<span class="sd">    kernel : str, optional</span>
<span class="sd">        Kernel type to be used in SVR (&#39;linear&#39;, &#39;poly&#39;, &#39;rbf&#39;, or &#39;all&#39;) (default is &#39;linear&#39;).</span>
<span class="sd">    gamma : str, optional</span>
<span class="sd">        gamma of &#39;rbf&#39; kernel function. Ignored by all other kernels, [&quot;auto&quot;, &quot;scale&quot;, None] by default None.</span>
<span class="sd">    C_range : list, optional</span>
<span class="sd">        List of C values to consider during hyperparameter tuning.</span>
<span class="sd">    epsilon_range : list, optional</span>
<span class="sd">        List of epsilon values to consider during hyperparameter tuning.</span>
<span class="sd">    degree_range : list, optional</span>
<span class="sd">        List of degrees to consider for the &#39;poly&#39; kernel during hyperparameter tuning.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method (&quot;gamma&quot;, &quot;t&quot;, &quot;normal&quot;, &quot;lognormal&quot;, &quot;nonparam&quot;) for probability calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
        <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">C_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> 
        <span class="n">epsilon_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
        <span class="n">degree_range</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the WAS_SVR with specified hyperparameter ranges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb_cores : int, optional</span>
<span class="sd">            Number of CPU cores to use for parallel computation.</span>
<span class="sd">        n_clusters : int, optional</span>
<span class="sd">            Number of clusters for KMeans.</span>
<span class="sd">        kernel : str, optional</span>
<span class="sd">            Kernel type to be used in SVR (&#39;linear&#39;, &#39;poly&#39;, &#39;rbf&#39;, or &#39;all&#39;).</span>
<span class="sd">        gamma : str, optional</span>
<span class="sd">            Kernel coefficient for &#39;rbf&#39; kernel. Ignored otherwise.</span>
<span class="sd">        C_range : list, optional</span>
<span class="sd">            List of C values for hyperparameter tuning.</span>
<span class="sd">        epsilon_range : list, optional</span>
<span class="sd">            List of epsilon values for hyperparameter tuning.</span>
<span class="sd">        degree_range : list, optional</span>
<span class="sd">            List of polynomial degrees for &#39;poly&#39; kernel.</span>
<span class="sd">        dist_method : str, optional</span>
<span class="sd">            Distribution method for tercile probability calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store all parameters so they are accessible throughout the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span> <span class="o">=</span> <span class="n">C_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_range</span> <span class="o">=</span> <span class="n">epsilon_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree_range</span> <span class="o">=</span> <span class="n">degree_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

<div class="viewcode-block" id="WAS_SVR.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits an SVR model to the provided training data, makes predictions on the test data, </span>
<span class="sd">        and calculates the prediction error.</span>

<span class="sd">        We handle data-type issues (e.g., bytes input), set up the SVR with the requested</span>
<span class="sd">        parameters, fit it, and return both the error and the prediction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape (n_samples, n_features)</span>
<span class="sd">            Training predictors.</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            Training targets.</span>
<span class="sd">        x_test : array-like, shape (n_features,)</span>
<span class="sd">            Test predictors.</span>
<span class="sd">        y_test : float or None</span>
<span class="sd">            Test target value. Used to calculate error if available.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon parameter for SVR (defines epsilon-tube).</span>
<span class="sd">        C : float</span>
<span class="sd">            Regularization parameter for SVR.</span>
<span class="sd">        degree : int, optional</span>
<span class="sd">            Degree for &#39;poly&#39; kernel. Ignored if kernel != &#39;poly&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            A 2-element array containing [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert any byte-string parameters to standard Python strings/integers</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="ow">and</span> <span class="n">degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">degree</span><span class="p">):</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        
        <span class="c1"># Ensure &#39;degree&#39; has a valid numeric default if not properly set</span>
        <span class="k">if</span> <span class="n">degree</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">degree</span> <span class="o">==</span> <span class="s1">&#39;nan&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">degree</span><span class="p">)):</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>

        <span class="c1"># Prepare model parameters based on kernel type</span>
        <span class="n">model_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="n">epsilon</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">and</span> <span class="n">degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_params</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s1">&#39;rbf&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_params</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Instantiate the SVR model with chosen parameters</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="o">**</span><span class="n">model_params</span><span class="p">)</span>

        <span class="c1"># Check for valid (finite) training data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Train only if there&#39;s valid data</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="c1"># If x_test is 1-D, reshape into 2-D for prediction</span>
            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Make predictions</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

            <span class="c1"># Ensuring no negative predictions (if that applies to your data domain, e.g., rainfall)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Calculate error, if y_test is valid</span>
            <span class="k">if</span> <span class="n">y_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_test</span><span class="p">):</span>
                <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># Return [error, prediction] as a flattened array</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If there&#39;s no valid training data, return NaNs</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="WAS_SVR.compute_hyperparameters">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.compute_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes optimal SVR hyperparameters (C and epsilon) for each spatial cluster.</span>

<span class="sd">        We cluster the spatial grid based on the mean values in `predictand`, </span>
<span class="sd">        then do a grid search for SVR hyperparameters on the average time series of each cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable with dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;).</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor variables with dimensions (&#39;T&#39;, &#39;features&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C_array, epsilon_array, degree_array, Cluster</span>
<span class="sd">            DataArrays containing the best-fitting hyperparameters and cluster labels for each grid cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        
        <span class="c1"># Flatten spatial and drop time dimension to get a 2D array for KMeans</span>
        <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
        
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        
        <span class="c1"># Compute mean time series for each cluster</span>
        <span class="n">cluster_means</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span> <span class="n">xarray1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xarray2</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span>
        <span class="p">}</span>

        <span class="c1"># Step 2: Prepare parameter grids depending on selected kernel(s)</span>
        <span class="n">param_grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="n">param_grid</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">],</span> 
                <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">,</span> 
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_range</span>
            <span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="n">param_grid</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;poly&#39;</span><span class="p">],</span> 
                <span class="s1">&#39;degree&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree_range</span><span class="p">,</span> 
                <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">,</span> 
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_range</span>
            <span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="n">param_grid</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;rbf&#39;</span><span class="p">],</span> 
                <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">,</span> 
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_range</span><span class="p">,</span> 
                <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
            <span class="p">})</span>

        <span class="c1"># We&#39;ll use sklearn&#39;s GridSearchCV to test parameter combinations</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">()</span>
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
    
        <span class="n">hyperparams_cluster</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Perform grid search for each cluster&#39;s mean time series</span>
        <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="c1"># Obtain the mean time series for this cluster</span>
            <span class="n">cluster_mean</span> <span class="o">=</span> <span class="n">cluster_means</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

            <span class="c1"># Ensure predictor time dimension aligns with the same time steps</span>
            <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_mean</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
            <span class="n">common_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">cluster_mean</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If there are no overlapping times, skip</span>
                <span class="k">continue</span>

            <span class="c1"># Select the overlapping times</span>
            <span class="n">cluster_mean_common</span> <span class="o">=</span> <span class="n">cluster_mean</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">common_times</span><span class="p">)</span>
            <span class="n">predictor_common</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">common_times</span><span class="p">)</span>

            <span class="n">y_cluster</span> <span class="o">=</span> <span class="n">cluster_mean_common</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">y_cluster</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Perform grid search for this cluster</span>
                <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">predictor_common</span><span class="p">,</span> <span class="n">y_cluster</span><span class="p">)</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
                
                <span class="c1"># Record best parameters for the cluster</span>
                <span class="n">hyperparams_cluster</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;kernel&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;degree&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># Only present if kernel=&#39;poly&#39;</span>
                    <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>     <span class="c1"># Only present if kernel=&#39;rbf&#39;</span>
                <span class="p">}</span>
    
        <span class="c1"># Step 3: Create DataArrays for the best C, epsilon, etc. in each cluster</span>
        <span class="n">C_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">epsilon_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">degree_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Fill each DataArray with the cluster-specific values</span>
        <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">hyperparams_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label</span>
            <span class="n">C_array</span> <span class="o">=</span> <span class="n">C_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
            <span class="n">epsilon_array</span> <span class="o">=</span> <span class="n">epsilon_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">])</span>
            <span class="n">degree_array</span> <span class="o">=</span> <span class="n">degree_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">])</span>
    
        <span class="c1"># Align arrays in case of dimension differences</span>
        <span class="n">C_array</span><span class="p">,</span> <span class="n">epsilon_array</span><span class="p">,</span> <span class="n">degree_array</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">C_array</span><span class="p">,</span> <span class="n">epsilon_array</span><span class="p">,</span> <span class="n">degree_array</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">C_array</span><span class="p">,</span> <span class="n">epsilon_array</span><span class="p">,</span> <span class="n">degree_array</span><span class="p">,</span> <span class="n">Cluster</span></div>


<div class="viewcode-block" id="WAS_SVR.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">degree_array</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes predictions for spatiotemporal data using SVR with parallel processing via Dask.</span>

<span class="sd">        We break the data into chunks, apply the `fit_predict` function in parallel,</span>
<span class="sd">        and combine the results into an output DataArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictors with dimensions (&#39;T&#39;, &#39;features&#39;).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training targets with dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictors with dimensions (&#39;features&#39;,).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test target values with dimensions (&#39;Y&#39;, &#39;X&#39;).</span>
<span class="sd">        epsilon : xarray.DataArray</span>
<span class="sd">            Epsilon hyperparameters per grid point.</span>
<span class="sd">        C : xarray.DataArray</span>
<span class="sd">            C hyperparameters per grid point.</span>
<span class="sd">        degree_array : xarray.DataArray, optional</span>
<span class="sd">            Polynomial degrees per grid point (only used if kernel=&#39;poly&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Predictions &amp; errors, stacked along a new &#39;output&#39; dimension (size=2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine chunk sizes so each worker handles a portion of the spatial domain</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time dimension in X_train with y_train</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        
        <span class="c1"># Squeeze out any singleton dimension in X_test / y_test</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Create a Dask client for parallel processing</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply `fit_predict` across each (Y,X) grid cell in parallel</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">epsilon</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">C</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">degree_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">})</span> <span class="k">if</span> <span class="n">degree_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>             <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>      <span class="c1"># x_test</span>
                <span class="p">(),</span>                 <span class="c1"># y_test</span>
                <span class="p">(),</span>                 <span class="c1"># epsilon</span>
                <span class="p">(),</span>                 <span class="c1"># C</span>
                <span class="p">()</span>                  <span class="c1"># degree</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>

        <span class="c1"># Trigger actual computation</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="c1"># Close the Dask client</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Return the results, containing both errors and predictions</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_SVR.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates tercile probabilities using a Student&#39;s t-based approach.</span>
<span class="sd">        </span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Model predictions for each time.</span>
<span class="sd">        error_variance : float or array-like</span>
<span class="sd">            Variance of prediction errors.</span>
<span class="sd">        first_tercile, second_tercile : float or array-like</span>
<span class="sd">            The lower and upper tercile boundaries.</span>
<span class="sd">        dof : int</span>
<span class="sd">            Degrees of freedom for the t-distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            Probability in each of the 3 categories (below, normal, above).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="c1"># If we have no valid predictions, fill with NaNs</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute standard deviation from error variance</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds into t-score space</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="c1"># Use scipy&#39;s t-distribution CDF to get probabilities</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_SVR.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates tercile probabilities assuming Gamma-distributed errors.</span>

<span class="sd">        best_guess : array-like</span>
<span class="sd">            Model predictions for each time.</span>
<span class="sd">        error_variance : float or array-like</span>
<span class="sd">            Variance of prediction errors.</span>
<span class="sd">        T1, T2 : float or array-like</span>
<span class="sd">            The lower (T1) and upper (T2) tercile boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            3 rows for probabilities (PB, PN, PA) over time dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># If there&#39;s any NaN in the inputs, fill output with NaNs</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="c1"># Convert to arrays for safety</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Gamma distribution parameters based on mean/variance</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
    
        <span class="c1"># CDF at T1 and T2</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_SVR.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_SVR.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-based method using the Gaussian CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_SVR.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_SVR.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>  <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="WAS_SVR.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_SVR.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">Predictant</span><span class="p">,</span> 
        <span class="n">clim_year_start</span><span class="p">,</span> 
        <span class="n">clim_year_end</span><span class="p">,</span> 
        <span class="n">Predictor</span><span class="p">,</span> 
        <span class="n">hindcast_det</span><span class="p">,</span> 
        <span class="n">Predictor_for_year</span><span class="p">,</span> 
        <span class="n">epsilon</span><span class="p">,</span> 
        <span class="n">C</span><span class="p">,</span> 
        <span class="n">kernel_array</span><span class="p">,</span> 
        <span class="n">degree_array</span><span class="p">,</span> 
        <span class="n">gamma_array</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates forecasts and computes probabilities for a specific year.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Target variable (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year for climatology.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year for climatology.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcasts (includes &#39;prediction&#39; and &#39;error&#39; outputs).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target forecast year (features).</span>
<span class="sd">        epsilon, C, kernel_array, degree_array, gamma_array : xarray.DataArray</span>
<span class="sd">            Hyperparameter grids for the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            1) The forecast results (error, prediction) for that year.</span>
<span class="sd">            2) The corresponding tercile probabilities (PB, PN, PA).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Divide the spatial domain into chunks for parallel computation</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Ensure time dimension alignment</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># We don&#39;t have an actual observed y_test for the forecast year, so fill with NaNs</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Create a Dask client for parallelization</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply `fit_predict` in parallel across the grid, using the forecast year&#39;s predictors</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">epsilon</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">C</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">kernel_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">degree_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">gamma_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x (training)</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>             <span class="c1"># y (training target)</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>      <span class="c1"># x_test (forecast-year predictors)</span>
                <span class="p">(),</span>                 <span class="c1"># y_test (unknown, hence NaN)</span>
                <span class="p">(),</span>                 <span class="c1"># epsilon</span>
                <span class="p">(),</span>                 <span class="c1"># C</span>
                <span class="p">(),</span>                 <span class="c1"># kernel</span>
                <span class="p">(),</span>                 <span class="c1"># degree</span>
                <span class="p">()</span>                  <span class="c1"># gamma</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>



<div class="viewcode-block" id="WAS_PolynomialRegression">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_PolynomialRegression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform Polynomial Regression on spatiotemporal datasets for climate prediction.</span>

<span class="sd">    This class is designed to work with Dask and Xarray for parallelized, high-performance </span>
<span class="sd">    regression computations across large datasets with spatial and temporal dimensions. The primary </span>
<span class="sd">    methods are for fitting the polynomial regression model, making predictions, and calculating </span>
<span class="sd">    probabilistic predictions for climate terciles.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int, optional</span>
<span class="sd">        The number of CPU cores to use for parallel computation (default is 1).</span>
<span class="sd">    degree : int, optional</span>
<span class="sd">        The degree of the polynomial (default is 2).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        The distribution method to compute tercile probabilities. One of </span>
<span class="sd">        {&quot;t&quot;, &quot;gamma&quot;, &quot;normal&quot;, &quot;lognormal&quot;, &quot;nonparam&quot;} (default is &quot;gamma&quot;).</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fit_predict(x, y, x_test, y_test)</span>
<span class="sd">        Fits a Polynomial Regression model to the training data, predicts on test data, </span>
<span class="sd">        and computes error.</span>
<span class="sd">    compute_model(X_train, y_train, X_test, y_test)</span>
<span class="sd">        Applies the Polynomial Regression model across a dataset using parallel computation </span>
<span class="sd">        with Dask, returning predictions and error metrics.</span>
<span class="sd">    compute_prob(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det)</span>
<span class="sd">        Computes tercile probabilities for hindcast rainfall predictions </span>
<span class="sd">        over specified climatological years.</span>
<span class="sd">    forecast(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det, Predictor_for_year)</span>
<span class="sd">        Generates a forecast for a single year (or time step) and calculates tercile probabilities </span>
<span class="sd">        using the chosen distribution method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the WAS_PolynomialRegression with a specified number of CPU cores and polynomial degree.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb_cores : int, optional</span>
<span class="sd">            Number of CPU cores to use for parallel computation, by default 1.</span>
<span class="sd">        degree : int, optional</span>
<span class="sd">            The degree of the polynomial, by default 2.</span>
<span class="sd">        dist_method : str, optional</span>
<span class="sd">            The method to compute tercile probabilities (&quot;t&quot;, &quot;gamma&quot;, &quot;normal&quot;, &quot;lognormal&quot;, &quot;nonparam&quot;), </span>
<span class="sd">            by default &quot;gamma&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

<div class="viewcode-block" id="WAS_PolynomialRegression.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a Polynomial Regression model to the provided training data, makes predictions </span>
<span class="sd">        on the test data, and calculates the prediction error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape (n_samples, n_features)</span>
<span class="sd">            Training data (predictors).</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            Training targets.</span>
<span class="sd">        x_test : array-like, shape (n_features,) or (1, n_features)</span>
<span class="sd">            Test data (predictors) for which we want predictions.</span>
<span class="sd">        y_test : float</span>
<span class="sd">            Test target value (for computing error).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray of shape (2,)</span>
<span class="sd">            Array containing [prediction_error, predicted_value].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a PolynomialFeatures transformer for the specified degree</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

        <span class="c1"># Identify valid (finite) samples</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># If we have at least one valid sample, we can train a model</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Transform x_clean into polynomial feature space</span>
            <span class="n">x_clean_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">x_clean</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean_poly</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="c1"># Reshape x_test if needed and transform it</span>
            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_test_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

            <span class="c1"># Make predictions</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test_poly</span><span class="p">)</span>

            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Compute prediction error</span>
            <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no valid data, return NaNs</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes predictions for spatiotemporal data using Polynomial Regression with parallel processing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training data (predictors) with dimensions (T, features).</span>
<span class="sd">            (It must be chunked properly in Dask, or at least be amenable to chunking.)</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training target values with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test data (predictors) with dimensions (features,) or (T, features).</span>
<span class="sd">            Typically, you&#39;d match time steps or have a single test.</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test target values with dimensions (Y, X) or broadcastable to (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            An array with shape (2, Y, X) after computing, where the first index </span>
<span class="sd">            is error and the second is the prediction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine chunk sizes so each worker handles a portion of the spatial domain</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time dimension: we want X_train and y_train to have the same &#39;T&#39;</span>
        <span class="c1"># (We assume X_train has dimension (T, features) and y_train has dimension (T, Y, X))</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Squeeze X_test (if it has extra dims)</span>
        <span class="c1"># Usually, X_test would be (features,) or (T, features)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># y_test might have shape (Y, X) or (T, Y, X). </span>
        <span class="c1"># If it&#39;s purely spatial, no &#39;T&#39; dimension. We remove it if present.</span>
        <span class="k">if</span> <span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">y_test</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Create a Dask client for parallel processing</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply `fit_predict` across each (Y,X) grid cell in parallel.</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>                                   <span class="c1"># shape (T, features)</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span> <span class="p">()],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>           <span class="c1"># We&#39;ll have a new dim &#39;output&#39; of size 2</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>

        <span class="c1"># Trigger computation</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Return an xarray.DataArray with dimension &#39;output&#39; of size 2: [error, prediction]</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># --------------------------------------------------------------------------</span>
    <span class="c1">#  Below are various methods to compute tercile probabilities.</span>
    <span class="c1"># --------------------------------------------------------------------------</span>

<div class="viewcode-block" id="WAS_PolynomialRegression.calculate_tercile_probabilities_t">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.calculate_tercile_probabilities_t">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_t</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the probability of each tercile category using a Student&#39;s t-based approach.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like, shape (n_time,)</span>
<span class="sd">            Forecasted values.</span>
<span class="sd">        error_variance : float or array-like</span>
<span class="sd">            Error variance associated with the forecasted value.</span>
<span class="sd">        first_tercile : float or array-like</span>
<span class="sd">            Lower tercile threshold.</span>
<span class="sd">        second_tercile : float or array-like</span>
<span class="sd">            Upper tercile threshold.</span>
<span class="sd">        dof : int</span>
<span class="sd">            Degrees of freedom for the t-distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray, shape (3, n_time)</span>
<span class="sd">            Probability in each tercile category [Below, Normal, Above].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>

            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># If any input is NaN, fill with NaN</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="c1"># Convert inputs to arrays</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Gamma distribution parameters</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>

        <span class="c1"># Compute CDF at T1, T2</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-based method using the Gaussian CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="c1"># Moment matching for lognormal distribution</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># CDF from scipy.stats.lognorm</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_PolynomialRegression.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PolynomialRegression.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate forecasts for a single time (e.g., future year) and compute </span>
<span class="sd">        tercile probabilities based on the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Target variable with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data with dimensions (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast array that includes &#39;error&#39; and &#39;prediction&#39; over the historical period.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple (result_, hindcast_prob)</span>
<span class="sd">            result_  : xarray.DataArray or numpy array with the forecast&#39;s [error, prediction].</span>
<span class="sd">            hindcast_prob : xarray.DataArray of shape (probability=3, Y, X) with PB, PN, and PA.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Chunk sizes for parallel processing</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align the time dimension</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Squeeze the forecast predictor data if needed</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># We&#39;ll apply our polynomial regression in parallel across Y,X. </span>
        <span class="c1"># Because we are forecasting a single point in time, y_test is unknown, so we omit it or set it to NaN.</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># shape (Y,X)</span>

        <span class="c1"># Create a Dask client</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply fit_predict to get the forecast for each grid cell </span>
        <span class="c1"># We&#39;ll produce shape (2,) for each cell: [error, prediction]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>                         <span class="c1"># shape (T, features)</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span> <span class="p">()],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>

        <span class="c1"># Compute and close the client</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>


        
<span class="c1">###########################################</span>

<div class="viewcode-block" id="WAS_PoissonRegression">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_PoissonRegression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform Poisson Regression on spatiotemporal datasets for count data prediction.</span>

<span class="sd">    This class is designed to work with Dask and Xarray for parallelized, high-performance </span>
<span class="sd">    regression computations across large datasets with spatial and temporal dimensions. The primary </span>
<span class="sd">    methods are for fitting the Poisson regression model, making predictions, and calculating </span>
<span class="sd">    probabilistic predictions for climate terciles.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int</span>
<span class="sd">        The number of CPU cores to use for parallel computation (default is 1).</span>
<span class="sd">    dist_method : str</span>
<span class="sd">        The method to use for tercile probability calculations, e.g. {&quot;t&quot;, &quot;gamma&quot;, &quot;normal&quot;, </span>
<span class="sd">        &quot;lognormal&quot;, &quot;nonparam&quot;} (default is &quot;gamma&quot;).</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fit_predict(x, y, x_test, y_test)</span>
<span class="sd">        Fits a Poisson regression model to the training data, predicts on test data, and computes error.</span>
<span class="sd">    compute_model(X_train, y_train, X_test, y_test)</span>
<span class="sd">        Applies the Poisson regression model across a dataset using parallel computation </span>
<span class="sd">        with Dask, returning predictions and error metrics.</span>
<span class="sd">    compute_prob(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det)</span>
<span class="sd">        Computes tercile probabilities for hindcast rainfall (or count data) predictions </span>
<span class="sd">        over specified climatological years, using the chosen `dist_method`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the WAS_PoissonRegression with a specified number of CPU cores and </span>
<span class="sd">        a default distribution method for tercile probability calculations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb_cores : int, optional</span>
<span class="sd">            Number of CPU cores to use for parallel computation, by default 1.</span>
<span class="sd">        dist_method : str, optional</span>
<span class="sd">            The distribution method to compute tercile probabilities, by default &quot;gamma&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

<div class="viewcode-block" id="WAS_PoissonRegression.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a Poisson regression model to the provided training data, makes predictions </span>
<span class="sd">        on the test data, and calculates the prediction error.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape (n_samples, n_features)</span>
<span class="sd">            Training data (predictors).</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            Training targets (non-negative count data).</span>
<span class="sd">        x_test : array-like, shape (n_features,) or (1, n_features)</span>
<span class="sd">            Test data (predictors).</span>
<span class="sd">        y_test : float</span>
<span class="sd">            Test target value (actual counts).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray of shape (2,)</span>
<span class="sd">            [prediction_error, predicted_value]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># PoissonRegressor requires non-negative y. We assume the user has handled invalid data.</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">PoissonRegressor</span><span class="p">()</span>

        <span class="c1"># Fit on all provided samples. (If any NaNs exist, user must filter them out externally </span>
        <span class="c1"># or we might add a mask for valid data.)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Predict on the test data</span>
        <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Poisson rates should not be negative, but numeric or solver issues could occur</span>
        <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute difference from actual</span>
        <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes predictions for spatiotemporal data using Poisson Regression with parallel processing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Predictor data with dimensions (T, features).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training target values (count data) with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test data (predictors) with shape (features,) or (T, features), typically squeezed.</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test target values (count data) with dimensions (Y, X) or broadcastable to (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            An array with a new dimension (&#39;output&#39;, size=2) capturing [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine chunk sizes so each worker handles a portion of the spatial domain</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align the &#39;T&#39; dimension</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Squeeze test arrays in case of extra dimensions</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># If y_test has a &#39;T&#39; dimension, remove/ignore it since we only need (Y,X)</span>
        <span class="k">if</span> <span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">y_test</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Create a Dask client for parallel computing</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply our fit_predict method across each spatial cell in parallel</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>                                 <span class="c1"># shape (T, features)</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>  <span class="c1"># shape (T,)</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span> <span class="p">()],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>         <span class="c1"># We&#39;ll have an &#39;output&#39; dimension of size 2</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>

        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># --------------------------------------------------------------------------</span>
    <span class="c1">#  Probability methods for terciles. Some are repeated from previous classes,</span>
    <span class="c1">#  but included here for completeness.</span>
    <span class="c1"># --------------------------------------------------------------------------</span>

<div class="viewcode-block" id="WAS_PoissonRegression.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method for calculating tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma-based method for calculating tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>

        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-based method using the Gaussian CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-based method for tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_PoissonRegression.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="WAS_PoissonRegression.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_PoissonRegression.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate forecasts for a single time (e.g., future year) and compute </span>
<span class="sd">        tercile probabilities based on the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Target variable with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data with dimensions (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast array that includes &#39;error&#39; and &#39;prediction&#39; over the historical period.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple (result_, hindcast_prob)</span>
<span class="sd">            result_  : xarray.DataArray or numpy array with the forecast&#39;s [error, prediction].</span>
<span class="sd">            hindcast_prob : xarray.DataArray of shape (probability=3, Y, X) with PB, PN, and PA.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Chunk sizes for parallel processing</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align the time dimension</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Squeeze the forecast predictor data if needed</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># We&#39;ll apply our polynomial regression in parallel across Y,X. </span>
        <span class="c1"># Because we are forecasting a single point in time, y_test is unknown, so we omit it or set it to NaN.</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># shape (Y,X)</span>

        <span class="c1"># Create a Dask client</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply fit_predict to get the forecast for each grid cell </span>
        <span class="c1"># We&#39;ll produce shape (2,) for each cell: [error, prediction]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>                         <span class="c1"># shape (T, features)</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span> <span class="p">()],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>

        <span class="c1"># Compute and close the client</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_RandomForest_XGBoost_ML_Stacking</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform Stacking Ensemble with RandomForest + XGBoost as base learners</span>
<span class="sd">    and a LinearRegression as the meta-model. Also supports:</span>
<span class="sd">      - Hyperparameter tuning via KMeans + GridSearchCV</span>
<span class="sd">      - Parallel spatiotemporal training/prediction using xarray + Dask</span>
<span class="sd">      - Probability computation (terciles) under different distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int, optional</span>
<span class="sd">        Number of CPU cores to use for parallel computation (default=1).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations. </span>
<span class="sd">        One of {&#39;gamma&#39;, &#39;t&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;nonparam&#39;} (default=&#39;gamma&#39;).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for KMeans (default=5).</span>
<span class="sd">    param_grid : dict or None, optional</span>
<span class="sd">        The hyperparameter grid for GridSearchCV over the StackingRegressor. </span>
<span class="sd">        If None, uses a default small example grid.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In scikit-learn, you can reference parameters inside stacking base estimators</span>
<span class="sd">    with naming like &quot;estimators__rf__n_estimators&quot;, &quot;estimators__xgb__learning_rate&quot;, etc. </span>
<span class="sd">    The exact syntax can vary by sklearn version.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">param_grid</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>

        <span class="c1"># Define a minimal default param_grid if none is provided.</span>
        <span class="k">if</span> <span class="n">param_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;rf__n_estimators&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                <span class="s2">&quot;xgb__learning_rate&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                <span class="s2">&quot;xgb__max_depth&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                <span class="s2">&quot;final_estimator__fit_intercept&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="n">param_grid</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 1) HYPERPARAMETER TUNING WITH KMEANS + GRID SEARCH</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.compute_hyperparameters">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.compute_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster grid cells (Y,X) via KMeans on the mean of `predictand` (over T).</span>
<span class="sd">        Then for each cluster, run a cross-validation GridSearch over a StackingRegressor</span>
<span class="sd">        to find best hyperparameters. Store results in DataArrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable with dims (&#39;T&#39;,&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor variables with dims (&#39;T&#39;,&#39;features&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_param_da : xarray.DataArray (dtype=object or str)</span>
<span class="sd">            A DataArray holding best hyperparameter sets (as strings) for each grid cell.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            The integer cluster assignment for each (Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="c1"># Use the first data column as the representative value</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="n">col_name</span><span class="p">]])</span>
    
        <span class="c1"># Drop duplicate (Y,X) rows</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
    
        <span class="c1"># Mask out invalid cells (using the first time slice of predictand)</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                     <span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    
        <span class="c1"># Align with original predictand</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    
        <span class="c1"># --- (b) Set up the stacking model and grid search ---</span>
        <span class="n">base_rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">base_xgb</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">meta_lin</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        <span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;rf&quot;</span><span class="p">,</span> <span class="n">base_rf</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;xgb&quot;</span><span class="p">,</span> <span class="n">base_xgb</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">meta_lin</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">stacking_model</span><span class="p">,</span>
            <span class="n">param_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="c1"># --- (c) For each cluster, compute the cluster-mean time series and run grid search ---</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">)</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">unique_clusters</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)]</span>
        <span class="n">best_params_for_cluster</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="n">mask_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># Aggregate the predictand over Y and X for this cluster to get a time series</span>
            <span class="n">y_cluster</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">predictand</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_c</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
    
            <span class="c1"># Select predictor data corresponding to the times in y_cluster</span>
            <span class="n">predictor_cluster</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
            <span class="n">X_mat</span> <span class="o">=</span> <span class="n">predictor_cluster</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># shape: (time, features)</span>
            <span class="n">y_vec</span> <span class="o">=</span> <span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span>          <span class="c1"># shape: (time,)</span>
    
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_mat</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">)</span>
            <span class="n">best_params_for_cluster</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
    
        <span class="c1"># --- (d) Broadcast best hyperparameter sets (as strings) back to each grid cell ---</span>
        <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params_for_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">best_param_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
    
        <span class="c1"># Align best_param_da with predictand dimensions if necessary</span>
        <span class="n">best_param_da</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">best_param_da</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">best_param_da</span><span class="p">,</span> <span class="n">cluster_da</span></div>


    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 2) FIT + PREDICT FOR A SINGLE GRID CELL</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params_str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a local StackingRegressor with the best hyperparams (parsed from best_params_str),</span>
<span class="sd">        then predict on X_test, returning [error, prediction].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : np.ndarray, shape (n_samples, n_features)</span>
<span class="sd">        y_train : np.ndarray, shape (n_samples,)</span>
<span class="sd">        X_test :  np.ndarray, shape (n_features,) or (1, n_features)</span>
<span class="sd">        y_test :  float or np.nan</span>
<span class="sd">        best_params_str : str</span>
<span class="sd">            String of best_params (e.g. &quot;{&#39;estimators__rf__n_estimators&#39;:100, ...}&quot;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray of shape (2,)</span>
<span class="sd">            [error, predicted_value]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_params_str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

        <span class="c1"># Parse param dictionary</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">)</span>  <span class="c1"># or safer parse, e.g. json.loads</span>

        <span class="c1"># Build fresh model</span>
        <span class="n">base_rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">base_xgb</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">meta_lin</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        <span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;rf&quot;</span><span class="p">,</span> <span class="n">base_rf</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;xgb&quot;</span><span class="p">,</span> <span class="n">base_xgb</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">meta_lin</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Set best_params</span>
        <span class="n">stacking_model</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">X_c</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_c</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">X_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="c1"># e.g., clamp negative if precipitation</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">err</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 3) PARALLELIZED MODEL TRAINING &amp; PREDICTION OVER SPACE</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_param_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parallel fit/predict across the entire spatial domain, using cluster-based hyperparams.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training data (predictors) with dims (&#39;T&#39;,&#39;features&#39;).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training target with dims (&#39;T&#39;,&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test data (predictors), shape (features,) or broadcastable across (Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test target with dims (&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            The per-grid best_params from compute_hyperparameters (as strings).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;), where &#39;output&#39; = [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Squeeze test data</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># best_params_str</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 4) PROBABILITY CALCULATION METHODS</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Student&#39;s t-based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>

        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-based method using the Gaussian CDF.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 5) COMPUTE PROBABILITIES OVER HISTORICAL HINDCAST</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>  <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># 6) FORECAST METHOD</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_ML_Stacking.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_ML_Stacking.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">Predictant</span><span class="p">,</span> 
        <span class="n">clim_year_start</span><span class="p">,</span> 
        <span class="n">clim_year_end</span><span class="p">,</span> 
        <span class="n">Predictor</span><span class="p">,</span> 
        <span class="n">hindcast_det</span><span class="p">,</span> 
        <span class="n">Predictor_for_year</span><span class="p">,</span> 
        <span class="n">best_param_da</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a forecast for a single time (e.g., future year), then compute </span>
<span class="sd">        tercile probabilities from the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data with dims (T, Y, X), used for climatological terciles.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data, dims (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast, dims (output=[error,prediction], T, Y, X).</span>
<span class="sd">            Used to compute error variance or error samples.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            Grid-based hyperparameters from compute_hyperparameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;) =&gt; [error, prediction].</span>
<span class="sd">            For a forecast, the &#39;error&#39; will generally be NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; tercile probabilities PB, PN, PA.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need a dummy y_test array, because fit_predict expects y_test</span>
        <span class="c1"># but we don&#39;t have actual future obs.</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># shape (Y, X)</span>

        <span class="c1"># Prepare chunk sizes for parallel</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align times, typically we set Predictor[&#39;T&#39;] = Predictant[&#39;T&#39;]</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># Squeeze the forecast predictor</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># 1) Fit+predict with the stacked model in parallel, returning [error, pred]</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>                          <span class="c1"># X_train</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>  <span class="c1"># y_train</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>               <span class="c1"># X_test</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span> <span class="c1"># y_test (dummy)</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># best_params_str</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>  <span class="c1"># We&#39;ll get shape (2,) =&gt; [err, pred]</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>



<div class="viewcode-block" id="WAS_MLP">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_MLP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform MLP (Multi-Layer Perceptron) regression on spatiotemporal</span>
<span class="sd">    datasets for climate prediction, with hyperparameter tuning via clustering + grid search.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int</span>
<span class="sd">        Number of CPU cores to use for parallel computation.</span>
<span class="sd">    dist_method : str</span>
<span class="sd">        Distribution method for tercile probability calculations. </span>
<span class="sd">        One of {&#39;gamma&#39;, &#39;t&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;nonparam&#39;}.</span>
<span class="sd">    n_clusters : int</span>
<span class="sd">        Number of clusters to use for KMeans.</span>
<span class="sd">    param_grid : dict or None</span>
<span class="sd">        The hyperparameter search grid for MLPRegressor. </span>
<span class="sd">        If None, a default grid is used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores, dist_method, n_clusters, param_grid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">param_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        
        <span class="c1"># If no param_grid is provided, create a minimal default grid.</span>
        <span class="k">if</span> <span class="n">param_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,)],</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;sigm&#39;</span><span class="p">],</span>
                <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;adam&#39;</span><span class="p">],</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                <span class="s1">&#39;max_iter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="n">param_grid</span>

    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 1) HYPERPARAMETER TUNING VIA CLUSTERING + GRID SEARCH</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.compute_hyperparameters">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.compute_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs KMeans clustering on the spatial mean of `predictand`, then for each cluster</span>
<span class="sd">        runs a cross-validation grid search on MLP hyperparameters using the cluster-mean time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable with dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;).</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor variables with dimensions (&#39;T&#39;, &#39;features&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hl_array, act_array, lr_array, cluster_da : xarray.DataArray</span>
<span class="sd">            DataArrays storing the best local hyperparameters for each grid cell</span>
<span class="sd">            (derived from cluster membership) and the cluster assignments.</span>
<span class="sd">            Note: We show example outputs for hidden_layer_sizes, activation, learning_rate_init. </span>
<span class="sd">                  You can extend this to all parameters in your `param_grid`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">predictand_</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">predictand</span><span class="p">)</span>

        <span class="c1"># (a) KMeans clustering on predictand (dropping the &#39;T&#39; dimension)</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        
        <span class="c1"># Use one representative column (e.g., the first data column) for clustering.</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">col_name</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="c1"># Convert clusters back to xarray</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        
        <span class="c1"># Mask out invalid cells (using the first time slice of predictand)</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                     <span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        
        <span class="c1"># Align with original predictand</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
    
        <span class="c1"># (b) Prepare GridSearchCV for MLP</span>
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">MLPRegressor</span><span class="p">(),</span>
            <span class="n">param_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># or use a time-series split if needed</span>
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="n">best_params_for_cluster</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="c1"># For each cluster, run grid search on the cluster-averaged time series</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># Compute the mean over the spatial dimensions for the cluster</span>
            <span class="n">y_cluster</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">predictand_</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_c</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Select the corresponding times in predictor</span>
            <span class="n">predictor_cluster</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">X_mat</span> <span class="o">=</span> <span class="n">predictor_cluster</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># (time, features)</span>
            <span class="n">y_vec</span> <span class="o">=</span> <span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span>          <span class="c1"># (time,)</span>
            
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_mat</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">)</span>
            <span class="n">best_params_for_cluster</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
    
        <span class="c1"># (c) Broadcast best hyperparameters to each grid cell</span>
        <span class="n">hl_array</span>  <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">act_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">lr_array</span>  <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">maxiter_array</span>  <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params_for_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">hl_str</span>  <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">act_str</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;activation&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">lr_val</span>  <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">maxiter_val</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_iter&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">hl_array</span>  <span class="o">=</span> <span class="n">hl_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">hl_str</span><span class="p">)</span>
            <span class="n">act_array</span> <span class="o">=</span> <span class="n">act_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">act_str</span><span class="p">)</span>
            <span class="n">lr_array</span>  <span class="o">=</span> <span class="n">lr_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span>  <span class="n">other</span><span class="o">=</span><span class="n">lr_val</span><span class="p">)</span>
            <span class="n">maxiter_array</span>  <span class="o">=</span> <span class="n">maxiter_array</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span>  <span class="n">other</span><span class="o">=</span><span class="n">maxiter_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hl_array</span><span class="p">,</span> <span class="n">act_array</span><span class="p">,</span> <span class="n">lr_array</span><span class="p">,</span> <span class="n">maxiter_array</span><span class="p">,</span> <span class="n">cluster_da</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 2) FIT + PREDICT ON A SINGLE GRID CELL</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span>
                    <span class="n">hl_sizes</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="n">lr_init</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trains an MLP (with local hyperparams) on the provided training data, then predicts on X_test.</span>
<span class="sd">        Returns [error, prediction].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : np.ndarray, shape (n_samples, n_features)</span>
<span class="sd">        y_train : np.ndarray, shape (n_samples,)</span>
<span class="sd">        X_test  : np.ndarray, shape (n_features,) or (1, n_features)</span>
<span class="sd">        y_test  : float or np.nan</span>
<span class="sd">        hl_sizes : str (stored as string in xarray) or None</span>
<span class="sd">        activation : str</span>
<span class="sd">        lr_init : float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray of shape (2,)</span>
<span class="sd">            [error, predicted_value]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert hidden_layer_sizes from string if needed</span>
        <span class="k">if</span> <span class="n">hl_sizes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hl_sizes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">hl_sizes</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">hl_sizes</span><span class="p">)</span>  <span class="c1"># parse string into tuple</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mlp_model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">hl_sizes</span> <span class="k">if</span> <span class="n">hl_sizes</span> <span class="k">else</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span> <span class="k">if</span> <span class="n">activation</span> <span class="k">else</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">maxiter</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">maxiter</span><span class="p">)</span> <span class="k">else</span> <span class="mi">6000</span><span class="p">,</span>
            <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">lr_init</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lr_init</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.001</span>
            <span class="c1"># learning_rate_init=lr_init if lr_init else 0.001</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">X_c</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_c</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">mlp_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">X_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mlp_preds</span> <span class="o">=</span> <span class="n">mlp_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="n">mlp_preds</span><span class="p">[</span><span class="n">mlp_preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># clip negative if it&#39;s precipitation</span>

            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="p">(</span><span class="n">y_test</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span> <span class="k">else</span> <span class="p">(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">mlp_preds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">err</span><span class="p">,</span> <span class="n">mlp_preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 3) PARALLELIZED MODEL PREDICTION OVER SPACE</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
        <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span>
        <span class="n">hl_array</span><span class="p">,</span> <span class="n">act_array</span><span class="p">,</span> <span class="n">lr_array</span><span class="p">,</span> <span class="n">maxiter_array</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs MLP fit/predict for each (Y,X) cell in parallel, using cluster-based hyperparams.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictors with dims (&#39;T&#39;,&#39;features&#39;).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training target with dims (&#39;T&#39;,&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictors, shape (&#39;features&#39;,) or broadcastable.</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test target with dims (&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        hl_array, act_array, lr_array : xarray.DataArray</span>
<span class="sd">            Local best hyperparameters from compute_hyperparameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;, &#39;Y&#39;, &#39;X&#39;), where &#39;output&#39; = [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>                           
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">hl_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">act_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">lr_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span>  <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">maxiter_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span>  <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">(),</span>               <span class="c1"># hidden_layer_sizes</span>
                <span class="p">(),</span>               <span class="c1"># activation</span>
                <span class="p">(),</span>                <span class="c1"># learning_rate_init</span>
                <span class="p">()</span>                <span class="c1"># max_iter                </span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Return DataArray with dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;) =&gt; [error, prediction]</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 4) TERCILE PROBABILITY METHODS</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_MLP.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>

        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_MLP.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_MLP.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-based method using the Gaussian CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_MLP.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 5) COMPUTE PROBABILITIES OVER HISTORICAL HINDCAST</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>  <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


        
    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 6) FORECAST METHOD</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_MLP.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_MLP.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">Predictant</span><span class="p">,</span> 
        <span class="n">clim_year_start</span><span class="p">,</span> 
        <span class="n">clim_year_end</span><span class="p">,</span> 
        <span class="n">Predictor</span><span class="p">,</span> 
        <span class="n">hindcast_det</span><span class="p">,</span> 
        <span class="n">Predictor_for_year</span><span class="p">,</span> 
        <span class="n">hl_array</span><span class="p">,</span> <span class="n">act_array</span><span class="p">,</span> <span class="n">lr_array</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a forecast for a single future time (e.g., future year), </span>
<span class="sd">        then compute tercile probabilities using the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data with dims (T, Y, X), used for computing climatological terciles.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data with dims (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=[error,prediction], T, Y, X).</span>
<span class="sd">            Used to compute error variance or error samples.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>
<span class="sd">        hl_array, act_array, lr_array : xarray.DataArray</span>
<span class="sd">            Hyperparameters from `compute_hyperparameters`, </span>
<span class="sd">            each with dims (Y, X) specifying local MLP settings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;), containing [error, prediction]. </span>
<span class="sd">            For a forecast, the &quot;error&quot; is generally NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; PB, PN, PA tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Provide a dummy y_test of NaNs (since we don&#39;t have future obs)</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># shape (Y, X)</span>

        <span class="c1"># Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align times</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># 1) Fit+predict in parallel for each grid cell</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>                              <span class="c1"># X_train</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>  <span class="c1"># y_train</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>                   <span class="c1"># X_test</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">hl_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">act_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">lr_array</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span>  <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>

            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">(),</span>               <span class="c1"># hidden_layer_sizes</span>
                <span class="p">(),</span>               <span class="c1"># activation</span>
                <span class="p">()</span>                <span class="c1"># learning_rate_init</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_RandomForest_XGBoost_Stacking_MLP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that performs stacking of RandomForest + XGBoost (base learners)</span>
<span class="sd">    and an MLPRegressor (meta-learner). Features:</span>

<span class="sd">      - Hyperparameter tuning via cluster-based GridSearchCV</span>
<span class="sd">      - Parallel spatiotemporal training/prediction</span>
<span class="sd">      - Tercile probability calculations with various distributions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int</span>
<span class="sd">        Number of CPU cores to use for parallel computation.</span>
<span class="sd">    dist_method : str</span>
<span class="sd">        Distribution method for tercile probability calculations.</span>
<span class="sd">        One of {&#39;gamma&#39;, &#39;t&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;nonparam&#39;}.</span>
<span class="sd">    n_clusters : int</span>
<span class="sd">        Number of clusters for KMeans.</span>
<span class="sd">    param_grid : dict or None</span>
<span class="sd">        Hyperparameter search grid for GridSearchCV. If None, a minimal default is used.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - When referencing parameters inside stacking estimators, scikit-learn uses</span>
<span class="sd">      &quot;estimators__&lt;est_name&gt;__&lt;param_name&gt;&quot; for base models, or</span>
<span class="sd">      &quot;final_estimator__&lt;param&gt;&quot; for the meta-model. For example:</span>
<span class="sd">        - &quot;estimators__rf__n_estimators&quot; =&gt; sets n_estimators for &#39;rf&#39;</span>
<span class="sd">        - &quot;estimators__xgb__max_depth&quot;   =&gt; sets max_depth for &#39;xgb&#39;</span>
<span class="sd">        - &quot;final_estimator__hidden_layer_sizes&quot; =&gt; sets hidden_layer_sizes in MLPRegressor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">param_grid</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>

        <span class="c1"># Define a minimal param_grid if none is provided</span>
        <span class="k">if</span> <span class="n">param_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1"># Example hyperparams for RandomForest</span>
                <span class="s2">&quot;rf__n_estimators&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
                <span class="c1"># Example hyperparams for XGBoost</span>
                <span class="s2">&quot;xgb__max_depth&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="s2">&quot;xgb__learning_rate&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                <span class="c1"># Example hyperparams for MLP meta-learner</span>
                <span class="s2">&quot;final_estimator__hidden_layer_sizes&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">50</span><span class="p">,),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">)],</span>
                <span class="s2">&quot;final_estimator__activation&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;relu&quot;</span><span class="p">,</span> <span class="s2">&quot;tanh&quot;</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="n">param_grid</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 1) HYPERPARAMETER TUNING VIA KMEANS + GRID SEARCH</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.compute_hyperparameters">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.compute_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster grid cells (Y,X) via KMeans on the mean of `predictand`.</span>
<span class="sd">        For each cluster, run GridSearchCV on a StackingRegressor that has:</span>
<span class="sd">         - RandomForest (rf) + XGBoost (xgb) as base learners</span>
<span class="sd">         - MLPRegressor as meta-learner</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable with dims (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;).</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor variables with dims (&#39;T&#39;,&#39;features&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            DataArray storing the best hyperparams (as strings) for each grid cell.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            The integer cluster assignment for each (Y,X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (a) KMeans clustering on a representative predictand (dropping &#39;T&#39;)</span>
        <span class="c1"># Convert to DataFrame, drop the time column, remove rows with missing values,</span>
        <span class="c1"># and drop duplicate (Y,X) so that each grid cell appears only once.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="c1"># Use one representative column (e.g., the first data column) for clustering.</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="n">col_name</span><span class="p">]])</span>
    
        <span class="c1"># Convert clusters back to xarray: drop duplicates so that each (Y,X) appears once.</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        
        <span class="c1"># Mask out invalid cells (using the first time slice of predictand)</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                     <span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="c1"># Align cluster_da with the original predictand</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    
        <span class="c1"># (b) Prepare the stacking model template</span>
        <span class="n">base_rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">base_xgb</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">meta_mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">base_rf</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">base_xgb</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">meta_mlp</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">stacking_model</span><span class="p">,</span>
            <span class="n">param_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">)</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">unique_clusters</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)]</span>
        <span class="n">best_params_for_cluster</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="c1"># (c) For each cluster, run cross-validation on the cluster-aggregated time series.</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="n">mask_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># Aggregate predictand for grid cells in cluster c by averaging over Y, X.</span>
            <span class="n">y_cluster</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">predictand</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_c</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
    
            <span class="c1"># Select predictor values for the same time stamps.</span>
            <span class="n">predictor_cluster</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
            <span class="n">X_mat</span> <span class="o">=</span> <span class="n">predictor_cluster</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># shape: (time, features)</span>
            <span class="n">y_vec</span> <span class="o">=</span> <span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span>          <span class="c1"># shape: (time,)</span>
    
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_mat</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">)</span>
            <span class="n">best_params_for_cluster</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
    
        <span class="c1"># (d) Broadcast the best hyperparameters to each grid cell (stored as strings)</span>
        <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params_for_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">best_param_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">best_param_da</span><span class="p">,</span> <span class="n">cluster_da</span></div>


    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 2) FIT + PREDICT FOR A SINGLE GRID CELL</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params_str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single grid cell, parse the local best_params dict, set them on the </span>
<span class="sd">        StackingRegressor (with RF + XGB base, MLP meta), train and predict.</span>
<span class="sd">        </span>
<span class="sd">        Returns [error, prediction].</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : np.ndarray, shape (n_samples, n_features)</span>
<span class="sd">        y_train : np.ndarray, shape (n_samples,)</span>
<span class="sd">        X_test :  np.ndarray, shape (n_features,) or (1, n_features)</span>
<span class="sd">        y_test :  float or np.nan</span>
<span class="sd">        best_params_str : str</span>
<span class="sd">            Local best hyperparams as a stringified dict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray of shape (2,)</span>
<span class="sd">            [error, prediction]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If there&#39;s no valid best_params or no data, return NaNs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_params_str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

        <span class="c1"># Parse the params</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">)</span>  <span class="c1"># could use json.loads(...) if you prefer</span>

        <span class="c1"># Create fresh base models &amp; meta-model</span>
        <span class="n">base_rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">base_xgb</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">meta_mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">base_rf</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">base_xgb</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">meta_mlp</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Apply local best params</span>
        <span class="n">stacking_model</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">X_c</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_c</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">X_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># clip negatives if it&#39;s precipitation</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span> <span class="k">else</span> <span class="p">(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">err</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 3) PARALLELIZED COMPUTE_MODEL</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_param_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parallel training + prediction across the entire spatial domain,</span>
<span class="sd">        referencing local best_params for each grid cell.</span>

<span class="sd">        Returns an xarray.DataArray with dim &#39;output&#39; = [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># chunk sizes for parallel</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Parallel execution with Dask</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>
                <span class="p">(),</span>
                <span class="p">()</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 4) PROBABILITY CALCULATION METHODS</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>

        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


        
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-based method using the Gaussian CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                              <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> \
                          <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 5) COMPUTE TERCILE PROBABILITIES (HINDCAST)</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>  <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># 6) FORECAST METHOD</span>
    <span class="c1"># -----------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_RandomForest_XGBoost_Stacking_MLP.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_RandomForest_XGBoost_Stacking_MLP.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">Predictant</span><span class="p">,</span> 
        <span class="n">clim_year_start</span><span class="p">,</span> 
        <span class="n">clim_year_end</span><span class="p">,</span> 
        <span class="n">Predictor</span><span class="p">,</span> 
        <span class="n">hindcast_det</span><span class="p">,</span> 
        <span class="n">Predictor_for_year</span><span class="p">,</span> 
        <span class="n">best_param_da</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a forecast for a single future time (e.g., future year),</span>
<span class="sd">        then compute tercile probabilities from the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data with dims (T, Y, X) used for computing climatological terciles.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data, shape (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=[error,prediction], T, Y, X).</span>
<span class="sd">            Used to estimate error variance or error samples.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            Grid-based best hyperparams from `compute_hyperparameters`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;) =&gt; [error, prediction].</span>
<span class="sd">            For a true forecast, the &#39;error&#39; is typically NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; PB, PN, PA tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Provide a dummy y_test =&gt; shape (Y, X), all NaN</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># 2) Fit+predict in parallel =&gt; produce shape (2, Y, X) =&gt; [error, prediction]</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test (dummy)</span>
                <span class="p">()</span>                <span class="c1"># best_params_str</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>

 

<div class="viewcode-block" id="WAS_Stacking_Ridge">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_Stacking_Ridge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that performs stacking of the following base learners:</span>
<span class="sd">      - RandomForestRegressor (rf)</span>
<span class="sd">      - XGBRegressor (xgb)</span>
<span class="sd">      - MLPRegressor (mlp_base)</span>
<span class="sd">    and uses Ridge as the meta-model.</span>

<span class="sd">    Like the previous classes, this supports:</span>
<span class="sd">      - Cluster-based hyperparameter tuning via KMeans + GridSearchCV</span>
<span class="sd">      - Parallel spatiotemporal training/prediction with xarray + dask</span>
<span class="sd">      - Various distribution methods for tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int</span>
<span class="sd">        Number of CPU cores to use for parallel computation.</span>
<span class="sd">    dist_method : str</span>
<span class="sd">        Distribution method for tercile probability calculations:</span>
<span class="sd">        One of {&#39;gamma&#39;, &#39;t&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;nonparam&#39;}.</span>
<span class="sd">    n_clusters : int</span>
<span class="sd">        Number of clusters for KMeans (used in hyperparameter tuning).</span>
<span class="sd">    param_grid : dict or None</span>
<span class="sd">        Hyperparameter grid for GridSearchCV. If None, a minimal default is used.</span>

<span class="sd">    Example for param_grid:</span>
<span class="sd">      {</span>
<span class="sd">        &quot;estimators__rf__n_estimators&quot;: [50, 100],</span>
<span class="sd">        &quot;estimators__xgb__max_depth&quot;: [3, 6],</span>
<span class="sd">        &quot;estimators__mlp_base__hidden_layer_sizes&quot;: [(20,), (50, 10)],</span>
<span class="sd">        &quot;final_estimator__alpha&quot;: [0.1, 0.9, 5.0],</span>
<span class="sd">      }</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    compute_hyperparameters(predictand, predictor)</span>
<span class="sd">        Performs cluster-based hyperparam tuning, returns best-param DataArray.</span>
<span class="sd">    fit_predict(X_train, y_train, X_test, y_test, best_params_str)</span>
<span class="sd">        Trains a local stacking model with the best hyperparams for that grid cell, then predicts.</span>
<span class="sd">    compute_model(X_train, y_train, X_test, y_test, best_param_da)</span>
<span class="sd">        Calls fit_predict(...) in parallel across all grid cells.</span>
<span class="sd">    compute_prob(Predictant, clim_year_start, clim_year_end, hindcast_det)</span>
<span class="sd">        Computes tercile probabilities using self.dist_method.</span>
<span class="sd">    forecast(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det, Predictor_for_year, best_param_da)</span>
<span class="sd">        Fits a forecast for a single future year (or time) and calculates tercile probabilities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">param_grid</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>

        <span class="c1"># Minimal default grid if none is provided:</span>
        <span class="k">if</span> <span class="n">param_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;rf__n_estimators&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                <span class="s2">&quot;xgb__max_depth&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                <span class="s2">&quot;mlp_base__hidden_layer_sizes&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
                <span class="s2">&quot;final_estimator__alpha&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span> <span class="o">=</span> <span class="n">param_grid</span>

    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 1) HYPERPARAMETER TUNING VIA CLUSTERING + GRID SEARCH</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.compute_hyperparameters">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.compute_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs KMeans clustering on the mean of `predictand` (over time).</span>
<span class="sd">        Then, for each cluster, runs a cross-validation GridSearch over a stacking model with:</span>
<span class="sd">          - RF, XGB, MLP (as base estimators)</span>
<span class="sd">          - Ridge (as the meta-estimator).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable with dims (&#39;T&#39;,&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor variables with dims (&#39;T&#39;,&#39;features&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            DataArray storing best hyperparams (as string) per grid cell.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster assignment for each (Y,X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- (a) Clustering: mimic WAS_Ridge ---</span>
        <span class="c1"># Convert predictand to DataFrame, drop the time column, and remove duplicates over (Y, X)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="c1"># Use the first data column (e.g., &quot;mean_val&quot;) as representative for clustering</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="n">col_name</span><span class="p">]])</span>
        <span class="c1"># Drop duplicates so that each grid cell appears only once</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
    
        <span class="c1"># Create a cluster DataArray and mask out invalid cells using the first time slice</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                     <span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="c1"># Align cluster_da with the original predictand</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    
        <span class="c1"># --- (b) Build the stacking model ---</span>
        <span class="n">rf_model</span>   <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">xgb_model</span>  <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">mlp_base</span>   <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
        <span class="n">ridge_meta</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">stacking_ridge</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;rf&quot;</span><span class="p">,</span> <span class="n">rf_model</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;xgb&quot;</span><span class="p">,</span> <span class="n">xgb_model</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;mlp_base&quot;</span><span class="p">,</span> <span class="n">mlp_base</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">ridge_meta</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="c1"># --- (c) Set up GridSearchCV ---</span>
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">stacking_ridge</span><span class="p">,</span>
            <span class="n">param_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_grid</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># or TimeSeriesSplit if appropriate</span>
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">)</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">unique_clusters</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)]</span>
        <span class="n">best_params_for_cluster</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="c1"># --- (d) For each cluster, compute the cluster-mean time series and run grid search ---</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="n">mask_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># Aggregate predictand over Y and X (for cells in cluster c) to get a time series</span>
            <span class="n">y_cluster</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">predictand</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_c</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                          <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Get predictor data for the matching time stamps</span>
            <span class="n">predictor_cluster</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
            <span class="n">X_mat</span> <span class="o">=</span> <span class="n">predictor_cluster</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># shape: (time, features)</span>
            <span class="n">y_vec</span> <span class="o">=</span> <span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span>          <span class="c1"># shape: (time,)</span>
    
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_mat</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">)</span>
            <span class="n">best_params_for_cluster</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
    
        <span class="c1"># --- (e) Broadcast best hyperparameters to every grid cell ---</span>
        <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params_for_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">best_param_da</span> <span class="o">=</span> <span class="n">best_param_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">c_mask</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">best_param_da</span><span class="p">,</span> <span class="n">cluster_da</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 2) FIT + PREDICT FOR A SINGLE GRID CELL</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params_str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single grid cell, parse the best params, instantiate the stacking regressor,</span>
<span class="sd">        fit to local data, and predict.</span>

<span class="sd">        Returns [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_params_str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No valid hyperparams =&gt; return NaN</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

        <span class="c1"># Parse param dict from string</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">best_params_str</span><span class="p">)</span>  <span class="c1"># or use a safer parser if you prefer</span>

        <span class="c1"># Base learners</span>
        <span class="n">rf_model</span>   <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">xgb_model</span>  <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">mlp_base</span>   <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
        <span class="n">ridge_meta</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>

        <span class="n">stacking_ridge</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;rf&quot;</span><span class="p">,</span> <span class="n">rf_model</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;xgb&quot;</span><span class="p">,</span> <span class="n">xgb_model</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;mlp_base&quot;</span><span class="p">,</span> <span class="n">mlp_base</span><span class="p">)],</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="n">ridge_meta</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Apply local best params</span>
        <span class="n">stacking_ridge</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">X_c</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_c</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">stacking_ridge</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">X_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">stacking_ridge</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># clip negative if modeling precip</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">err</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 3) PARALLEL MODELING ACROSS SPACE</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_param_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parallel training + prediction across all spatial grid points.</span>
<span class="sd">        Uses local best hyperparams from best_param_da for each pixel.</span>

<span class="sd">        Returns an xarray.DataArray with dim (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;) =&gt; [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>
                <span class="p">()</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 4) PROBABILITY CALCULATIONS</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
        <span class="c1"># (Implementation of Student’s t-based probabilities)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">ft</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prob</span></div>


<div class="viewcode-block" id="WAS_Stacking_Ridge.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
        <span class="c1"># (Implementation of Gamma-based probabilities)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">prob</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">prob</span></div>


<div class="viewcode-block" id="WAS_Stacking_Ridge.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
        <span class="c1"># (Implementation of Normal-based probabilities)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span>  <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> \
                        <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prob</span></div>


<div class="viewcode-block" id="WAS_Stacking_Ridge.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
        <span class="c1"># (Implementation of Lognormal-based probabilities)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span><span class="o">/</span><span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> \
                    <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">prob</span></div>


<div class="viewcode-block" id="WAS_Stacking_Ridge.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method (requires historical errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>  
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_below</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span>   <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 5) COMPUTE PROBABILITIES (HINDCAST)</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.compute_prob">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>  <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray (T, Y, X)</span>
<span class="sd">            Observed data.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            The start and end years for the climatology.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dims (output=2, T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, T, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Identify climatology slice</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Distinguish distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="s2">&quot;Must be one of [&#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;].&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 6) FORECAST METHOD</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_Stacking_Ridge.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_Stacking_Ridge.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_param_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast for a single future year (or time) and compute tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data with dims (T, Y, X), used for computing climatology thresholds.</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start of climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End of climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data, shape (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=[error,prediction], T, Y, X) </span>
<span class="sd">            for computing error variance or samples.</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the forecast year, shape (features,) or (1, features).</span>
<span class="sd">        best_param_da : xarray.DataArray</span>
<span class="sd">            Local best hyperparams from compute_hyperparameters, shape (Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">            In a real forecast, &quot;error&quot; is typically NaN since we have no future observation.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a dummy y_test (NaN) for the forecast</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># shape (Y, X)</span>

        <span class="c1"># Chunk sizes for parallel</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align times</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># 1) Fit+predict in parallel =&gt; shape (2, Y, X)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>     <span class="c1"># dummy y_test</span>
            <span class="n">best_param_da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># X_train</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y_train</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># X_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># best_params_str</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Tercile probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>


            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Choose &#39;t&#39;,&#39;gamma&#39;,&#39;normal&#39;,&#39;lognormal&#39;,&#39;nonparam&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="n">hindcast_prob_out</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="c1">#.drop_vars(&#39;T&#39;).squeeze()</span>

        <span class="c1"># Return [error, prediction] plus tercile probabilities</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">hindcast_prob_out</span></div>
</div>



<div class="viewcode-block" id="WAS_LogisticRegression_Model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_LogisticRegression_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A logistic regression-based approach to classifying climate data into terciles and </span>
<span class="sd">    then predicting the class probabilities for new data. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb_cores : int, optional</span>
<span class="sd">            Number of CPU cores to use for Dask parallelization (default = 1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the number of cores and a distribution method attribute (the latter might be used in future expansions)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>


<div class="viewcode-block" id="WAS_LogisticRegression_Model.classify">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model.classify">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classifies the values of a 1D array `y` into terciles. </span>
<span class="sd">        We only use a slice of y for the training/climatology period to define the 33rd and 67th percentiles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            The time series of values we want to classify (e.g., rainfall).</span>
<span class="sd">        index_start, index_end : int</span>
<span class="sd">            The start and end indices defining the climatology/training window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_class : array, shape (n_samples,)</span>
<span class="sd">            The tercile class of each value in `y`, coded as 0 (below), 1 (middle), or 2 (above).</span>
<span class="sd">        tercile_33 : float</span>
<span class="sd">            The 33rd percentile threshold used to split the data.</span>
<span class="sd">        tercile_67 : float</span>
<span class="sd">            The 67th percentile threshold used to split the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a mask of non-NaN entries</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># Check if there&#39;s any valid data</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># Compute the 33% and 67% thresholds from the specified slice</span>
            <span class="n">terciles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">index_start</span><span class="p">:</span><span class="n">index_end</span><span class="p">],</span> <span class="p">[</span><span class="mi">33</span><span class="p">,</span> <span class="mi">67</span><span class="p">])</span>
            <span class="c1"># Digitize assigns each y-value to a bin: </span>
            <span class="c1"># bin 0: below tercile_33, bin 1: [tercile_33, tercile_67), bin 2: &gt;= tercile_67</span>
            <span class="n">y_class</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">terciles</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">y_class</span><span class="p">,</span> <span class="n">terciles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">terciles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If data is invalid, return arrays filled with NaN</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="WAS_LogisticRegression_Model.fit_predict">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model.fit_predict">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trains a logistic regression model on (x, y) and predicts class probabilities for x_test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape (n_samples, n_features)</span>
<span class="sd">            Predictor data for training.</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            Class labels (0, 1, 2) for training.</span>
<span class="sd">        x_test : array-like, shape (n_features,)</span>
<span class="sd">            Predictor data for the forecast/unknown scenario.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        preds_proba : np.ndarray, shape (3,)</span>
<span class="sd">            Probability of each of the 3 tercile classes. </span>
<span class="sd">            If fewer than 3 classes were present in training, the array is padded with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize a logistic regression model. &#39;lbfgs&#39; is a popular solver.</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">)</span>

        <span class="c1"># Identify rows with valid data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># Subset to valid entries</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Fit logistic regression</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
            
            <span class="c1"># Reshape x_test if it is 1D</span>
            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Predict probabilities for each class</span>
            <span class="n">preds_proba</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  <span class="c1"># shape (n_classes,)</span>

            <span class="c1"># If the model trained on fewer than 3 classes, we pad probabilities</span>
            <span class="k">if</span> <span class="n">preds_proba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">preds_proba_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">preds_proba_padded</span><span class="p">[:</span><span class="n">preds_proba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">preds_proba</span>
                <span class="n">preds_proba</span> <span class="o">=</span> <span class="n">preds_proba_padded</span>
            
            <span class="k">return</span> <span class="n">preds_proba</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no valid data to fit, return NaNs</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_LogisticRegression_Model.compute_class">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model.compute_class">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns tercile classes for each point in the `Predictant` array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            The observed variable (e.g., rainfall) with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            First year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            Last year of the climatology period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Predictant_class : xarray.DataArray</span>
<span class="sd">            The tercile class for each grid cell and time, labeled 0, 1, or 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Identify the index range for the climatology period</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        
        <span class="c1"># Use xr.apply_ufunc to apply `classify` along the time dimension (&#39;T&#39;)</span>
        <span class="n">Predictant_class</span><span class="p">,</span> <span class="n">tercile_33</span><span class="p">,</span> <span class="n">tercile_67</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classify</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,)],</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index_start&#39;</span><span class="p">:</span> <span class="n">index_start</span><span class="p">,</span> <span class="s1">&#39;index_end&#39;</span><span class="p">:</span> <span class="n">index_end</span><span class="p">},</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Return the classified data, ensuring dimensions are consistent</span>
        <span class="k">return</span> <span class="n">Predictant_class</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_LogisticRegression_Model.compute_model">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes logistic-regression-based class probabilities for each grid cell in `y_train`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Predictors with dimensions (T, features).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Tercile class labels with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictors with dimensions (T, features).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Class probabilities (3) for each grid cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine chunk sizes based on user-defined number of cores</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">)</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">)</span>
        
        <span class="c1"># Align time dimension</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        
        <span class="c1"># Squeeze unnecessary dimensions from X_test for proper shape</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Create a Dask client for parallel processing</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply the logistic model in parallel across spatial dimensions</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,)],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,)],</span>  
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>  
        <span class="p">)</span>
        
        <span class="c1"># Compute the Dask result</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span></div>


<div class="viewcode-block" id="WAS_LogisticRegression_Model.forecast">
<a class="viewcode-back" href="../../wass2s.html#wass2s.was_machine_learning.WAS_LogisticRegression_Model.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the trained logistic model on a single forecast year.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            The observed variable (T, Y, X), used for classification (training).</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            The training predictors (T, features).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictors for the forecast period or year, shape (features,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Probability of each tercile class (PB, PN, PA) for every grid cell, </span>
<span class="sd">            after removing the time dimension (because it&#39;s just one forecast).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define chunk sizes for parallelization</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">)</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">)</span>
        
        <span class="c1"># Align &#39;T&#39; dimension so it matches</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="c1"># Parallel approach with Dask</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,)],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,)],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
        <span class="p">)</span>

        <span class="c1"># Compute final result, close client</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Label the probability dimension with PB, PN, PA</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>

        <span class="c1"># Drop the time dimension (we&#39;re forecasting a single instance) and reorder dimensions</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>