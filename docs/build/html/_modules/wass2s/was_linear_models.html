

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_linear_models &mdash; wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel. 0.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1e28cc32"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_linear_models</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_linear_models</h1><div class="highlight"><pre>
<span></span><span class="c1">################################### Modules ###################################</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn</span><span class="w"> </span><span class="kn">import</span> <span class="n">linear_model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomizedSearchCV</span><span class="p">,</span> <span class="n">cross_val_score</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">statsmodels.api</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.stats.outliers_influence</span><span class="w"> </span><span class="kn">import</span> <span class="n">variance_inflation_factor</span> <span class="k">as</span> <span class="n">VIF</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.stats.anova</span><span class="w"> </span><span class="kn">import</span> <span class="n">anova_lm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">weibull_min</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">nbinom</span><span class="p">,</span> <span class="n">loguniform</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sig</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">CubicSpline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">fsolve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xeofs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xe</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">cpu_count</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dask.distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optuna</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wass2s.utils</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="c1">#### Add Nonexcedance function for all models ##############################################</span>

<div class="viewcode-block" id="WAS_LinearRegression_Model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_LinearRegression_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to perform linear regression modeling on spatiotemporal datasets for climate prediction.</span>

<span class="sd">    This class is designed to work with Dask and Xarray for parallelized, high-performance </span>
<span class="sd">    regression computations across large datasets with spatial and temporal dimensions. The primary </span>
<span class="sd">    methods are for fitting the model, making predictions, and calculating probabilistic predictions </span>
<span class="sd">    for climate terciles. </span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_cores : int, optional</span>
<span class="sd">        The number of CPU cores to use for parallel computation (default is 1).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations. One of</span>
<span class="sd">        {&quot;t&quot;,&quot;gamma&quot;,&quot;normal&quot;,&quot;lognormal&quot;,&quot;nonparam&quot;}. Default = &quot;gamma&quot;.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fit_predict(x, y, x_test, y_test=None)</span>
<span class="sd">        Fits a linear regression model, makes predictions, and calculates error if y_test is provided.</span>

<span class="sd">    compute_model(X_train, y_train, X_test, y_test)</span>
<span class="sd">        Applies the linear regression model across a dataset using parallel computation with Dask.</span>

<span class="sd">    compute_prob(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det)</span>
<span class="sd">        Computes tercile probabilities for hindcast predictions over specified years.</span>

<span class="sd">    forecast(Predictant, clim_year_start, clim_year_end, Predictor, hindcast_det, Predictor_for_year)</span>
<span class="sd">        Generates a single-year forecast and computes tercile probabilities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_LinearRegression_Model.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the WAS_LinearRegression_Model with a specified number of CPU cores.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb_cores : int, optional</span>
<span class="sd">            Number of CPU cores to use for parallel computation, by default 1.</span>
<span class="sd">        dist_method : str, optional</span>
<span class="sd">            Distribution method to compute tercile probabilities, by default &quot;gamma&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span></div>

    
<div class="viewcode-block" id="WAS_LinearRegression_Model.fit_predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.fit_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a linear regression model to the provided training data, makes predictions </span>
<span class="sd">        on the test data, and calculates the prediction error (if y_test is provided).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape (n_samples, n_features)</span>
<span class="sd">            Training data (predictors).</span>
<span class="sd">        y : array-like, shape (n_samples,)</span>
<span class="sd">            Training targets.</span>
<span class="sd">        x_test : array-like, shape (n_features,) or (1, n_features)</span>
<span class="sd">            Test data (predictors).</span>
<span class="sd">        y_test : float or None</span>
<span class="sd">            Test target value. If None, no error is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            If y_test is not None, returns [error, prediction].</span>
<span class="sd">            If y_test is None, returns [prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># clip negative if modeling precipitation</span>

            <span class="k">if</span> <span class="n">y_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only return prediction if y_test is None</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no valid data, return NaNs</span>
            <span class="k">if</span> <span class="n">y_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="WAS_LinearRegression_Model.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies linear regression across a spatiotemporal dataset in parallel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictors with dims (&#39;T&#39;,&#39;features&#39;).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training targets with dims (&#39;T&#39;,&#39;Y&#39;,&#39;X&#39;).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictors, shape (&#39;features&#39;,) or (T, features).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test targets with dims (&#39;Y&#39;,&#39;X&#39;), or broadcastable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (&#39;output&#39;,&#39;Y&#39;,&#39;X&#39;), where &#39;output&#39;=[error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        
        <span class="c1"># Align times</span>
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span> <span class="p">()],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    
   <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_LinearRegression_Model._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_LinearRegression_Model.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_LinearRegression_Model.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_LinearRegression_Model.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_LinearRegression_Model.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># --------------------------------------------------------------------------</span>
    <span class="c1">#  FORECAST METHOD</span>
    <span class="c1"># --------------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_LinearRegression_Model.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LinearRegression_Model.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a single-year forecast using linear regression, then computes </span>
<span class="sd">        tercile probabilities using self.dist_method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data with dims (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year for climatology</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year for climatology</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data with dims (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=[error,prediction], T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Single-year predictor with shape (features,) or (1, features).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction]. </span>
<span class="sd">            For a true forecast, error is typically NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Provide a dummy y_test with the same shape as the spatial domain =&gt; [NaNs]</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Align time dimension</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># 1) Fit+predict in parallel =&gt; shape (output=2, Y, X)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>  <span class="c1"># dummy y_test</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">()</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>  <span class="c1"># output=2 =&gt; [error, prediction]</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_Ridge_Model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_Ridge_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ridge regression model for spatial rainfall prediction with support for two modes:</span>
<span class="sd">    - per-grid-cell (pixel-wise) hyperparameter optimization</span>
<span class="sd">    - spatially clustered optimization (faster, more robust for noisy data)</span>

<span class="sd">    The class optimizes the Ridge regularization parameter (alpha) either:</span>
<span class="sd">    * independently for each grid cell, or</span>
<span class="sd">    * once per spatial cluster (using K-means on the predictand field)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_range : array-like, optional</span>
<span class="sd">        Array of alpha values to consider when using classical RidgeCV.</span>
<span class="sd">        Also defines the search space bounds for Bayesian/Randomized search.</span>
<span class="sd">        Default: np.logspace(-10, 10, 100)</span>
<span class="sd">    n_clusters : int, default=5</span>
<span class="sd">        Number of spatial clusters (used only when mode=&#39;cluster&#39;)</span>
<span class="sd">    nb_cores : int, default=1</span>
<span class="sd">        Number of CPU cores to use for parallel computation (grid mode)</span>
<span class="sd">    dist_method : str, default=&#39;nonparam&#39;</span>
<span class="sd">        Distance method used for clustering (currently only &#39;nonparam&#39; implemented)</span>
<span class="sd">    hyperparam_optimizer : {&#39;bayesian&#39;, &#39;random&#39;, &#39;ridgecv&#39;}, default=&#39;bayesian&#39;</span>
<span class="sd">        Method used for finding the best alpha:</span>
<span class="sd">        - &#39;bayesian&#39;   Optuna Bayesian optimization</span>
<span class="sd">        - &#39;random&#39;     RandomizedSearchCV</span>
<span class="sd">        - &#39;ridgecv&#39;    classic RidgeCV grid search</span>
<span class="sd">    n_trials : int, default=50</span>
<span class="sd">        Number of trials for Bayesian optimization (Optuna)</span>
<span class="sd">    n_iter : int, default=50</span>
<span class="sd">        Number of parameter settings sampled in RandomizedSearchCV</span>
<span class="sd">    mode : {&#39;cluster&#39;, &#39;grid&#39;}, default=&#39;cluster&#39;</span>
<span class="sd">        Optimization strategy:</span>
<span class="sd">        - &#39;cluster&#39;  spatially cluster the field  one alpha per cluster</span>
<span class="sd">        - &#39;grid&#39;     independent alpha optimization for each grid cell</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Grid mode (&#39;grid&#39;) is computationally expensive but gives the most local fit</span>
<span class="sd">    - Cluster mode (&#39;cluster&#39;) is much faster and usually more stable</span>
<span class="sd">    - Requires xarray, dask, scikit-learn, optuna (for bayesian mode)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_Ridge_Model.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">hyperparam_optimizer</span><span class="o">=</span><span class="s2">&quot;bayesian&quot;</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">=</span> <span class="n">hyperparam_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>  <span class="c1"># &#39;cluster&#39; or &#39;grid&#39;</span></div>


    <span class="c1"># ------------------ Hyperparameter Helpers ------------------</span>

<div class="viewcode-block" id="WAS_Ridge_Model._optimize_hyperparameters_optuna">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model._optimize_hyperparameters_optuna">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model._optimize_hyperparameters_randomized">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model._optimize_hyperparameters_randomized">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="n">param_distributions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">loguniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">))}</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Ridge</span><span class="p">()</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span>
                                           <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model._optimize_single_cell">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model._optimize_single_cell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">,</span> <span class="n">X_mat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unified helper to optimize a single pixel or cluster mean.&quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_vec</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_mat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Require at least 10 valid time steps</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span> <span class="o">=</span> <span class="n">X_mat</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y_vec</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_cv</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">RidgeCV</span><span class="p">(</span><span class="n">alphas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">model_cv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">model_cv</span><span class="o">.</span><span class="n">alpha_</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


    <span class="c1"># ------------------ Core Logic Methods ------------------</span>

<div class="viewcode-block" id="WAS_Ridge_Model.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spatially varying Ridge alpha parameter(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable (usually rainfall)</span>
<span class="sd">            Must have dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor array with dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;features&#39;) or (&#39;T&#39;, &#39;features&#39;)</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatological period for standardization</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatological period for standardization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha_map : xarray.DataArray</span>
<span class="sd">            Spatial field of optimal alpha values</span>
<span class="sd">            - shape (Y, X) when mode=&#39;grid&#39;</span>
<span class="sd">            - shape (Y, X) with constant values per cluster when mode=&#39;cluster&#39;</span>
<span class="sd">        cluster_da : xarray.DataArray or None</span>
<span class="sd">            Cluster labels (integers) when mode=&#39;cluster&#39;</span>
<span class="sd">            Contains NaN where clustering was not possible</span>
<span class="sd">            Returns dummy array filled with 1s when mode=&#39;grid&#39;</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If mode is neither &#39;cluster&#39; nor &#39;grid&#39;</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If dask client could not be created or computation failed (grid mode)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All NaN values in time series are handled (masked)</span>
<span class="sd">        - Minimum 10 valid time steps required per location/cluster</span>
<span class="sd">        - Standardization is applied to predictand using specified climatology period</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predictand</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">predictand_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="c1"># Grid-wise: Parallelized over every pixel</span>
            <span class="n">chunk_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">chunk_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">p_st_chunked</span> <span class="o">=</span> <span class="n">predictand_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunk_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunk_x</span><span class="p">})</span>

            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">,</span>
                <span class="n">p_st_chunked</span><span class="p">,</span>
                <span class="n">predictor</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">alpha_array</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha_array</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_array</span><span class="p">,</span> <span class="n">cluster_da</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ridge: Running Cluster-wise optimization (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters)...&quot;</span><span class="p">)</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">variable_column</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
                <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert cluster assignments back into an xarray structure</span>
            <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
                   
            <span class="c1"># Align cluster array with the predictand array</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand_st</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            
            <span class="c1"># Identify unique cluster labels</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">x2</span>
            
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">y_cluster</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">==</span> <span class="n">clus</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">(</span><span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alpha_map</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_da</span> <span class="o">!=</span> <span class="n">clus</span><span class="p">,</span> <span class="n">best_alpha</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">alpha_map</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.fit_predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.fit_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a ridge regression model and make predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Training data (shape = [n_samples, n_features]).</span>
<span class="sd">        y : ndarray</span>
<span class="sd">            Target values for training data (shape = [n_samples,]).</span>
<span class="sd">        x_test : ndarray</span>
<span class="sd">            Test data (shape = [n_features,] or [1, n_features]).</span>
<span class="sd">        y_test : float</span>
<span class="sd">            Target value for test data.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Regularization strength for Ridge regression.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no valid training data, return NaNs</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
                      <span class="c1"># =None, clim_year_start=None, clim_year_end=None):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit and predict ridge regression model for spatiotemporal data using Dask for parallel computation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data (dims: T, features).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data (dims: T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictor data (dims: features) or broadcastable.</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test predictand data (dims: Y, X).</span>
<span class="sd">        alpha : xarray.DataArray</span>
<span class="sd">            Spatial map of alpha values for each grid cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Align alpha with y_train, y_test</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="c1"># if alpha is None:</span>
        <span class="c1">#     alpha, _ = self.compute_hyperparameters(</span>
        <span class="c1">#          y_train, X_train, clim_year_start, clim_year_end</span>
        <span class="c1">#     )</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>   <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>            <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>     <span class="c1"># x_test</span>
                <span class="p">(),</span>                <span class="c1"># y_test</span>
                <span class="p">()</span>                 <span class="c1"># alpha</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


   <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_Ridge_Model._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_Ridge_Model.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solver for Weibull shape parameter.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate tercile probabilities using best-fit distribution family.&quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>   
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
        
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">WAS_Ridge_Model</span><span class="o">.</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution code: </span><span class="si">{</span><span class="n">dist_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        
        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_Ridge_Model.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Ridge_Model.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a ridge-based forecast for a single future time (year).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>        
        <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>
                <span class="p">(),</span>
                <span class="p">()</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span> 
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_Lasso_Model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_Lasso_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lasso regression model for spatial rainfall prediction with support for two modes:</span>
<span class="sd">    - per-grid-cell (pixel-wise) hyperparameter optimization</span>
<span class="sd">    - spatially clustered optimization (recommended for most rainfall applications)</span>

<span class="sd">    Lasso performs feature selection by driving less important coefficients to exactly zero,</span>
<span class="sd">    which can be useful when working with many atmospheric/oceanic predictors.</span>

<span class="sd">    Compared to Ridge, Lasso tends to need:</span>
<span class="sd">    - smaller alpha values (less regularization)</span>
<span class="sd">    - more iterations (coefficients can become unstable near zero)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_range : array-like, optional</span>
<span class="sd">        Range of alpha values to search over.</span>
<span class="sd">        Default: np.logspace(-6, 2, 100)  reasonable for rainfall / standardized data</span>
<span class="sd">    n_clusters : int, default=5</span>
<span class="sd">        Number of spatial clusters (only used when mode=&#39;cluster&#39;)</span>
<span class="sd">    nb_cores : int, default=1</span>
<span class="sd">        Number of parallel workers for grid-wise optimization</span>
<span class="sd">    dist_method : str, default=&#39;nonparam&#39;</span>
<span class="sd">        Clustering distance method (currently only &#39;nonparam&#39; implemented)</span>
<span class="sd">    hyperparam_optimizer : {&#39;bayesian&#39;, &#39;random&#39;, &#39;lassocv&#39;}, default=&#39;bayesian&#39;</span>
<span class="sd">        Strategy for finding optimal alpha:</span>
<span class="sd">        - &#39;bayesian&#39;   Optuna Bayesian optimization (usually best quality)</span>
<span class="sd">        - &#39;random&#39;     Randomized search (faster, decent quality)</span>
<span class="sd">        - &#39;lassocv&#39;    scikit-learn LassoCV (fastest, grid-based)</span>
<span class="sd">    n_trials : int, default=50</span>
<span class="sd">        Number of trials for Bayesian optimization (Optuna)</span>
<span class="sd">    n_iter : int, default=50</span>
<span class="sd">        Number of parameter settings sampled in randomized search</span>
<span class="sd">    mode : {&#39;cluster&#39;, &#39;grid&#39;}, default=&#39;cluster&#39;</span>
<span class="sd">        Optimization strategy:</span>
<span class="sd">        - &#39;cluster&#39;  one alpha per spatial cluster (fast, stable)</span>
<span class="sd">        - &#39;grid&#39;     independent alpha for every grid cell (slow, very local)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Grid mode is computationally very expensive  use it only when you really need</span>
<span class="sd">      maximum spatial detail and have sufficient computing resources.</span>
<span class="sd">    - Cluster mode is usually a very good compromise between performance and stability.</span>
<span class="sd">    - Lasso is more sensitive to data scaling than Ridge  make sure predictors</span>
<span class="sd">      and predictand are properly standardized.</span>
<span class="sd">    - Requires: xarray, dask, scikit-learn, optuna (for bayesian mode)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_Lasso_Model.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">hyperparam_optimizer</span><span class="o">=</span><span class="s2">&quot;bayesian&quot;</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">=</span> <span class="n">hyperparam_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>  <span class="c1"># &#39;cluster&#39; or &#39;grid&#39;</span></div>


    <span class="c1"># ------------------ Hyperparameter Helpers ------------------</span>

<div class="viewcode-block" id="WAS_Lasso_Model._optimize_hyperparameters_optuna">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model._optimize_hyperparameters_optuna">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="c1"># Lasso is prone to zeroing out everything; negative MSE is a good metric here</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model._optimize_hyperparameters_randomized">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model._optimize_hyperparameters_randomized">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="n">param_distributions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">loguniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">))}</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Lasso</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model._optimize_single_cell">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model._optimize_single_cell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">,</span> <span class="n">X_mat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unified helper to optimize a single pixel or cluster mean for Lasso.&quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_vec</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_mat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Minimum valid years</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span> <span class="o">=</span> <span class="n">X_mat</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y_vec</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback to LassoCV for speed in grid-mode if needed</span>
                <span class="n">model_cv</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoCV</span><span class="p">(</span><span class="n">alphas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">model_cv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">model_cv</span><span class="o">.</span><span class="n">alpha_</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


    <span class="c1"># ------------------ Core Logic Methods ------------------</span>

<div class="viewcode-block" id="WAS_Lasso_Model.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spatially varying optimal Lasso regularization parameter alpha.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable (typically rainfall amount)</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor fields</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;features&#39;) or (&#39;T&#39;, &#39;features&#39;)</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the reference climatology period for standardization</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the reference climatology period for standardization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha_map : xarray.DataArray</span>
<span class="sd">            Spatial field (Y, X) containing optimal alpha value(s)</span>
<span class="sd">            - In &#39;grid&#39; mode: different value possible for each cell</span>
<span class="sd">            - In &#39;cluster&#39; mode: same value for all cells in the same cluster</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels (when mode=&#39;cluster&#39;)</span>
<span class="sd">            Dummy array filled with 1s when mode=&#39;grid&#39; (for compatibility)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If unknown mode is provided</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If dask parallel computation fails (grid mode)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Time series with fewer than 10 valid points are skipped (return NaN)</span>
<span class="sd">        - Lasso uses increased max_iter=10000 to help convergence</span>
<span class="sd">        - All NaN handling is automatic (masking invalid time steps)</span>
<span class="sd">        - Progress messages are printed during long computations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predictand</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">predictand_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lasso: Running Grid-wise optimization on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="si">}</span><span class="s2"> cores...&quot;</span><span class="p">)</span>
            <span class="n">chunk_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">chunk_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">p_st_chunked</span> <span class="o">=</span> <span class="n">predictand_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunk_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunk_x</span><span class="p">})</span>

            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">,</span>
                <span class="n">p_st_chunked</span><span class="p">,</span>
                <span class="n">predictor</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">alpha_array</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha_array</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_array</span><span class="p">,</span> <span class="n">cluster_da</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lasso: Running Cluster-wise optimization (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters)...&quot;</span><span class="p">)</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">variable_column</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
                <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert cluster assignments back into an xarray structure</span>
            <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
                   
            <span class="c1"># Align cluster array with the predictand array</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand_st</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            
            <span class="c1"># Identify unique cluster labels</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">x2</span>
            
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">y_cluster</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">==</span> <span class="n">clus</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">(</span><span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alpha_map</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_da</span> <span class="o">!=</span> <span class="n">clus</span><span class="p">,</span> <span class="n">best_alpha</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">alpha_map</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model.fit_predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.fit_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a Lasso model and make predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">x_clean</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="n">preds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">error_</span> <span class="o">=</span> <span class="n">y_test</span> <span class="o">-</span> <span class="n">preds</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error_</span><span class="p">,</span> <span class="n">preds</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="WAS_Lasso_Model.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Lasso predictions for spatiotemporal data using provided alpha values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># Align alpha with y_train, y_test</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                 <span class="n">y_train</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>
        
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># alpha</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

   <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_Lasso_Model._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_Lasso_Model.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_Lasso_Model.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.32</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_Lasso_Model.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_Lasso_Model.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a forecast for a single time (year) using Lasso with alpha, </span>
<span class="sd">        then compute tercile probabilities from the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=2, T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Single-year predictor data (features,).</span>
<span class="sd">        alpha : xarray.DataArray</span>
<span class="sd">            Spatial map of alpha values (Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">            For a real forecast scenario, the error is typically NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Create dummy y_test =&gt; shape (Y, X) with NaN</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># 2) Chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span> 
        
        <span class="c1"># Align</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Align alpha with the domain</span>
        <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Fit+predict in parallel =&gt; produce (2, Y, X)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>  <span class="c1"># dummy</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># alpha</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>  <span class="c1"># =&gt; [error, prediction]</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span> 
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_ElasticNet_Model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_ElasticNet_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ElasticNet regression model for spatial rainfall prediction.</span>

<span class="sd">    ElasticNet combines L1 (Lasso) and L2 (Ridge) penalties, allowing both</span>
<span class="sd">    feature selection and coefficient shrinkage. It is often a good compromise</span>
<span class="sd">    between Lasso (aggressive sparsity) and Ridge (stability)  particularly</span>
<span class="sd">    useful when predictors are correlated (common in climate/teleconnection data).</span>

<span class="sd">    Supports two spatial optimization strategies:</span>
<span class="sd">    - grid-wise: independent (, l1_ratio) per grid cell (very expensive)</span>
<span class="sd">    - cluster-wise: one (, l1_ratio) per spatial cluster (recommended)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_range : array-like, optional</span>
<span class="sd">        Range of total regularization strength values.</span>
<span class="sd">        Default: np.logspace(-6, 2, 100)  suitable for standardized rainfall data</span>
<span class="sd">    l1_ratio_range : array-like, optional</span>
<span class="sd">        Range of L1 penalty ratio (0 = pure Ridge, 1 = pure Lasso).</span>
<span class="sd">        Default: [0.1, 0.5, 0.7, 0.9, 0.95, 0.99, 1.0]</span>
<span class="sd">    n_clusters : int, default=5</span>
<span class="sd">        Number of spatial clusters (used only in mode=&#39;cluster&#39;)</span>
<span class="sd">    nb_cores : int, default=1</span>
<span class="sd">        Number of parallel workers for grid-wise optimization</span>
<span class="sd">    dist_method : str, default=&#39;nonparam&#39;</span>
<span class="sd">        Clustering distance method (currently only &#39;nonparam&#39; supported)</span>
<span class="sd">    hyperparam_optimizer : {&#39;bayesian&#39;, &#39;random&#39;, &#39;elasticnetcv&#39;}, default=&#39;bayesian&#39;</span>
<span class="sd">        Hyperparameter search strategy:</span>
<span class="sd">        - &#39;bayesian&#39;      Optuna (usually best quality)</span>
<span class="sd">        - &#39;random&#39;        RandomizedSearchCV (faster, good compromise)</span>
<span class="sd">        - &#39;elasticnetcv&#39;  scikit-learn ElasticNetCV (fastest, discrete grid)</span>
<span class="sd">    n_trials : int, default=50</span>
<span class="sd">        Number of trials for Bayesian optimization</span>
<span class="sd">    n_iter : int, default=50</span>
<span class="sd">        Number of parameter settings sampled in randomized search</span>
<span class="sd">    mode : {&#39;cluster&#39;, &#39;grid&#39;}, default=&#39;cluster&#39;</span>
<span class="sd">        Optimization approach:</span>
<span class="sd">        - &#39;cluster&#39;  one (alpha, l1_ratio) per spatial cluster (fast &amp; stable)</span>
<span class="sd">        - &#39;grid&#39;     independent optimization for each grid cell (slow, local)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Grid mode is computationally intensive  use only when spatial detail is critical</span>
<span class="sd">      and sufficient computing resources are available.</span>
<span class="sd">    - Cluster mode is the recommended default for most rainfall modeling applications.</span>
<span class="sd">    - Requires: xarray, dask, scikit-learn, optuna (if using &#39;bayesian&#39;)</span>
<span class="sd">    - All models use max_iter=10000 to improve convergence</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="WAS_ElasticNet_Model.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l1_ratio_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span> <span class="n">hyperparam_optimizer</span><span class="o">=</span><span class="s2">&quot;bayesian&quot;</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l1_ratio_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="n">l1_ratio_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">=</span> <span class="n">hyperparam_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="c1"># &#39;cluster&#39; or &#39;grid&#39;</span></div>


    <span class="c1"># ------------------ Hyperparameter Helpers ------------------</span>

<div class="viewcode-block" id="WAS_ElasticNet_Model._optimize_hyperparameters_optuna">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model._optimize_hyperparameters_optuna">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">,</span> <span class="n">l1_ratio_range</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">l1_ratio</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;l1_ratio&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">l1_ratio_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l1_ratio_range</span><span class="p">))</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;l1_ratio&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model._optimize_hyperparameters_randomized">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model._optimize_hyperparameters_randomized">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">,</span> <span class="n">l1_ratio_range</span><span class="p">):</span>
        <span class="n">param_distributions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">loguniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">)),</span>
            <span class="s1">&#39;l1_ratio&#39;</span><span class="p">:</span> <span class="n">l1_ratio_range</span>
        <span class="p">}</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNet</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span>
                                           <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;l1_ratio&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model._optimize_single_cell">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model._optimize_single_cell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">,</span> <span class="n">X_mat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unified helper to optimize a single pixel or cluster mean for ElasticNet.&quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_vec</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_mat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span> <span class="c1"># Return [alpha, l1_ratio]</span>
        
        <span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span> <span class="o">=</span> <span class="n">X_mat</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y_vec</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_cv</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNetCV</span><span class="p">(</span><span class="n">alphas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">model_cv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">model_cv</span><span class="o">.</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">model_cv</span><span class="o">.</span><span class="n">l1_ratio_</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span></div>


    <span class="c1"># ------------------ Core Logic Methods ------------------</span>

<div class="viewcode-block" id="WAS_ElasticNet_Model.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spatially varying optimal ElasticNet parameters (alpha and l1_ratio).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable (typically rainfall)</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor fields</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;features&#39;) or (&#39;T&#39;, &#39;features&#39;)</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatological standardization period</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatological standardization period</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha_map : xarray.DataArray</span>
<span class="sd">            Spatial field (Y, X) of optimal alpha values</span>
<span class="sd">        l1_ratio_map : xarray.DataArray</span>
<span class="sd">            Spatial field (Y, X) of optimal l1_ratio values</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels (integers) when mode=&#39;cluster&#39;</span>
<span class="sd">            Dummy array filled with 1s when mode=&#39;grid&#39;</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid mode is provided</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If dask parallel computation fails (in grid mode)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Locations/time series with &lt; 10 valid points are skipped (return NaN)</span>
<span class="sd">        - NaN handling is automatic (invalid time steps are masked)</span>
<span class="sd">        - Progress messages are printed for long-running computations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predictand</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">predictand_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ElasticNet: Running Grid-wise optimization on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="si">}</span><span class="s2"> cores...&quot;</span><span class="p">)</span>
            <span class="n">chunk_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">chunk_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">p_st_chunked</span> <span class="o">=</span> <span class="n">predictand_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunk_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunk_x</span><span class="p">})</span>

            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Returns a DataArray with a new &#39;params&#39; dimension [alpha, l1_ratio]</span>
            <span class="n">param_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">,</span> <span class="n">p_st_chunked</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;params&#39;</span><span class="p">,)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">param_array</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">l1_ratio_array</span> <span class="o">=</span> <span class="n">param_array</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha_array</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_array</span><span class="p">,</span> <span class="n">l1_ratio_array</span><span class="p">,</span> <span class="n">cluster_da</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ElasticNet: Running Cluster-wise optimization...&quot;</span><span class="p">)</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">variable_column</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
                <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert cluster assignments back into an xarray structure</span>
            <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
                   
            <span class="c1"># Align cluster array with the predictand array</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand_st</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            
            <span class="c1"># Identify unique cluster labels</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">x2</span>
            
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">l1_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">y_cluster</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">==</span> <span class="n">clus</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">(</span><span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alpha_map</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_da</span> <span class="o">!=</span> <span class="n">clus</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">l1_map</span> <span class="o">=</span> <span class="n">l1_map</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_da</span> <span class="o">!=</span> <span class="n">clus</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">alpha_map</span><span class="p">,</span> <span class="n">l1_map</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model.fit_predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.fit_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l1_ratio</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x_test</span><span class="p">)</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">pred</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">pred</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs parallelized ElasticNet modeling for spatiotemporal data.</span>
<span class="sd">        Returns [error, prediction] per grid cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        
        <span class="c1"># Align alpha, l1_ratio, y_train, y_test</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">l1_ratio</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">l1_ratio</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">l1_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                 <span class="n">y_train</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">l1_ratio</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">(),</span>               <span class="c1"># alpha</span>
                <span class="p">()</span>                <span class="c1"># l1_ratio</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


   <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_ElasticNet_Model._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_ElasticNet_Model.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_ElasticNet_Model.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_ElasticNet_Model.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.32</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># ------------------- FORECAST METHOD -------------------</span>
<div class="viewcode-block" id="WAS_ElasticNet_Model.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_ElasticNet_Model.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">Predictor</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">,</span>
        <span class="n">Predictor_for_year</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">l1_ratio</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a single-year forecast using ElasticNet with (alpha, l1_ratio), </span>
<span class="sd">        and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X).</span>
<span class="sd">        clim_year_start, clim_year_end : int</span>
<span class="sd">            Climatology reference period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=2, T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Single-year predictor data (features,).</span>
<span class="sd">        alpha : xarray.DataArray</span>
<span class="sd">            Spatial map of alpha values (Y, X).</span>
<span class="sd">        l1_ratio : xarray.DataArray</span>
<span class="sd">            Spatial map of l1_ratio values (Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, forecast].</span>
<span class="sd">            For a real forecast scenario, &#39;error&#39; is NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; [PB, PN, PA].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Create a dummy y_test =&gt; shape (Y, X) with NaN</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># 2) Align shapes</span>
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Align alpha, l1_ratio with domain</span>
        <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Parallel fit+predict =&gt; shape (2, Y, X)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">)),</span>
                              <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="p">,</span>   <span class="c1"># pass dummy test =&gt; yields [NaN, forecast]</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">l1_ratio</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">(),</span>               <span class="c1"># alpha</span>
                <span class="p">()</span>                <span class="c1"># l1_ratio</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>  <span class="c1"># =&gt; [error, prediction]</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.32</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_LassoLars_Model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_LassoLars_Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LassoLars regression model for spatial rainfall prediction with least-angle</span>
<span class="sd">    regression (LARS) path computation.</span>

<span class="sd">    LassoLars is particularly suitable when:</span>
<span class="sd">    - The number of samples is relatively small</span>
<span class="sd">    - You want very precise control over the L1 regularization path</span>
<span class="sd">    - Numerical stability is more important than speed</span>

<span class="sd">    Compared to standard Lasso, LassoLars tends to be:</span>
<span class="sd">    - More stable for small datasets</span>
<span class="sd">    - Slightly slower</span>
<span class="sd">    - Better when predictors are highly correlated</span>

<span class="sd">    Supports two spatial strategies:</span>
<span class="sd">    - grid-wise: independent alpha optimization per grid cell (very expensive)</span>
<span class="sd">    - cluster-wise: one alpha per spatial cluster (recommended default)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha_range : array-like, optional</span>
<span class="sd">        Range of regularization strength values to search.</span>
<span class="sd">        Default: np.logspace(-6, 2, 100)  appropriate for standardized rainfall data</span>
<span class="sd">    n_clusters : int, default=5</span>
<span class="sd">        Number of spatial clusters (used only when mode=&#39;cluster&#39;)</span>
<span class="sd">    nb_cores : int, default=1</span>
<span class="sd">        Number of parallel workers for grid-wise optimization</span>
<span class="sd">    dist_method : str, default=&#39;nonparam&#39;</span>
<span class="sd">        Clustering distance method (currently only &#39;nonparam&#39; implemented)</span>
<span class="sd">    hyperparam_optimizer : {&#39;bayesian&#39;, &#39;random&#39;, &#39;lassolars_cv&#39;}, default=&#39;bayesian&#39;</span>
<span class="sd">        Strategy for selecting optimal alpha:</span>
<span class="sd">        - &#39;bayesian&#39;       Optuna Bayesian optimization (best quality)</span>
<span class="sd">        - &#39;random&#39;         Randomized search (faster, reasonable quality)</span>
<span class="sd">        - &#39;lassolars_cv&#39;   scikit-learn LassoLarsCV (fastest, grid-based)</span>
<span class="sd">    n_trials : int, default=50</span>
<span class="sd">        Number of trials for Bayesian optimization (Optuna)</span>
<span class="sd">    n_iter : int, default=50</span>
<span class="sd">        Number of parameter settings sampled in randomized search</span>
<span class="sd">    mode : {&#39;cluster&#39;, &#39;grid&#39;}, default=&#39;grid&#39;</span>
<span class="sd">        Optimization strategy:</span>
<span class="sd">        - &#39;cluster&#39;  one alpha per spatial cluster (fast &amp; robust)</span>
<span class="sd">        - &#39;grid&#39;     independent alpha for every grid cell (slow, very local)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - LassoLars uses the full regularization path  can be more stable than coordinate</span>
<span class="sd">      descent Lasso when data is noisy or n_samples is small.</span>
<span class="sd">    - Grid mode is **very computationally expensive**  use cluster mode unless</span>
<span class="sd">      you really need maximum spatial detail and have substantial computing power.</span>
<span class="sd">    - Requires: xarray, dask, scikit-learn, optuna (if using &#39;bayesian&#39;)</span>
<span class="sd">    - All models use max_iter=10000 to improve convergence on difficult cases</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="WAS_LassoLars_Model.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nb_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">hyperparam_optimizer</span><span class="o">=</span><span class="s2">&quot;bayesian&quot;</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span> <span class="o">=</span> <span class="n">nb_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">=</span> <span class="n">hyperparam_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>  <span class="c1"># &#39;cluster&#39; or &#39;grid&#39;</span></div>


    <span class="c1"># ------------------ Hyperparameter Helpers ------------------</span>

<div class="viewcode-block" id="WAS_LassoLars_Model._optimize_hyperparameters_optuna">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model._optimize_hyperparameters_optuna">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_optuna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLars</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="c1"># Lasso is prone to zeroing out everything; negative MSE is a good metric here</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_LassoLars_Model._optimize_hyperparameters_randomized">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model._optimize_hyperparameters_randomized">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_hyperparameters_randomized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha_range</span><span class="p">):</span>
        <span class="n">param_distributions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">loguniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">))}</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLars</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span></div>


    <span class="c1"># ------------------ Optimization Helpers ------------------</span>

<div class="viewcode-block" id="WAS_LassoLars_Model._optimize_single_cell">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model._optimize_single_cell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_vec</span><span class="p">,</span> <span class="n">X_mat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds best alpha for a single pixel or cluster mean using chosen optimizer.&quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_vec</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_mat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span> <span class="o">=</span> <span class="n">X_mat</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y_vec</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">)</span>
                <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">cross_val_score</span><span class="p">(</span>
                    <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLars</span><span class="p">(</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                        <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">),</span> <span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> 
                    <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
            
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperparam_optimizer</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">loguniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">))}</span>
                <span class="n">rs</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLars</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span> <span class="n">param_dist</span><span class="p">,</span> 
                                        <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
                <span class="n">rs</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">rs</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_cv</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLarsCV</span><span class="p">(</span><span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">model_cv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">model_cv</span><span class="o">.</span><span class="n">alpha_</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="WAS_LassoLars_Model.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictand</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spatially varying optimal LassoLars regularization parameter (alpha).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictand : xarray.DataArray</span>
<span class="sd">            Target variable (typically rainfall)</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)</span>
<span class="sd">        predictor : xarray.DataArray</span>
<span class="sd">            Predictor fields</span>
<span class="sd">            Expected dimensions: (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;features&#39;) or (&#39;T&#39;, &#39;features&#39;)</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatological standardization period</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatological standardization period</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha_map : xarray.DataArray</span>
<span class="sd">            Spatial field (Y, X) containing optimal alpha value(s)</span>
<span class="sd">            - Different value per cell when mode=&#39;grid&#39;</span>
<span class="sd">            - Constant per cluster when mode=&#39;cluster&#39;</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels (integers) when mode=&#39;cluster&#39;</span>
<span class="sd">            Dummy array filled with 1s when mode=&#39;grid&#39; (for API consistency)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If mode is neither &#39;cluster&#39; nor &#39;grid&#39;</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If dask parallel computation fails (grid mode)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Time series with fewer than 10 valid points are automatically skipped (return NaN)</span>
<span class="sd">        - All NaN values in input are properly masked</span>
<span class="sd">        - Progress messages are printed during long computations</span>
<span class="sd">        - LassoLarsCV does **not** require pre-defined alpha grid (uses full LARS path)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predictand</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">predictand_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LassoLars: Running Pixel-wise optimization on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="si">}</span><span class="s2"> cores...&quot;</span><span class="p">)</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="n">chunk_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">chunk_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictand_st</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
            <span class="n">p_st_chunked</span> <span class="o">=</span> <span class="n">predictand_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunk_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunk_x</span><span class="p">})</span>

            <span class="n">alpha_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">,</span> <span class="n">p_st_chunked</span><span class="p">,</span> <span class="n">predictor</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;features&#39;</span><span class="p">)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha_array</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_array</span><span class="p">,</span> <span class="n">cluster_da</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LassoLars: Running Cluster-wise optimization (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters)...&quot;</span><span class="p">)</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="n">predictand_dropna</span> <span class="o">=</span> <span class="n">predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">variable_column</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
                <span class="n">predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert cluster assignments back into an xarray structure</span>
            <span class="n">df_unique</span> <span class="o">=</span> <span class="n">predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
                   
            <span class="c1"># Align cluster array with the predictand array</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">predictand_st</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            
            <span class="c1"># Identify unique cluster labels</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">x2</span>
            
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">y_cluster</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">==</span> <span class="n">clus</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_single_cell</span><span class="p">(</span><span class="n">y_cluster</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">predictor</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_cluster</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alpha_map</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_da</span> <span class="o">!=</span> <span class="n">clus</span><span class="p">,</span> <span class="n">best_alpha</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">alpha_map</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_LassoLars_Model.fit_predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.fit_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoLars</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_test</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x_test</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">pred</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">pred</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span></div>

    
<div class="viewcode-block" id="WAS_LassoLars_Model.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits and predicts the LassoLars model using Dask for parallel execution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data (dims: T, features).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training response variable (dims: T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Test predictor data (dims: features,) or broadcastable to (Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Test response variable (dims: Y, X).</span>
<span class="sd">        alpha : xarray.DataArray</span>
<span class="sd">            Cluster-wise optimal alpha values (dims: Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        
        <span class="n">X_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                 <span class="n">y_train</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>
            
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>        
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span> 
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>
                <span class="p">(),</span>
                <span class="p">()</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    
   <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_LassoLars_Model._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.32</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_LassoLars_Model.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_LassoLars_Model.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_LassoLars_Model.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_LassoLars_Model.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.32</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># ------------------- FORECAST METHOD -------------------</span>

<div class="viewcode-block" id="WAS_LassoLars_Model.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_linear_models.WAS_LassoLars_Model.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a forecast for a single time step using LassoLars with alpha,</span>
<span class="sd">        then computes tercile probabilities based on the chosen distribution method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year for the climatological reference period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year for the climatological reference period.</span>
<span class="sd">        Predictor : xarray.DataArray</span>
<span class="sd">            Historical predictor data (T, features).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Historical deterministic forecast with dims (output=2, T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Single-year predictor data (features,) or shape (1, features).</span>
<span class="sd">        alpha : xarray.DataArray</span>
<span class="sd">            Spatial map of alpha values (Y, X) for LassoLars.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            dims (output=2, Y, X) =&gt; [error, prediction].</span>
<span class="sd">            For a true forecast scenario, the error is typically NaN.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            dims (probability=3, Y, X) =&gt; [PB, PN, PA] for tercile categories.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Provide a dummy y_test with NaN so fit_predict returns [NaN, forecast]</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># 2) Chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">))</span>
        
        <span class="n">Predictor</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Align alpha with the domain</span>
        <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictant_st</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="c1"># 3) Parallel fit+predict =&gt; (2, Y, X)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">,</span>
            <span class="n">Predictor</span><span class="p">,</span>
            <span class="n">Predictant_st</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">Predictor_for_year_</span><span class="p">,</span>
            <span class="n">y_test_dummy</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>   <span class="c1"># dummy test</span>
            <span class="n">alpha</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">),</span>  <span class="c1"># x</span>
                <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span>           <span class="c1"># y</span>
                <span class="p">(</span><span class="s1">&#39;features&#39;</span><span class="p">,),</span>    <span class="c1"># x_test</span>
                <span class="p">(),</span>               <span class="c1"># y_test</span>
                <span class="p">()</span>                <span class="c1"># alpha</span>
            <span class="p">],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;output&#39;</span><span class="p">,)],</span>  <span class="c1"># =&gt; [error, prediction]</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
        <span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span> 
        <span class="c1"># result_ =&gt; dims (output=2, Y, X). </span>
        <span class="c1"># For a real future forecast, &quot;error&quot; is NaN, &quot;prediction&quot; is the forecast.</span>

        <span class="c1"># 2) Compute thresholds T1, T2 from climatology</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.32</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># Expand single prediction to T=1 so probability methods can handle it</span>
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="c1"># year = Predictor_for_year.coords[&#39;T&#39;].values.astype(&#39;datetime64[Y]&#39;).astype(int)[0] + 1970  </span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_expanded</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_expanded</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_expanded</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_expanded</span><span class="p">,</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>