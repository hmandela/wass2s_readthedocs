

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_mme &mdash; wass2s 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">wass2s api</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_mme</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_mme</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wass2s.utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xcast</span> <span class="k">as</span> <span class="nn">xc</span>  <span class="c1"># </span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">lognorm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gamma</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="kn">import</span> <span class="n">MLPRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">StackingRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="kn">import</span> <span class="n">MLPRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">KFold</span>
<span class="kn">from</span> <span class="nn">xgboost</span> <span class="kn">import</span> <span class="n">XGBRegressor</span>
<span class="kn">from</span> <span class="nn">lightgbm</span> <span class="kn">import</span> <span class="n">LGBMRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVR</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">AdaBoostRegressor</span>
<span class="kn">import</span> <span class="nn">pymc</span> <span class="k">as</span> <span class="nn">pm</span>
<span class="kn">import</span> <span class="nn">arviz</span> <span class="k">as</span> <span class="nn">az</span>
<span class="kn">import</span> <span class="nn">gc</span>

<div class="viewcode-block" id="process_datasets_for_mme_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.process_datasets_for_mme_">[docs]</a>
<span class="k">def</span> <span class="nf">process_datasets_for_mme_</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gcm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">agroparam</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ELM_ELR</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dir_to_save_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">month_of_initialization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">gcm</span><span class="p">:</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.prcp&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="s1">&#39;GROC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
                        <span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">:</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span><span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span><span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> <span class="n">year_forecast</span><span class="o">=</span><span class="n">year_forecast</span><span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">agroparam</span><span class="p">:</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="s1">&#39;GROC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
                        <span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">:</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>        
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">hdcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">fcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>

        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="s1">&#39;GROC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
                        <span class="p">}</span>  

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scores_organized</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcsted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcsted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>    
    
    <span class="c1"># Extract the datasets and keys</span>
    <span class="n">hindcast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> 
    <span class="n">forecast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_fcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">predictor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>    

    <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">ELM_ELR</span><span class="p">:</span>
        <span class="c1"># Concatenate along a new dimension (&#39;M&#39;) and assign coordinates</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>  
            <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>                    
            <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>         
        <span class="p">)</span><span class="o">*</span><span class="n">mask</span>
        
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>  
            <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>                    
            <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>         
        <span class="p">)</span><span class="o">*</span><span class="n">mask</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">]},</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">mask</span>
        <span class="c1"># obs = obs.fillna(obs.mean(dim=&quot;T&quot;))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Concatenate along a new dimension (&#39;M&#39;) and assign coordinates</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>             
            <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>         
        <span class="p">)</span><span class="o">*</span><span class="n">mask</span>
        
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>                     
            <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>         
        <span class="p">)</span><span class="o">*</span><span class="n">mask</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">]},</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">mask</span>

    <span class="c1"># all_model_hdcst, obs = xr.align(all_model_hdcst, obs) </span>
    <span class="k">return</span> <span class="n">all_model_hdcst</span><span class="p">,</span> <span class="n">all_model_fcst</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">scores_organized</span></div>


<div class="viewcode-block" id="process_datasets_for_mme">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.process_datasets_for_mme">[docs]</a>
<span class="k">def</span> <span class="nf">process_datasets_for_mme</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">gcm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">agroparam</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Prob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">ELM_ELR</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dir_to_save_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">best_models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">month_of_initialization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">lead_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">score_metric</span><span class="o">=</span><span class="s1">&#39;GROC&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process hindcast and forecast datasets for a multi-model ensemble.</span>

<span class="sd">    This function loads, interpolates, and concatenates hindcast and forecast datasets from various sources </span>
<span class="sd">    (GCMs, agroparameters, or others) to prepare them for a multi-model ensemble. It supports different score </span>
<span class="sd">    metrics and configurations for probabilistic or deterministic outputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rainfall : xarray.DataArray</span>
<span class="sd">        Observed rainfall data used for interpolation and masking.</span>
<span class="sd">    hdcsted : dict, optional</span>
<span class="sd">        Dictionary of hindcast datasets for different models.</span>
<span class="sd">    fcsted : dict, optional</span>
<span class="sd">        Dictionary of forecast datasets for different models.</span>
<span class="sd">    gcm : bool, optional</span>
<span class="sd">        If True, process data as GCM data. Default is True.</span>
<span class="sd">    agroparam : bool, optional</span>
<span class="sd">        If True, process data as agroparameter data. Default is False.</span>
<span class="sd">    Prob : bool, optional</span>
<span class="sd">        If True, process data as probabilistic forecasts. Default is False.</span>
<span class="sd">    ELM_ELR : bool, optional</span>
<span class="sd">        If True, use ELM_ELR configuration for dimension renaming. Default is False.</span>
<span class="sd">    dir_to_save_model : str, optional</span>
<span class="sd">        Directory path to load model data.</span>
<span class="sd">    best_models : list, optional</span>
<span class="sd">        List of model names to include in the ensemble.</span>
<span class="sd">    scores : dict, optional</span>
<span class="sd">        Dictionary containing model scores, with the key specified by `score_metric`.</span>
<span class="sd">    year_start : int, optional</span>
<span class="sd">        Starting year for the data range.</span>
<span class="sd">    year_end : int, optional</span>
<span class="sd">        Ending year for the data range.</span>
<span class="sd">    model : bool, optional</span>
<span class="sd">        If True, treat data as model-based. Default is True.</span>
<span class="sd">    month_of_initialization : int, optional</span>
<span class="sd">        Month when the forecast is initialized.</span>
<span class="sd">    lead_time : int, optional</span>
<span class="sd">        Forecast lead time in months.</span>
<span class="sd">    year_forecast : int, optional</span>
<span class="sd">        Year for which the forecast is generated.</span>
<span class="sd">    score_metric : str, optional</span>
<span class="sd">        Metric used to organize scores (e.g., &#39;Pearson&#39;, &#39;MAE&#39;, &#39;GROC&#39;). Default is &#39;GROC&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_model_hdcst : xarray.DataArray</span>
<span class="sd">        Concatenated hindcast data across models.</span>
<span class="sd">    all_model_fcst : xarray.DataArray</span>
<span class="sd">        Concatenated forecast data across models.</span>
<span class="sd">    obs : xarray.DataArray</span>
<span class="sd">        Observed rainfall data expanded with a model dimension and masked.</span>
<span class="sd">    scores_organized : dict</span>
<span class="sd">        Dictionary of organized scores for selected models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">gcm</span><span class="p">:</span>
        <span class="c1"># Standardize model keys for matching.</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.prcp&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="c1"># Use the provided score_metric to extract the appropriate scores.</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">:</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span>
                <span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> 
                <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span>
                <span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> 
                <span class="n">year_forecast</span><span class="o">=</span><span class="n">year_forecast</span>
            <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">agroparam</span><span class="p">:</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
                        <span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">:</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>        
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">hdcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">fcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">scores_organized</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
    
    <span class="c1"># Concatenate datasets along the &#39;M&#39; dimension.</span>
    <span class="n">hindcast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> 
    <span class="n">forecast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_fcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">predictor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>    
    
    <span class="c1"># Create a mask based on the rainfall data.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">ELM_ELR</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

    <span class="k">elif</span> <span class="n">Prob</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
    
    <span class="k">return</span> <span class="n">all_model_hdcst</span><span class="p">,</span> <span class="n">all_model_fcst</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">scores_organized</span></div>



<div class="viewcode-block" id="myfill">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.myfill">[docs]</a>
<span class="k">def</span> <span class="nf">myfill</span><span class="p">(</span><span class="n">all_model_fcst</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill missing values in forecast data using random samples from observations.</span>

<span class="sd">    This function fills NaN values in the forecast data by randomly sampling values from the observed </span>
<span class="sd">    rainfall data along the time dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_model_fcst : xarray.DataArray</span>
<span class="sd">        Forecast data with dimensions (T, M, Y, X) containing possible NaN values.</span>
<span class="sd">    obs : xarray.DataArray</span>
<span class="sd">        Observed rainfall data with dimensions (T, Y, X) used for filling NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da_filled_random : xarray.DataArray</span>
<span class="sd">        Forecast data with NaN values filled using random samples from observations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Suppose all_model_hdcst has dimensions: T, M, Y, X</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">all_model_fcst</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
    
    <span class="c1"># Create a DataArray of random T indices with shape (T, M, Y, X)</span>
    <span class="c1"># so that each element gets its own random index along T</span>
    <span class="n">random_t_indices_full</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)),</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    
    <span class="c1"># Use vectorized indexing: for each (T, M, Y, X) location,</span>
    <span class="c1"># this picks the value at a random T index for that M, Y, X location.</span>
    <span class="n">random_slices_full</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">random_t_indices_full</span><span class="p">)</span>
    
    <span class="c1"># Fill missing values with these randomly selected values</span>
    <span class="n">da_filled_random</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">random_slices_full</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">da_filled_random</span>   </div>





<div class="viewcode-block" id="WAS_mme_Weighted">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Weighted</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weighted Multi-Model Ensemble (MME) for climate forecasting.</span>

<span class="sd">    This class implements a weighted ensemble approach for combining multiple climate models, </span>
<span class="sd">    supporting both equal weighting and score-based weighting. It also provides methods for </span>
<span class="sd">    computing tercile probabilities using various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    equal_weighted : bool, optional</span>
<span class="sd">        If True, use equal weights for all models; otherwise, use score-based weights. Default is False.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Statistical distribution for probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;normal&#39;, &#39;lognormal&#39;, </span>
<span class="sd">        &#39;weibull_min&#39;, &#39;nonparam&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    metric : str, optional</span>
<span class="sd">        Performance metric for weighting (&#39;MAE&#39;, &#39;Pearson&#39;, &#39;GROC&#39;). Default is &#39;GROC&#39;.</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        Threshold for score transformation. Default is 0.5.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equal_weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;GROC&quot;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            equal_weighted (bool): If True, use a simple unweighted mean.</span>
<span class="sd">            dist_method (str): Distribution method (kept for compatibility).</span>
<span class="sd">            metric (str): Score metric name (e.g., &#39;MAE&#39;, &#39;Pearson&#39;, &#39;GROC&#39;).</span>
<span class="sd">            threshold (numeric): Threshold value for masking the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equal_weighted</span> <span class="o">=</span> <span class="n">equal_weighted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>

<div class="viewcode-block" id="WAS_mme_Weighted.transform_score">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.transform_score">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform score array based on the chosen metric and threshold.</span>

<span class="sd">        For &#39;MAE&#39;, scores below the threshold are set to 1, others to 0. For &#39;Pearson&#39; or &#39;GROC&#39;, </span>
<span class="sd">        scores above the threshold are set to 1, others to 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        score_array : xarray.DataArray</span>
<span class="sd">            Score array to transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transformed_score : xarray.DataArray</span>
<span class="sd">            Transformed score array with binary weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mae&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pearson&#39;</span><span class="p">,</span> <span class="s1">&#39;groc&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
               <span class="c1"># xr.where(</span>
               <span class="c1">#     score_array &lt;= 0.6,</span>
               <span class="c1">#     0.6,</span>
               <span class="c1">#     xr.where(score_array &lt;= 0.8, 0.8, 1)</span>
               <span class="c1"># )</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default: no masking applied.</span>
            <span class="k">return</span> <span class="n">score_array</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.compute">[docs]</a>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcst</span><span class="p">,</span> <span class="n">fcst</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute weighted hindcast and forecast using model scores.</span>

<span class="sd">        This method calculates weighted averages of hindcast and forecast data based on model scores. </span>
<span class="sd">        If `complete` is True, missing values are filled with unweighted averages.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rainfall : xarray.DataArray</span>
<span class="sd">            Observed rainfall data with dimensions (T, Y, X, M).</span>
<span class="sd">        hdcst : xarray.DataArray</span>
<span class="sd">            Hindcast data with dimensions (T, M, Y, X).</span>
<span class="sd">        fcst : xarray.DataArray</span>
<span class="sd">            Forecast data with dimensions (T, M, Y, X).</span>
<span class="sd">        scores : dict</span>
<span class="sd">            Dictionary mapping model names to score arrays.</span>
<span class="sd">        complete : bool, optional</span>
<span class="sd">            If True, fill missing values with unweighted averages. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Weighted hindcast data with dimensions (T, Y, X).</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Weighted forecast data with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Adjust time coordinates as needed.</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        
        <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="n">hdcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create a mask based on non-NaN values in the rainfall data.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>\
                 <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_weighted</span><span class="p">:</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">selected_models</span> <span class="o">=</span> <span class="n">model_names</span>
            
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">score_sum</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">selected_models</span><span class="p">:</span>
                <span class="c1"># Interpolate and mask the score array for the current model.</span>
                <span class="n">score_array</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="n">weight_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_score</span><span class="p">(</span><span class="n">score_array</span><span class="p">)</span>
    
                <span class="c1"># Interpolate hindcast and forecast data to the rainfall grid.</span>
                <span class="n">hindcast_data</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
    
                <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
    
                <span class="c1"># Multiply by the weight.</span>
                <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_data</span> <span class="o">*</span> <span class="n">weight_array</span>
                <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_data</span> <span class="o">*</span> <span class="n">weight_array</span>
    
                <span class="c1"># Also keep an unweighted version for optional complete blending.</span>
                <span class="k">if</span> <span class="n">hindcast_det</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_weighted</span>
                    <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_weighted</span>
                    <span class="n">score_sum</span> <span class="o">=</span> <span class="n">weight_array</span>
                    <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="n">hindcast_data</span>
                    <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="n">forecast_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hindcast_det</span> <span class="o">+=</span> <span class="n">hindcast_weighted</span>
                    <span class="n">forecast_det</span> <span class="o">+=</span> <span class="n">forecast_weighted</span>
                    <span class="n">score_sum</span> <span class="o">+=</span> <span class="n">weight_array</span>
                    <span class="n">hindcast_det_unweighted</span> <span class="o">+=</span> <span class="n">hindcast_data</span>
                    <span class="n">forecast_det_unweighted</span> <span class="o">+=</span> <span class="n">forecast_data</span>
                    
            <span class="c1"># Compute the weighted averages.</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span> <span class="o">/</span> <span class="n">score_sum</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span> <span class="o">/</span> <span class="n">score_sum</span>

            <span class="c1"># If complete==True, use unweighted averages to fill in missing grid cells.</span>
            <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
                <span class="n">num_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_models</span><span class="p">)</span>
                <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="n">hindcast_det_unweighted</span> <span class="o">/</span> <span class="n">num_models</span>
                <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="n">forecast_det_unweighted</span> <span class="o">/</span> <span class="n">num_models</span>
                <span class="n">mask_hd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">mask_fc</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_det</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hindcast_det_unweighted</span> <span class="o">*</span> <span class="n">mask_hd</span>
                <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">forecast_det_unweighted</span> <span class="o">*</span> <span class="n">mask_fc</span>
                
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
                         
        <span class="k">return</span> <span class="n">hindcast_det</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">forecast_det</span> <span class="o">*</span> <span class="n">mask</span></div>



    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for hindcast data.</span>

<span class="sd">        Calculates tercile probabilities based on the specified distribution method, using </span>
<span class="sd">        climatological terciles derived from the predictand data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
      
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">*</span><span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">forecast_det</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        
        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_Min2009_ProbWeighted">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_Min2009_ProbWeighted</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Probability-Weighted Multi-Model Ensemble based on Min et al. (2009).</span>

<span class="sd">    Implements a specific weighting scheme for combining multiple climate models, </span>
<span class="sd">    where weights are derived from model scores with a threshold-based transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize any required attributes here</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="WAS_Min2009_ProbWeighted.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted.compute">[docs]</a>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcst</span><span class="p">,</span> <span class="n">fcst</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute probability-weighted ensemble estimates for hindcast and forecast datasets.</span>

<span class="sd">        Applies a weighting scheme where scores below the threshold are set to 0, and others to 1. </span>
<span class="sd">        Optionally fills missing values with unweighted averages.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rainfall : xarray.DataArray</span>
<span class="sd">            Observed rainfall data with dimensions (T, Y, X, M).</span>
<span class="sd">        hdcst : xarray.DataArray</span>
<span class="sd">            Hindcast data with dimensions (T, M, Y, X).</span>
<span class="sd">        fcst : xarray.DataArray</span>
<span class="sd">            Forecast data with dimensions (T, M, Y, X).</span>
<span class="sd">        scores : dict</span>
<span class="sd">            Dictionary mapping model names to score arrays.</span>
<span class="sd">        threshold : float, optional</span>
<span class="sd">            Threshold below which scores are set to 0. Default is 0.5.</span>
<span class="sd">        complete : bool, optional</span>
<span class="sd">            If True, fill missing values with unweighted averages. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_weighted : xarray.DataArray</span>
<span class="sd">            Weighted hindcast ensemble with dimensions (T, Y, X).</span>
<span class="sd">        forecast_weighted : xarray.DataArray</span>
<span class="sd">            Weighted forecast ensemble with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="c1"># --- Adjust time coordinates ---</span>
        <span class="c1"># Extract the year from the forecast&#39;s T coordinate (assuming epoch conversion)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the initial time value from rainfall</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month (1-12)</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        
        <span class="c1"># Update forecast and hindcast time coordinates</span>
        <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="n">hdcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create a spatial mask from rainfall (using first time and model)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># --- Initialize accumulators for weighted and unweighted sums ---</span>
        <span class="n">weighted_hindcast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">weighted_forecast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">score_sum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">hindcast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">forecast_sum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># --- Loop over each model ---</span>
        <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">:</span>
            <span class="c1"># Interpolate the score array to the rainfall grid</span>
            <span class="n">score_array</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="c1"># Apply weighting rules: below threshold set to 0; between threshold and 0.6 -&gt; 0.6; </span>
            <span class="c1"># between 0.6 and 0.8 -&gt; 0.8; above 0.8 -&gt; 1.</span>

            <span class="c1"># score_array = xr.where(</span>
            <span class="c1">#    score_array &lt;= threshold,</span>
            <span class="c1">#     0,</span>
            <span class="c1">#     xr.where(</span>
            <span class="c1">#         score_array &lt;= 0.6,</span>
            <span class="c1">#         0.6,</span>
            <span class="c1">#        xr.where(score_array &lt;= 0.8, 0.8, 1)</span>
            <span class="c1">#     )</span>
            <span class="c1"># )</span>

            <span class="n">score_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="c1"># Interpolate hindcast and forecast data for the model to the rainfall grid</span>
            <span class="n">hindcast_data</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Weight the datasets by the score_array</span>
            <span class="n">weighted_hindcast</span> <span class="o">=</span> <span class="n">hindcast_data</span> <span class="o">*</span> <span class="n">score_array</span>
            <span class="n">weighted_forecast</span> <span class="o">=</span> <span class="n">forecast_data</span> <span class="o">*</span> <span class="n">score_array</span>

            <span class="c1"># Accumulate weighted and unweighted sums</span>
            <span class="k">if</span> <span class="n">weighted_hindcast_sum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weighted_hindcast_sum</span> <span class="o">=</span> <span class="n">weighted_hindcast</span>
                <span class="n">weighted_forecast_sum</span> <span class="o">=</span> <span class="n">weighted_forecast</span>
                <span class="n">score_sum</span> <span class="o">=</span> <span class="n">score_array</span>
                <span class="n">hindcast_sum</span> <span class="o">=</span> <span class="n">hindcast_data</span>
                <span class="n">forecast_sum</span> <span class="o">=</span> <span class="n">forecast_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weighted_hindcast_sum</span> <span class="o">+=</span> <span class="n">weighted_hindcast</span>
                <span class="n">weighted_forecast_sum</span> <span class="o">+=</span> <span class="n">weighted_forecast</span>
                <span class="n">score_sum</span> <span class="o">+=</span> <span class="n">score_array</span>
                <span class="n">hindcast_sum</span> <span class="o">+=</span> <span class="n">hindcast_data</span>
                <span class="n">forecast_sum</span> <span class="o">+=</span> <span class="n">forecast_data</span>

        <span class="c1"># --- Compute weighted ensemble (weighted average) ---</span>
        <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">weighted_hindcast_sum</span> <span class="o">/</span> <span class="n">score_sum</span>
        <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">weighted_forecast_sum</span> <span class="o">/</span> <span class="n">score_sum</span>
        
        <span class="c1"># --- Optionally complete missing values with unweighted average ---</span>
        <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
            <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span>
            <span class="n">hindcast_unweighted</span> <span class="o">=</span> <span class="n">hindcast_sum</span> <span class="o">/</span> <span class="n">n_models</span>
            <span class="n">forecast_unweighted</span> <span class="o">=</span> <span class="n">forecast_sum</span> <span class="o">/</span> <span class="n">n_models</span>
            
            <span class="c1"># Identify missing areas in the weighted estimates</span>
            <span class="n">mask_hd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hindcast_weighted</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">mask_fc</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_weighted</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hindcast_unweighted</span> <span class="o">*</span> <span class="n">mask_hd</span>
            <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">forecast_unweighted</span> <span class="o">*</span> <span class="n">mask_fc</span>

        <span class="c1"># --- Drop the &#39;M&#39; dimension if present ---</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">hindcast_weighted</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">forecast_weighted</span> <span class="o">*</span> <span class="n">mask</span></div>
</div>


<span class="c1"># ---------------------------------------------------</span>
<span class="c1"># WAS_mme_GA Class</span>
<span class="c1">#   - Genetic Algorithm for multi-model ensemble weighting</span>
<span class="c1"># ---------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_GA">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_GA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Genetic Algorithm-based Multi-Model Ensemble Weighting.</span>

<span class="sd">    Uses a Genetic Algorithm to optimize weights for combining multiple climate models, </span>
<span class="sd">    minimizing the mean squared error (MSE) against observations. Supports tercile probability </span>
<span class="sd">    calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    population_size : int, optional</span>
<span class="sd">        Number of individuals in the GA population. Default is 20.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum number of generations for the GA. Default is 50.</span>
<span class="sd">    crossover_rate : float, optional</span>
<span class="sd">        Probability of performing crossover. Default is 0.7.</span>
<span class="sd">    mutation_rate : float, optional</span>
<span class="sd">        Probability of mutating a gene. Default is 0.01.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, </span>
<span class="sd">        &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">population_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">crossover_rate</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                 <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GA population with random weight vectors.</span>

<span class="sd">        Each weight vector is normalized to sum to 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_models : int</span>
<span class="sd">            Number of models in the ensemble.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        population : list of np.ndarray</span>
<span class="sd">            List of normalized weight vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">population_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span> <span class="o">=</span> <span class="n">crossover_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">=</span> <span class="n">mutation_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

        <span class="c1"># Set seeds</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Best solution found by GA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_fitness</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ---------------------------------------------------</span>
    <span class="c1"># GA Routines for Ensemble Weights</span>
    <span class="c1"># ---------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_initialize_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_models</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GA population with random weight vectors.</span>

<span class="sd">        Each weight vector is normalized to sum to 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_models : int</span>
<span class="sd">            Number of models in the ensemble.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        population : list of np.ndarray</span>
<span class="sd">            List of normalized weight vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">population</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalize so sum=1</span>
            <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">population</span>

    <span class="k">def</span> <span class="nf">_fitness_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the negative MSE of the ensemble.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : np.ndarray</span>
<span class="sd">            Weight vector for the models.</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Predictor data with shape (n_samples, n_models).</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Observed data with shape (n_samples,) or (n_samples, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fitness : float</span>
<span class="sd">            Negative mean squared error (GA maximizes fitness).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Weighted sum across models</span>
        <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">mse</span>  <span class="c1"># negative MSE (GA maximizes fitness)</span>

    <span class="k">def</span> <span class="nf">_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">fitnesses</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform roulette wheel selection based on fitness.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        population : list of np.ndarray</span>
<span class="sd">            List of weight vectors.</span>
<span class="sd">        fitnesses : list of float</span>
<span class="sd">            Fitness values for each individual.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        selected : np.ndarray</span>
<span class="sd">            Selected weight vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_fit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitnesses</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_fit</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">fit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitnesses</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="n">fit</span>
            <span class="k">if</span> <span class="n">current</span> <span class="o">&gt;=</span> <span class="n">pick</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">chrom</span>
        <span class="k">return</span> <span class="n">population</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_crossover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent1</span><span class="p">,</span> <span class="n">parent2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform single-point crossover on two parent weight vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent1 : np.ndarray</span>
<span class="sd">            First parent weight vector.</span>
<span class="sd">        parent2 : np.ndarray</span>
<span class="sd">            Second parent weight vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        child1, child2 : tuple of np.ndarray</span>
<span class="sd">            Two child weight vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">child1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">parent1</span><span class="p">[:</span><span class="n">point</span><span class="p">],</span> <span class="n">parent2</span><span class="p">[</span><span class="n">point</span><span class="p">:]))</span>
            <span class="n">child2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">parent2</span><span class="p">[:</span><span class="n">point</span><span class="p">],</span> <span class="n">parent1</span><span class="p">[</span><span class="n">point</span><span class="p">:]))</span>
            <span class="k">return</span> <span class="n">child1</span><span class="p">,</span> <span class="n">child2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parent1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">parent2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromosome</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mutation: each weight can be perturbed slightly.</span>
<span class="sd">        Then clip negatives to 0 and renormalize to sum=1.</span>
<span class="sd">        Mutate a weight vector with Gaussian noise and normalize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chromosome : np.ndarray</span>
<span class="sd">            Weight vector to mutate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mutated : np.ndarray</span>
<span class="sd">            Mutated and normalized weight vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">:</span>
                <span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># Clip any negatives</span>
        <span class="n">chromosome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">chromosome</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Renormalize</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># re-init if it all collapsed to zero</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chromosome</span> <span class="o">/=</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">chromosome</span>

    <span class="k">def</span> <span class="nf">_run_ga</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the GA to find best ensemble weights for M models.</span>
<span class="sd">        X shape: (n_samples, n_models). y shape: (n_samples,).</span>
<span class="sd">        Run the Genetic Algorithm to find optimal ensemble weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Predictor data with shape (n_samples, n_models).</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Observed data with shape (n_samples,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_chrom : np.ndarray</span>
<span class="sd">            Best weight vector found.</span>
<span class="sd">        best_fit : float</span>
<span class="sd">            Best fitness value (negative MSE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_population</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>

        <span class="n">best_chrom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_fit</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="c1"># Evaluate fitness</span>
            <span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fitness_function</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">population</span><span class="p">]</span>

            <span class="c1"># Track best</span>
            <span class="n">gen_best_fit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fitnesses</span><span class="p">)</span>
            <span class="n">gen_best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">fitnesses</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gen_best_fit</span> <span class="o">&gt;</span> <span class="n">best_fit</span><span class="p">:</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="n">gen_best_fit</span>
                <span class="n">best_chrom</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">gen_best_idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Create new population</span>
            <span class="n">new_population</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitnesses</span><span class="p">)</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitnesses</span><span class="p">)</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossover</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutate</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutate</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
                <span class="n">new_population</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">])</span>

            <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">best_chrom</span><span class="p">,</span> <span class="n">best_fit</span>

    <span class="k">def</span> <span class="nf">_predict_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weighted sum across models:</span>
<span class="sd">           y_pred[i] = sum_j( weights[j] * X[i,j] )</span>
<span class="sd">        Compute weighted sum of model predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : np.ndarray</span>
<span class="sd">            Weight vector for the models.</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Predictor data with shape (n_samples, n_models) or (n_models,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">            Weighted predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Single sample =&gt; dot product</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># ---------------------------------------------------</span>
    <span class="c1"># compute_model</span>
    <span class="c1"># ---------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_GA.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the GA and predict on test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, Y, X, M).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, Y, X, M).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Predictions with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span>  <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span>  <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="c1"># 2) Stack/reshape training data &amp; remove NaNs</span>
        <span class="c1">#    X_train =&gt; (samples, M), y_train =&gt; (samples,)</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        
        <span class="n">nan_mask_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_train</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_train</span><span class="p">]</span>

        <span class="c1"># 3) Stack/reshape test data &amp; remove NaNs similarly</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 4) Run GA on training data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If no valid training, fill with NaNs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_fitness</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_fitness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_ga</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>

            <span class="c1"># 5) Predict on X_test</span>
            <span class="n">X_test_clean</span> <span class="o">=</span> <span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">]</span>
            <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span><span class="p">,</span> <span class="n">X_test_clean</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">nan_mask_test</span><span class="p">])</span>
            <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
        
        <span class="c1"># 6) Reshape predictions back to (T, Y, X)</span>
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ---------------------------------------------------</span>
    <span class="c1"># Probability Calculation Methods</span>
    <span class="c1"># ---------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method for tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> \
                              <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma-distribution based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-parametric method using historical error samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal-distribution based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> \
                              <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GA.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lognormal-distribution based method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> \
                          <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># ---------------------------------------------------</span>
    <span class="c1"># compute_prob</span>
    <span class="c1"># ---------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_GA.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for hindcast data using the GA-optimized weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> \
                 <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Ensure (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>

        <span class="c1"># Choose distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="c1"># ---------------------------------------------------</span>
    <span class="c1"># forecast</span>
    <span class="c1"># ---------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_GA.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GA.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span>
                 <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast for a target year and compute tercile probabilities.</span>

<span class="sd">        Standardizes data, fits the GA, predicts for the target year, and computes probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Historical predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, Y, X, M).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, Y, X, M).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probability forecast with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> \
                 <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>

        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span>    <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If GA not fitted yet, we can fit it on the entire hindcast</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Stack</span>
            <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># # Flatten y if needed</span>
            <span class="c1"># if y_train_stacked.shape[1] == 1:</span>
            <span class="c1">#     y_train_stacked = y_train_stacked.ravel()</span>

            <span class="n">nan_mask_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_train</span><span class="p">]</span>
            <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_train</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_fitness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_ga</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>

        <span class="c1"># Now predict for the new year</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span>  <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span>  <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># if y_test_stacked.shape[1] == 1:</span>
        <span class="c1">#     y_test_stacked = y_test_stacked.ravel()</span>

        <span class="n">nan_mask_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_chromosome</span><span class="p">,</span> <span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">nan_mask_test</span><span class="p">])</span>
            <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                 <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># Reverse-standardize</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span>
            <span class="n">result_da</span><span class="p">,</span>
            <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
            <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="c1"># Fix T coordinate for the predicted year (simple approach)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># Compute tercile probabilities using cross-validated hindcast_det_cross</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>

        <span class="c1"># Distribution method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>

        <span class="c1"># Return the final forecast and its tercile probabilities</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="BMA">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA">[docs]</a>
<span class="k">class</span> <span class="nc">BMA</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">observations</span><span class="p">,</span>
        <span class="n">model_predictions</span><span class="p">,</span>
        <span class="n">model_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">error_metric</span><span class="o">=</span><span class="s2">&quot;rmse&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bayesian Model Averaging (BMA) class, supporting either RMSE- or MAE-based priors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        observations : 1D array of length T</span>
<span class="sd">            Observed values over time.</span>
<span class="sd">        model_predictions : list of 1D arrays</span>
<span class="sd">            Each element is a model&#39;s predictions over the same time period (length T).</span>
<span class="sd">        model_names : list of str, optional</span>
<span class="sd">            If not provided or mismatched, names are generated.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Hyperparameter controlling how strongly the chosen error metric influences prior weights.</span>
<span class="sd">        error_metric : {&quot;rmse&quot;, &quot;mae&quot;}, optional</span>
<span class="sd">            Which error metric to use for prior weighting. Default is &quot;rmse&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_predictions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="n">model_predictions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_predictions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_metric</span> <span class="o">=</span> <span class="n">error_metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Handle model names</span>
        <span class="k">if</span> <span class="n">model_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_names</span> <span class="o">=</span> <span class="n">model_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Model</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)]</span>

        <span class="c1"># Attributes to be computed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rmse_or_mae_vals</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># Will store either RMSEs or MAEs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waics</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Store posterior means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

<div class="viewcode-block" id="BMA.compute_error_based_prior">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.compute_error_based_prior">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_error_based_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute either RMSE or MAE for each model vs. observations, </span>
<span class="sd">        then use exp(-alpha * error) for priors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">preds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_predictions</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_metric</span> <span class="o">==</span> <span class="s2">&quot;rmse&quot;</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">preds</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_metric</span> <span class="o">==</span> <span class="s2">&quot;mae&quot;</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">preds</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid error_metric: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">error_metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">error_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rmse_or_mae_vals</span> <span class="o">=</span> <span class="n">error_vals</span>
        <span class="n">unnorm_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_vals</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="o">=</span> <span class="n">unnorm_prior</span> <span class="o">/</span> <span class="n">unnorm_prior</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="BMA.fit_models_pymc">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.fit_models_pymc">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_models_pymc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">draws</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
        <span class="n">tune</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">target_accept</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">init</span><span class="o">=</span><span class="s2">&quot;adapt_diag&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a PyMC model for each set of predictions: y ~ offset + scale * preds + noise.</span>
<span class="sd">        Then compute WAIC and store offset, scale from posterior means.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        draws : int</span>
<span class="sd">            The number of samples (in each chain) to draw from the posterior.</span>
<span class="sd">        tune : int</span>
<span class="sd">            The number of tuning (burn-in) steps.</span>
<span class="sd">        chains : int</span>
<span class="sd">            The number of chains to run.</span>
<span class="sd">        target_accept : float</span>
<span class="sd">            The target acceptance probability for the sampler.</span>
<span class="sd">        init : str</span>
<span class="sd">            The initialization method for PyMC&#39;s sampler. E.g., &quot;adapt_diag&quot;, &quot;jitter+adapt_diag&quot;, &quot;advi+adapt_diag&quot;, &quot;adapt_full&quot;, &quot;jitter+adapt_full&quot;, &quot;auto&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Default to equal priors if not computed yet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">waics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_predictions</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">():</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>

                <span class="n">mu</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">preds</span>
                <span class="n">y_obs</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">&quot;y_obs&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">)</span>

                <span class="n">idata</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="n">draws</span><span class="o">=</span><span class="n">draws</span><span class="p">,</span>
                    <span class="n">tune</span><span class="o">=</span><span class="n">tune</span><span class="p">,</span>
                    <span class="n">chains</span><span class="o">=</span><span class="n">chains</span><span class="p">,</span>
                    <span class="n">target_accept</span><span class="o">=</span><span class="n">target_accept</span><span class="p">,</span>
                    <span class="n">progressbar</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                    <span class="n">return_inferencedata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">idata_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;log_likelihood&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
                    <span class="n">init</span><span class="o">=</span><span class="n">init</span>  <span class="c1"># &lt;&lt;--- Now user-selectable</span>
                <span class="p">)</span>

                <span class="c1"># Compute WAIC</span>
                <span class="n">waic_res</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">waic</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span>
                <span class="n">waic_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">waic_res</span><span class="o">.</span><span class="n">elpd_waic</span>  <span class="c1"># from ELPD to &#39;traditional&#39; WAIC</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">waics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waic_val</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span>

            <span class="c1"># Posterior means for offset, scale, sigma</span>
            <span class="n">offset_mean</span> <span class="o">=</span> <span class="n">idata</span><span class="o">.</span><span class="n">posterior</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">scale_mean</span> <span class="o">=</span> <span class="n">idata</span><span class="o">.</span><span class="n">posterior</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">sigma_mean</span> <span class="o">=</span> <span class="n">idata</span><span class="o">.</span><span class="n">posterior</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">model_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset_mean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_scales</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_mean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_mean</span></div>


<div class="viewcode-block" id="BMA.compute_model_posterior_probs">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.compute_model_posterior_probs">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model_posterior_probs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine model priors and WAIC-based likelihood approximation to get posterior probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Run fit_models_pymc() first.&quot;</span><span class="p">)</span>

        <span class="n">min_waic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waics</span><span class="p">)</span>
        <span class="n">delta_waic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waics</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_waic</span>
        <span class="n">likelihood_approx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">delta_waic</span><span class="p">)</span>
        <span class="n">unnorm_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="o">*</span> <span class="n">likelihood_approx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="o">=</span> <span class="n">unnorm_posterior</span> <span class="o">/</span> <span class="n">unnorm_posterior</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="BMA.predict_in_sample">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.predict_in_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">predict_in_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute in-sample predictions using offset + scale for each model, weighted by posterior_probs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Compute posterior probabilities first.&quot;</span><span class="p">)</span>

        <span class="n">bma_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_predictions</span><span class="p">):</span>
            <span class="n">corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_scales</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">preds</span>
            <span class="n">bma_preds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">corrected</span>
        <span class="k">return</span> <span class="n">bma_preds</span></div>


<div class="viewcode-block" id="BMA.predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future_model_preds_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute out-of-sample (future) predictions for each model, applying offset+scale,</span>
<span class="sd">        and then weighting by posterior probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Compute posterior probabilities first.&quot;</span><span class="p">)</span>

        <span class="n">future_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">future_model_preds_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bma_pred_future</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">future_len</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">preds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">future_model_preds_list</span><span class="p">):</span>
            <span class="n">corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_scales</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">preds</span>
            <span class="n">bma_pred_future</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">corrected</span>
        <span class="k">return</span> <span class="n">bma_pred_future</span></div>


<div class="viewcode-block" id="BMA.summary">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.BMA.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary for whichever error metric is used (RMSE or MAE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== BMA Summary ===&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmse_or_mae_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="s2">&quot;RMSE&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_metric</span> <span class="o">==</span> <span class="s2">&quot;rmse&quot;</span> <span class="k">else</span> <span class="s2">&quot;MAE&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">err_str</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmse_or_mae_vals</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ev</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Prior probabilities:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_priors</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">WAIC:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waics</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Posterior probabilities:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_probs</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">pp</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Posterior Means for offset &amp; scale:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: offset=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, scale=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_scales</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=======================&quot;</span><span class="p">)</span></div>
</div>





<div class="viewcode-block" id="WAS_mme_BMA">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_BMA</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">all_hdcst_models</span><span class="p">,</span> <span class="n">all_fcst_models</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">alpha_</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">error_metric_</span><span class="o">=</span><span class="s2">&quot;rmse&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for Bayesian Model Averaging (BMA) applied to Multi-Model Ensemble data in xarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obs : xarray.DataArray</span>
<span class="sd">            Observed rainfall, shape (T, M, Y, X) or (T, Y, X) if M=1 is squeezed.</span>
<span class="sd">        all_hdcst_models : xarray.DataArray</span>
<span class="sd">            Hindcast model outputs, shape (T, M, Y, X).</span>
<span class="sd">        all_fcst_models : xarray.DataArray</span>
<span class="sd">            Forecast model outputs, shape (T, M, Y, X).</span>
<span class="sd">        dist_method : str</span>
<span class="sd">            Distribution method for post-processing (e.g., &#39;gamma&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_hdcst_models</span> <span class="o">=</span> <span class="n">all_hdcst_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_fcst_models</span> <span class="o">=</span> <span class="n">all_fcst_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>  <span class="c1"># For post-processing methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span> <span class="o">=</span> <span class="n">alpha_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_metric_</span> <span class="o">=</span> <span class="n">error_metric_</span>
    
        <span class="c1"># Extract model names from &#39;M&#39; dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_hdcst_models</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Reshape/clean data for BMA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_data</span><span class="p">()</span>

        <span class="c1"># Initialize BMA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bma</span> <span class="o">=</span> <span class="n">BMA</span><span class="p">(</span>
            <span class="n">observations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_flattened</span><span class="p">,</span>
            <span class="n">model_predictions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hdcst_flattened</span><span class="p">,</span>
            <span class="n">model_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_names</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span><span class="p">,</span>
            <span class="n">error_metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_metric_</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reshape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flatten the xarray data from (T, M, Y, X) -&gt; 1D arrays, removing positions that have NaNs</span>
<span class="sd">        in obs or *any* of the M models. The same approach is used for the forecast data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># Extract dimensions</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_hdcst_models</span><span class="o">.</span><span class="n">shape</span>
    
        <span class="c1"># Observations might have an M dim if they are shaped (T, 1, Y, X)</span>
        <span class="c1"># If that&#39;s the case, we drop that dimension (we only need the actual obs array)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">obs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># shape (T, Y, X)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span>  <span class="c1"># shape (T, Y, X)</span>
    
        <span class="c1"># Flatten observations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obs_flattened_raw</span> <span class="o">=</span> <span class="n">obs_2d</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># 1) Build training mask across *all* hindcast models + obs</span>
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># Initialize training mask from obs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obs_flattened_raw</span><span class="p">)</span>
    
        <span class="c1"># Flatten each hindcast model and update the training mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdcst_flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">model_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="c1"># Select and flatten this model</span>
            <span class="n">da_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_hdcst_models</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_idx</span><span class="p">)</span>  <span class="c1"># shape (T, Y, X)</span>
            <span class="n">da_model_flat</span> <span class="o">=</span> <span class="n">da_model</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
            <span class="c1"># Update the mask: positions with NaNs in this model become True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_nan_mask</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_model_flat</span><span class="p">)</span>
    
            <span class="c1"># Append to list for now (we&#39;ll mask them next)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdcst_flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">da_model_flat</span><span class="p">)</span>
    
        <span class="c1"># Now mask out the NaNs from obs and from each model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_flattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_flattened_raw</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdcst_flattened</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">train_nan_mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdcst_flattened</span><span class="p">]</span>
    
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># 2) Build forecast mask across *all* forecast models</span>
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># Flatten each forecast model and update the forecast mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fcst_flattened_raw</span> <span class="o">=</span> <span class="n">obs_2d</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcst_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fcst_flattened_raw</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">fcst_flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">model_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="n">da_fcst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_fcst_models</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_idx</span><span class="p">)</span>
            <span class="n">da_fcst_flat</span> <span class="o">=</span> <span class="n">da_fcst</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fcst_nan_mask</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_fcst_flat</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fcst_flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">da_fcst_flat</span><span class="p">)</span>
        <span class="c1"># Now store the forecast data, omitting positions of NaNs across any forecast model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcst_flattened</span> <span class="o">=</span> <span class="p">[</span><span class="n">fcst_vals</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fcst_nan_mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">fcst_vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fcst_flattened</span><span class="p">]</span>
            
        <span class="c1"># Store shape for rebuilding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span>


<div class="viewcode-block" id="WAS_mme_BMA.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.compute">[docs]</a>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draws</span><span class="p">,</span> <span class="n">tune</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">target_accept</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s2">&quot;jitter+adapt_diag&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        draws : int</span>
<span class="sd">            The number of samples (in each chain) to draw from the posterior.</span>
<span class="sd">        tune : int</span>
<span class="sd">            The number of tuning (burn-in) steps.</span>
<span class="sd">        chains : int</span>
<span class="sd">            The number of chains to run.</span>
<span class="sd">        verbose: bool</span>
<span class="sd">            Show progress.</span>
<span class="sd">        target_accept : float</span>
<span class="sd">            The target acceptance probability for the sampler.</span>
<span class="sd">        init : str</span>
<span class="sd">            The initialization method for PyMC&#39;s sampler. E.g., &quot;adapt_diag&quot;, &quot;jitter+adapt_diag&quot;, &quot;advi+adapt_diag&quot;, &quot;adapt_full&quot;, &quot;jitter+adapt_full&quot;, &quot;auto&quot;.</span>
<span class="sd">        Runs the BMA workflow on hindcasts: </span>
<span class="sd">          1) compute_rmse_based_prior</span>
<span class="sd">          2) fit_models_pymc</span>
<span class="sd">          3) compute_model_posterior_probs</span>
<span class="sd">        Returns in-sample predictions as an xarray.DataArray (T, Y, X).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">compute_error_based_prior</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">fit_models_pymc</span><span class="p">(</span><span class="n">draws</span><span class="p">,</span> <span class="n">tune</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">target_accept</span><span class="o">=</span><span class="n">target_accept</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">compute_model_posterior_probs</span><span class="p">()</span>
        

        <span class="c1"># In-sample predictions (1D)</span>
        <span class="n">bma_in_sample_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">predict_in_sample</span><span class="p">()</span>

        <span class="c1"># Put predictions back into the original shape with NaNs</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obs_flattened_raw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">train_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bma_in_sample_flat</span>
        <span class="n">result_3d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Rebuild as DataArray</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">obs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># coords for T, Y, X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span>

        <span class="n">bma_in_sample_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">result_3d</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">obs_2d</span><span class="o">.</span><span class="n">coords</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bma_in_sample_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>

        

<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>

        

<div class="viewcode-block" id="WAS_mme_BMA.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>

        

<div class="viewcode-block" id="WAS_mme_BMA.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for the hindcast using the chosen distribution method.</span>
<span class="sd">        Predictant is an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="WAS_mme_BMA.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply BMA offset+scale weights to future forecasts, returning an xarray.DataArray (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">posterior_probs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Run train_bma() before predicting.&quot;</span><span class="p">)</span>

        <span class="n">bma_forecast_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fcst_flattened</span><span class="p">)</span>

        <span class="c1"># Re-insert NaNs</span>
        <span class="n">result_fcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fcst_flattened_raw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">result_fcst</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fcst_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bma_forecast_flat</span>
        <span class="n">result_fcst_3d</span> <span class="o">=</span> <span class="n">result_fcst</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>

        <span class="n">fcst_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_fcst_models</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># shape (T, Y, X)</span>

        <span class="n">bma_forecast_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">result_fcst_3d</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">fcst_2d</span><span class="o">.</span><span class="n">coords</span>
        <span class="p">)</span>

        <span class="n">year</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_fcst_models</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">bma_forecast_da</span> <span class="o">=</span> <span class="n">bma_forecast_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">bma_forecast_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bma_forecast_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        
        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">bma_forecast_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">bma_forecast_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">bma_forecast_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">bma_forecast_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">bma_forecast_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">bma_forecast_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>    </div>


<div class="viewcode-block" id="WAS_mme_BMA.summary">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_BMA.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Print BMA summary information. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bma</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_ELR">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELR">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_ELR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extended Logistic Regression (ELR) for Multi-Model Ensemble (MME) forecasting derived from xcast package.</span>

<span class="sd">    This class implements an Extended Logistic Regression for probabilistic forecasting,</span>
<span class="sd">    directly computing tercile probabilities without requiring separate probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    elm_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments to pass to the xcast ELR model. If None, an empty dictionary is used.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elm_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elm_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="n">elm_kwargs</span>     

<div class="viewcode-block" id="WAS_mme_ELR.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELR.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute probabilistic hindcast using the ELR model.</span>

<span class="sd">        Fits the ELR model on training data and predicts tercile probabilities for the test data.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELR</span><span class="p">()</span> <span class="c1"># **self.elm_kwargs</span>
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="s1">&#39;probability&#39;</span><span class="p">})</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_ELR.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELR.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate probabilistic forecast for a target year using the ELR model.</span>

<span class="sd">        Fits the ELR model on hindcast data and predicts tercile probabilities for the target year.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period (not used in this method).</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period (not used in this method).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">clim_year_end</span> <span class="o">=</span> <span class="n">clim_year_end</span>
        <span class="n">clim_year_start</span> <span class="o">=</span> <span class="n">clim_year_start</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">Predictant</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">hindcast_det_</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELR</span><span class="p">()</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="s1">&#39;probability&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span></div>
</div>


<div class="viewcode-block" id="NonHomogeneousGaussianRegression">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.NonHomogeneousGaussianRegression">[docs]</a>
<span class="k">class</span> <span class="nc">NonHomogeneousGaussianRegression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Placeholder for Non-Homogeneous Gaussian Regression model.</span>

<span class="sd">    This class is not implemented in the provided code and serves as a placeholder for future development.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

    
<div class="viewcode-block" id="WAS_mme_ELM">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_ELM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extreme Learning Machine (ELM) for Multi-Model Ensemble (MME) forecasting derived from xcast.</span>

<span class="sd">    This class implements an Extreme Learning Machine model for deterministic forecasting,</span>
<span class="sd">    with optional tercile probability calculations using various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    elm_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments to pass to the xcast ELM model. If None, default parameters are used:</span>
<span class="sd">        {&#39;regularization&#39;: 10, &#39;hidden_layer_size&#39;: 5, &#39;activation&#39;: &#39;lin&#39;, &#39;preprocessing&#39;: &#39;none&#39;, &#39;n_estimators&#39;: 5}.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elm_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elm_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;regularization&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;hidden_layer_size&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="s1">&#39;lin&#39;</span><span class="p">,</span>  <span class="c1"># &#39;sigm&#39;, &#39;tanh&#39;, &#39;lin&#39;, &#39;leaky&#39;, &#39;relu&#39;, &#39;softplus&#39;],</span>
                <span class="s1">&#39;preprocessing&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>  <span class="c1"># &#39;minmax&#39;, &#39;std&#39;, &#39;none&#39; ],</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="n">elm_kwargs</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>         

<div class="viewcode-block" id="WAS_mme_ELM.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the ELM model.</span>

<span class="sd">        Fits the ELM model on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">X_train</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        
        <span class="c1"># X_train = X_train.fillna(0)</span>
        <span class="c1"># y_train = y_train.fillna(0)</span>
        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELM</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span><span class="p">)</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_ELM.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_ELM.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for hindcast data.</span>

<span class="sd">        Calculates probabilities for below-normal, normal, and above-normal categories using</span>
<span class="sd">        the specified distribution method, based on climatological terciles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_ELM.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_ELM.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross_val</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the ELM model.</span>

<span class="sd">        Fits the ELM model on hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        and computes tercile probabilities. Applies regridding, drymasking, and standardization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross_val : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">Predictant</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="c1"># hindcast_det_ = hindcast_det.fillna(0)</span>
        <span class="c1"># Predictant_ = Predictant.fillna(0)</span>
        <span class="c1"># Predictor_for_year_ = Predictor_for_year.fillna(0)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELM</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span><span class="p">)</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>


        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross_val</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross_val</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>


          
<div class="viewcode-block" id="WAS_mme_MLP">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_MLP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi-Layer Perceptron (MLP) for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a Multi-Layer Perceptron model using scikit-learn&#39;s MLPRegressor</span>
<span class="sd">    for deterministic forecasting, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hidden_layer_sizes : tuple, optional</span>
<span class="sd">        Sizes of the hidden layers in the MLP (e.g., (10, 5)). Default is (10, 5).</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function for the hidden layers (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;).</span>
<span class="sd">        Default is &#39;relu&#39;.</span>
<span class="sd">    solver : str, optional</span>
<span class="sd">        Optimization algorithm (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;). Default is &#39;adam&#39;.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum number of iterations for the solver. Default is 200.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        L2 regularization parameter. Default is 0.01.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span> <span class="o">=</span> <span class="n">hidden_layer_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_MLP.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the MLP model.</span>

<span class="sd">        Fits the MLPRegressor on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Handles data stacking and NaN removal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize MLPRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                                <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for the hindcast using the chosen distribution method.</span>
<span class="sd">        Predictant is an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_MLP.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the MLP model.</span>

<span class="sd">        Fits the MLPRegressor on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># For forecast, we use the same single MLP model.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                                    <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                                    <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                                    <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>


        
        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_GradientBoosting">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_GradientBoosting</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Single-model implementation using GradientBoostingRegressor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">         - n_estimators: int, number of boosting iterations.</span>
<span class="sd">         - learning_rate: float, learning rate.</span>
<span class="sd">         - max_depth: int, maximum depth of individual regression estimators.</span>
<span class="sd">         - random_state: int, for reproducibility.</span>
<span class="sd">         - dist_method: string, method for tercile probability calculations.</span>
<span class="sd">                        Options: &#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">gb</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_GradientBoosting.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the GradientBoostingRegressor on the training data and predict on X_test.</span>
<span class="sd">        The input data (xarray DataArrays) are assumed to have dimensions including &#39;T&#39;, &#39;Y&#39;, &#39;X&#39;.</span>
<span class="sd">        The predictions are then reshaped back to (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gb</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                            <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                            <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the model and predict on non-NaN testing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct predictions (leaving NaN rows unchanged)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GradientBoosting.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_GradientBoosting.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant is expected to be an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span> 
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_GradientBoosting.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_GradientBoosting.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single MLP model.</span>
<span class="sd">        Steps:</span>
<span class="sd">         - Standardize the predictor for the target year using hindcast climatology.</span>
<span class="sd">         - Fit the MLP (if not already fitted) on standardized hindcast data.</span>
<span class="sd">         - Predict for the target year.</span>
<span class="sd">         - Reconstruct predictions into original (T, Y, X) shape.</span>
<span class="sd">         - Reverse the standardization.</span>
<span class="sd">         - Compute tercile probabilities using the chosen distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gb</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                                <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                                <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>        
        
        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_XGBoosting">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_XGBoosting</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XGBoost-based Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a single-model forecasting approach using XGBoost&#39;s XGBRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of boosting rounds. Default is 100.</span>
<span class="sd">    learning_rate : float, optional</span>
<span class="sd">        Learning rate for boosting. Default is 0.1.</span>
<span class="sd">    max_depth : int, optional</span>
<span class="sd">        Maximum tree depth for base learners. Default is 3.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_XGBoosting.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the XGBoost model.</span>

<span class="sd">        Fits the XGBRegressor on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Handles data stacking and NaN removal to ensure robust predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the XGBRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                                <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        
        <span class="c1"># Fit the XGBRegressor and predict on non-NaN testing rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct predictions: keep rows with NaNs unchanged</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># def compute_model(self, X_train, y_train, X_test, y_test):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Fit an XGBRegressor to spatiotemporal training data and predict on the test data.</span>
        
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     X_train, y_train : xarray.DataArray</span>
    <span class="c1">#         Training features and target values with dims (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;M&#39;) or (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;) if M=1.</span>
        
    <span class="c1">#     X_test, y_test : xarray.DataArray</span>
    <span class="c1">#         Test features and target values with the same structure.</span>
        
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     predicted_da : xarray.DataArray</span>
    <span class="c1">#         Predictions in the same shape as y_test, with coords (T, Y, X).</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # === Ensure model hyperparameters are valid ===</span>
    <span class="c1">#     n_estimators = int(self.n_estimators) if hasattr(self, &#39;n_estimators&#39;) else 100</span>
    <span class="c1">#     learning_rate = float(self.learning_rate) if hasattr(self, &#39;learning_rate&#39;) else 0.1</span>
    <span class="c1">#     max_depth = int(self.max_depth) if hasattr(self, &#39;max_depth&#39;) else 3</span>
    <span class="c1">#     random_state = int(self.random_state) if hasattr(self, &#39;random_state&#39;) else 42</span>
    
    <span class="c1">#     # === Initialize model ===</span>
    <span class="c1">#     self.xgb = XGBRegressor(</span>
    <span class="c1">#         n_estimators=n_estimators,</span>
    <span class="c1">#         learning_rate=learning_rate,</span>
    <span class="c1">#         max_depth=max_depth,</span>
    <span class="c1">#         random_state=random_state,</span>
    <span class="c1">#         verbosity=0</span>
    <span class="c1">#     )</span>
    
    <span class="c1">#     # === Extract coordinates for output reconstruction ===</span>
    <span class="c1">#     time = X_test[&#39;T&#39;]</span>
    <span class="c1">#     lat = X_test[&#39;Y&#39;]</span>
    <span class="c1">#     lon = X_test[&#39;X&#39;]</span>
    <span class="c1">#     n_time, n_lat, n_lon = len(time), len(lat), len(lon)</span>
    
    <span class="c1">#     # === Stack training data ===</span>
    <span class="c1">#     X_train_stacked = X_train.stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).transpose(&#39;sample&#39;, ...).values</span>
    <span class="c1">#     y_train_stacked = y_train.stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).transpose(&#39;sample&#39;, ...).values</span>
    
    <span class="c1">#     train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
    <span class="c1">#     X_train_clean = X_train_stacked[~train_nan_mask]</span>
    <span class="c1">#     y_train_clean = y_train_stacked[~train_nan_mask].ravel()</span>
    
    <span class="c1">#     # === Stack test data ===</span>
    <span class="c1">#     X_test_stacked = X_test.stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).transpose(&#39;sample&#39;, ...).values</span>
    <span class="c1">#     y_test_stacked = y_test.stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).transpose(&#39;sample&#39;, ...).values</span>
    <span class="c1">#     test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
    
    <span class="c1">#     # === Fit model and predict ===</span>
    <span class="c1">#     self.xgb.fit(X_train_clean, y_train_clean)</span>
    <span class="c1">#     y_pred = self.xgb.predict(X_test_stacked[~test_nan_mask])</span>
    
    <span class="c1">#     # === Reconstruct prediction array ===</span>
    <span class="c1">#     result = np.full(y_test_stacked.shape, np.nan)</span>
    <span class="c1">#     result[~test_nan_mask] = y_pred.reshape(-1, 1)</span>
    
    <span class="c1">#     predictions_reshaped = result.reshape(n_time, n_lat, n_lon)</span>
    
    <span class="c1">#     predicted_da = xr.DataArray(</span>
    <span class="c1">#         data=predictions_reshaped,</span>
    <span class="c1">#         coords={&#39;T&#39;: time, &#39;Y&#39;: lat, &#39;X&#39;: lon},</span>
    <span class="c1">#         dims=[&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;]</span>
    <span class="c1">#     )</span>
    
    <span class="c1">#     return predicted_da</span>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for hindcast data.</span>

<span class="sd">        Calculates probabilities for below-normal, normal, and above-normal categories using</span>
<span class="sd">        the specified distribution method, based on climatological terciles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="s2">        Predictant is expected to be an xarray DataArray with dims (T, Y, X).</span>
<span class="s2">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_XGBoosting.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the XGBoost model.</span>

<span class="sd">        Fits the XGBRegressor on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Use the same single XGBoost model for forecasting.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                    <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                    <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                                    <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_AdaBoost">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_AdaBoost</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AdaBoost-based Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a single-model forecasting approach using scikit-learn&#39;s AdaBoostRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of boosting iterations. Default is 50.</span>
<span class="sd">    learning_rate : float, optional</span>
<span class="sd">        Learning rate for boosting. Default is 0.1.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_AdaBoost.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the AdaBoost model.</span>

<span class="sd">        Fits the AdaBoostRegressor on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Handles data stacking and NaN removal to ensure robust predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the AdaBoostRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span> <span class="o">=</span> <span class="n">AdaBoostRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                          <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                          <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the AdaBoost model and predict on non-NaN testing rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct prediction array (leaving rows with NaNs unchanged)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_AdaBoost.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_AdaBoost.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant is expected to be an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_AdaBoost.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_AdaBoost.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the AdaBoost model.</span>

<span class="sd">        Fits the AdaBoostRegressor on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a land mask from the first time step</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="c1"># Standardize hindcast and predictant</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Use the same XGBoost model for forecasting.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span> <span class="o">=</span> <span class="n">AdaBoostRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                              <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                              <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaboost</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_LGBM_Boosting">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_LGBM_Boosting</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LightGBM-based Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a single-model forecasting approach using LightGBM&#39;s LGBMRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of boosting iterations. Default is 100.</span>
<span class="sd">    learning_rate : float, optional</span>
<span class="sd">        Learning rate for boosting. Default is 0.1.</span>
<span class="sd">    max_depth : int, optional</span>
<span class="sd">        Maximum tree depth (-1 for no limit). Default is -1.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the LightGBM model.</span>

<span class="sd">        Fits the LGBMRegressor on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Handles data stacking and NaN removal to ensure robust predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize LGBMRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span> <span class="o">=</span> <span class="n">LGBMRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                  <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                  <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                  <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the model and predict on non-NaN rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant is expected to be an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_LGBM_Boosting.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_LGBM_Boosting.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the LightGBM model.</span>

<span class="sd">        Fits the LGBMRegressor on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Create a mask from the first time step (excluding NaNs)</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="c1"># Standardize hindcast and predictant</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Use the same XGBoost model for forecasting.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span> <span class="o">=</span> <span class="n">LGBMRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                                      <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                                      <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                                      <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgbm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on predictions using the chosen distribution method</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
                        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



    
<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Stack_MLP_RF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with MLP and Random Forest for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using MLPRegressor and RandomForestRegressor as base models,</span>
<span class="sd">    with a LinearRegression meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hidden_layer_sizes : tuple, optional</span>
<span class="sd">        Sizes of the hidden layers for the MLP base model (e.g., (10, 5)). Default is (10, 5).</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function for the MLP (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;). Default is &#39;relu&#39;.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum number of iterations for the MLP solver. Default is 200.</span>
<span class="sd">    solver : str, optional</span>
<span class="sd">        Optimization algorithm for the MLP (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;). Default is &#39;adam&#39;.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        L2 regularization parameter for the MLP. Default is 0.01.</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of trees in the Random Forest base model. Default is 100.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                 <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                 <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
                 <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span> <span class="o">=</span> <span class="n">hidden_layer_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the stacking ensemble of MLP and Random Forest.</span>

<span class="sd">        Fits the stacking ensemble (MLP and Random Forest base models with a LinearRegression meta-model)</span>
<span class="sd">        on training data and predicts deterministic values for the test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize the base models (MLP and Random Forest)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;mlp&#39;</span><span class="p">,</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">))</span>
        <span class="p">]</span>
        
        <span class="c1"># Initialize the meta-model (Linear Regression)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        
        <span class="c1"># Initialize the stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        This method extracts the climatology terciles from Predictant over the period</span>
<span class="sd">        [clim_year_start, clim_year_end], computes an error variance (or uses error samples),</span>
<span class="sd">        and then applies the chosen probability function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="c1"># For error variance, here we use the difference between Predictant and hindcast_det</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="c1"># For nonparametric, assume hindcast_det contains error samples</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove any rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_RF.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_RF.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method that uses the trained stacking ensemble to predict for a new year,</span>
<span class="sd">        then computes tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if &quot;M&quot; in Predictant.coords:</span>
        <span class="c1">#     Predictant = Predictant.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Standardize predictor for the target year using hindcast stats</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble (if not already done)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;mlp&#39;</span><span class="p">,</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span> <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on the predictions using the chosen distribution</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Stack_Lasso_RF_MLP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with Lasso and Random Forest base models, and MLP meta-model for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using Lasso and RandomForestRegressor as base models,</span>
<span class="sd">    with an MLPRegressor meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lasso_alpha : float, optional</span>
<span class="sd">        Regularization strength for the Lasso base model. Default is 0.01.</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of trees in the Random Forest base model. Default is 100.</span>
<span class="sd">    mlp_hidden_layer_sizes : tuple, optional</span>
<span class="sd">        Sizes of the hidden layers for the MLP meta-model (e.g., (10, 5)). Default is (10, 5).</span>
<span class="sd">    mlp_activation : str, optional</span>
<span class="sd">        Activation function for the MLP (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;). Default is &#39;relu&#39;.</span>
<span class="sd">    mlp_solver : str, optional</span>
<span class="sd">        Optimization algorithm for the MLP (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;). Default is &#39;adam&#39;.</span>
<span class="sd">    mlp_max_iter : int, optional</span>
<span class="sd">        Maximum number of iterations for the MLP solver. Default is 200.</span>
<span class="sd">    mlp_alpha : float, optional</span>
<span class="sd">        L2 regularization parameter for the MLP. Default is 0.01.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">lasso_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
                 <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                 <span class="n">mlp_hidden_layer_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> 
                 <span class="n">mlp_activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> 
                 <span class="n">mlp_solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> 
                 <span class="n">mlp_max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                 <span class="n">mlp_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base models: Lasso and RandomForestRegressor.</span>
<span class="sd">        Meta-model: MLPRegressor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lasso_alpha</span> <span class="o">=</span> <span class="n">lasso_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_hidden_layer_sizes</span> <span class="o">=</span> <span class="n">mlp_hidden_layer_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_activation</span> <span class="o">=</span> <span class="n">mlp_activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_solver</span> <span class="o">=</span> <span class="n">mlp_solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_max_iter</span> <span class="o">=</span> <span class="n">mlp_max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span> <span class="o">=</span> <span class="n">mlp_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the stacking ensemble of Lasso and Random Forest with an MLP meta-model.</span>

<span class="sd">        Fits the stacking ensemble (Lasso and Random Forest base models with an MLPRegressor meta-model)</span>
<span class="sd">        on training data and predicts deterministic values for the test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define base models: Lasso and RandomForestRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;lasso&#39;</span><span class="p">,</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lasso_alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="c1"># Define meta-model: MLPRegressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_hidden_layer_sizes</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_activation</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_solver</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span>
        <span class="p">)</span>
        <span class="c1"># Create stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant should be an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is in (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack DataArray from (T, Y, X[, M]) to (n_samples, n_features),</span>
<span class="sd">        and remove rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_Stack_Lasso_RF_MLP.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_Lasso_RF_MLP.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the stacking ensemble.</span>

<span class="sd">        Fits the stacking ensemble (Lasso and Random Forest base models with an MLPRegressor meta-model)</span>
<span class="sd">        on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
      
        
        <span class="c1"># Standardize predictor for the target year using hindcast stats</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble if not already done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;lasso&#39;</span><span class="p">,</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lasso_alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_hidden_layer_sizes</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_activation</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_solver</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span> <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="c1"># Compute tercile probabilities using the chosen distribution method</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Stack_MLP_Ada_Ridge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with MLP and AdaBoost base models, and Ridge meta-model for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using MLPRegressor and AdaBoostRegressor as base models,</span>
<span class="sd">    with a Ridge meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hidden_layer_sizes : tuple, optional</span>
<span class="sd">        Sizes of the hidden layers for the MLP base model (e.g., (10, 5)). Default is (10, 5).</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function for the MLP (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;). Default is &#39;relu&#39;.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum number of iterations for the MLP solver. Default is 200.</span>
<span class="sd">    solver : str, optional</span>
<span class="sd">        Optimization algorithm for the MLP (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;). Default is &#39;adam&#39;.</span>
<span class="sd">    mlp_alpha : float, optional</span>
<span class="sd">        L2 regularization parameter for the MLP. Default is 0.01.</span>
<span class="sd">    n_estimators_adaboost : int, optional</span>
<span class="sd">        Number of boosting iterations for AdaBoost. Default is 50.</span>
<span class="sd">    ridge_alpha : float, optional</span>
<span class="sd">        Regularization strength for the Ridge meta-model. Default is 1.0.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> 
                 <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> 
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                 <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> 
                 <span class="n">mlp_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">n_estimators_adaboost</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
                 <span class="n">ridge_alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> 
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span> <span class="o">=</span> <span class="n">hidden_layer_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span> <span class="o">=</span> <span class="n">mlp_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_adaboost</span> <span class="o">=</span> <span class="n">n_estimators_adaboost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridge_alpha</span> <span class="o">=</span> <span class="n">ridge_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the stacking ensemble of MLP and AdaBoost with a Ridge meta-model.</span>

<span class="sd">        Fits the stacking ensemble (MLP and AdaBoost base models with a Ridge meta-model)</span>
<span class="sd">        on training data and predicts deterministic values for the test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define base models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;mlp&#39;</span><span class="p">,</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span>
            <span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="n">AdaBoostRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_adaboost</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
            <span class="p">))</span>
        <span class="p">]</span>
        <span class="c1"># Define meta-model (Ridge)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Build stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant is expected to be an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_Stack_MLP_Ada_Ridge.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_MLP_Ada_Ridge.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the stacking ensemble.</span>

<span class="sd">        Fits the stacking ensemble (MLP and AdaBoost base models with a Ridge meta-model)</span>
<span class="sd">        on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Standardize predictor for the target year using hindcast statistics</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>

        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble if not already done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;mlp&#39;</span><span class="p">,</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_alpha</span>
            <span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="n">AdaBoostRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_adaboost</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span> <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Stack_RF_GB_Ridge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with Random Forest and Gradient Boosting base models, and Ridge meta-model for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using RandomForestRegressor and GradientBoostingRegressor as base models,</span>
<span class="sd">    with a Ridge meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators_rf : int, optional</span>
<span class="sd">        Number of trees in the Random Forest base model. Default is 100.</span>
<span class="sd">    max_depth_rf : int or None, optional</span>
<span class="sd">        Maximum depth for Random Forest trees (None for no limit). Default is None.</span>
<span class="sd">    n_estimators_gb : int, optional</span>
<span class="sd">        Number of boosting iterations for Gradient Boosting. Default is 100.</span>
<span class="sd">    learning_rate_gb : float, optional</span>
<span class="sd">        Learning rate for Gradient Boosting. Default is 0.1.</span>
<span class="sd">    ridge_alpha : float, optional</span>
<span class="sd">        Regularization strength for the Ridge meta-model. Default is 1.0.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">n_estimators_rf</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                 <span class="n">max_depth_rf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_estimators_gb</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">learning_rate_gb</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">ridge_alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_rf</span> <span class="o">=</span> <span class="n">n_estimators_rf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_rf</span> <span class="o">=</span> <span class="n">max_depth_rf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_gb</span> <span class="o">=</span> <span class="n">n_estimators_gb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_gb</span> <span class="o">=</span> <span class="n">learning_rate_gb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridge_alpha</span> <span class="o">=</span> <span class="n">ridge_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the stacking ensemble of Random Forest and Gradient Boosting with a Ridge meta-model.</span>

<span class="sd">        Fits the stacking ensemble (Random Forest and Gradient Boosting base models with a Ridge meta-model)</span>
<span class="sd">        on training data and predicts deterministic values for the test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define base models:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_rf</span><span class="p">,</span>
                                         <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_rf</span><span class="p">,</span>
                                         <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_gb</span><span class="p">,</span>
                                             <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_gb</span><span class="p">,</span>
                                             <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="c1"># Define meta-model (Ridge)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># Create the stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for hindcasts based on the chosen distribution.</span>
<span class="sd">        Predictant is an xarray DataArray with dims (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_Stack_RF_GB_Ridge.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_RF_GB_Ridge.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the stacking ensemble.</span>

<span class="sd">        Fits the stacking ensemble (Random Forest and Gradient Boosting base models with a Ridge meta-model)</span>
<span class="sd">        on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble if not already set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;mlp&#39;</span><span class="p">,</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>  <span class="c1"># Or set via parameters if needed</span>
                <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>
                <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span>
            <span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="n">AdaBoostRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span> <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>        
        
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_Stack_KNN_Tree_SVR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with K-Nearest Neighbors and Decision Tree base models, and SVR meta-model for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using KNeighborsRegressor and DecisionTreeRegressor as base models,</span>
<span class="sd">    with an SVR meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_neighbors : int, optional</span>
<span class="sd">        Number of neighbors for K-Nearest Neighbors. Default is 5.</span>
<span class="sd">    tree_max_depth : int or None, optional</span>
<span class="sd">        Maximum depth for the Decision Tree (None for no limit). Default is None.</span>
<span class="sd">    svr_C : float, optional</span>
<span class="sd">        Regularization parameter for SVR. Default is 1.0.</span>
<span class="sd">    svr_kernel : str, optional</span>
<span class="sd">        Kernel type for SVR (&#39;linear&#39;, &#39;poly&#39;, &#39;rbf&#39;, &#39;sigmoid&#39;). Default is &#39;rbf&#39;.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">tree_max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">svr_C</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">svr_kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_max_depth</span> <span class="o">=</span> <span class="n">tree_max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">svr_C</span> <span class="o">=</span> <span class="n">svr_C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">svr_kernel</span> <span class="o">=</span> <span class="n">svr_kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the stacking ensemble of KNN and Decision Tree with an SVR meta-model.</span>

<span class="sd">        Fits the stacking ensemble (KNeighborsRegressor and DecisionTreeRegressor base models with an SVR meta-model)</span>
<span class="sd">        on training data and predicts deterministic values for the test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define base models:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_max_depth</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="c1"># Define meta-model: SVR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svr_C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svr_kernel</span><span class="p">)</span>
        
        <span class="c1"># Build stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_guess : array-like</span>
<span class="sd">            Forecast or best guess values.</span>
<span class="sd">        error_variance : array-like</span>
<span class="sd">            Variance associated with forecast errors.</span>
<span class="sd">        first_tercile : array-like</span>
<span class="sd">            First tercile threshold values.</span>
<span class="sd">        second_tercile : array-like</span>
<span class="sd">            Second tercile threshold values.</span>
<span class="sd">        dof : float or array-like</span>
<span class="sd">            Shape parameter for the Weibull minimum distribution.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred_prob : np.ndarray</span>
<span class="sd">            A 3 x n_time array with probabilities for being below the first tercile,</span>
<span class="sd">            between the first and second tercile, and above the second tercile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>

<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        Predictant is expected to be an xarray DataArray with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>  
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_Stack_KNN_Tree_SVR.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stack_KNN_Tree_SVR.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the stacking ensemble.</span>

<span class="sd">        Fits the stacking ensemble (KNN and Decision Tree base models with an SVR meta-model)</span>
<span class="sd">        on standardized hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        reverses standardization, and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Standardize the predictor for the target year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble if not already done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_max_depth</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svr_C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svr_kernel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span> <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span><span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        
        <span class="c1"># Fit the MLP model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>        
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml">[docs]</a>
<span class="k">class</span> <span class="nc">WAS_mme_StackXGboost_Ml</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble with XGBoost base model and Linear Regression meta-model for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    This class implements a stacking ensemble using XGBRegressor as the base model,</span>
<span class="sd">    with a LinearRegression meta-model, for deterministic forecasting and optional tercile probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators : int, optional</span>
<span class="sd">        Number of gradient boosted trees in XGBoost. Default is 100.</span>
<span class="sd">    max_depth : int, optional</span>
<span class="sd">        Maximum depth of each tree in XGBoost. Default is 3.</span>
<span class="sd">    learning_rate : float, optional</span>
<span class="sd">        Boosting learning rate for XGBoost. Default is 0.1.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for random number generation for reproducibility. Default is 42.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations</span>
<span class="sd">        (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
        <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="n">n_estimators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>

<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train a stacking regressor with XGBoost as the base model and </span>
<span class="sd">        Linear Regression as the meta-model, then generate deterministic</span>
<span class="sd">        predictions on X_test.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Predictor training data with dimensions (T, Y, X, M) or (T, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Predictand training data with dimensions (T, Y, X, M) or (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Predictor testing data with dimensions (T, Y, X, M) or (T, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Predictand testing data with dimensions (T, Y, X, M) or (T, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            The predictions over X_test in the original grid shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the base model (XGBoost)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">XGBRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
            <span class="p">))</span>
        <span class="p">]</span>
        
        <span class="c1"># Initialize the meta-model (Linear Regression)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        
        <span class="c1"># Initialize the stacking ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Fit the stacking ensemble only on rows without NaNs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Rebuild the predictions into the original shape,</span>
        <span class="c1"># leaving NaN rows intact.</span>
        <span class="c1"># Reconstruct predictions, leaving rows with NaNs intact</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred_test</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>
<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Student&#39;s t-based method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="c1"># Transform thresholds</span>
            <span class="n">first_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>
            <span class="n">second_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">second_tercile</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_std</span>

            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_t</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_weibull_min">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_weibull_min">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_weibull_min</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weibull minimum-based method.</span>
<span class="sd">        </span>
<span class="sd">        Here, we assume:</span>
<span class="sd">          - best_guess is used as the location,</span>
<span class="sd">          - error_std (sqrt(error_variance)) as the scale, and </span>
<span class="sd">          - dof (degrees of freedom) as the shape parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    
            <span class="c1"># Using the weibull_min CDF with best_guess as loc and error_std as scale.</span>
            <span class="c1"># Note: Adjust these assumptions if your application requires a different parameterization.</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> \
                               <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_gamma">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_gamma</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>

        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
        <span class="n">cdf_t1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">cdf_t2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cdf_t2</span> <span class="o">-</span> <span class="n">cdf_t1</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cdf_t2</span>

        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_normal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_normal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_normal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_lognormal">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.calculate_tercile_probabilities_lognormal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_tercile_probabilities_lognormal</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lognormal-distribution based method.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="n">pred_prob</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">pred_prob</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">first_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">second_tercile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.compute_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities using the chosen distribution method.</span>
<span class="sd">        This method extracts the climatology terciles from Predictant over the period</span>
<span class="sd">        [clim_year_start, clim_year_end], computes an error variance (or uses error samples),</span>
<span class="sd">        and then applies the chosen probability function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># Ensure Predictant is (T, Y, X)</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        
        <span class="c1"># For error variance, here we use the difference between Predictant and hindcast_det</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="c1"># Choose the appropriate probability calculation function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="c1"># For nonparametric, assume hindcast_det contains error samples</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove any rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span>

<div class="viewcode-block" id="WAS_mme_StackXGboost_Ml.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_StackXGboost_Ml.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method that uses the trained stacking ensemble to predict for a new year,</span>
<span class="sd">        then computes tercile probabilities.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Historical predictand data.</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start of the climatology period (e.g., 1981).</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End of the climatology period (e.g., 2010).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcasts used for training (predictors).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcasts for cross-validation (for error estimation).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target forecast year.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_da : xarray.DataArray</span>
<span class="sd">            The deterministic forecast for the target year.</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probability forecast for the target year.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Standardize the predictor for the target year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Initialize stacking ensemble (if not already done or to retrain)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">XGBRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
            <span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
            <span class="n">estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">,</span>
            <span class="n">final_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_model</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
        
        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># train_nan_mask = np.any(np.isnan(X_train_stacked), axis=1) | np.any(np.isnan(y_train_stacked), axis=1)</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        
        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># test_nan_mask = np.any(np.isnan(X_test_stacked), axis=1) | np.any(np.isnan(y_test_stacked), axis=1)</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>         
        <span class="c1"># Fit the stacking model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacking_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>
        
        <span class="c1"># Reconstruct the prediction array (keeping NaN rows intact)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>
        
        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>        
        
        <span class="c1"># Compute tercile probabilities on predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_weibull_min</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
            
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_gamma</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_normal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;lognormal&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_lognormal</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">calc_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">error_samples</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">})</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">calc_func</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;output_sizes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>