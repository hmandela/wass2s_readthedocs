

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_mme &mdash; wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel. 0.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1e28cc32"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_mme</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_mme</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">arviz</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">az</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">minimize_scalar</span><span class="p">,</span> <span class="n">fsolve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">expit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">norm</span><span class="p">,</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">weibull_min</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">nbinom</span><span class="p">,</span>
    <span class="n">logistic</span><span class="p">,</span> <span class="n">genextreme</span><span class="p">,</span> <span class="n">laplace</span><span class="p">,</span> <span class="n">pareto</span><span class="p">,</span> <span class="n">loguniform</span><span class="p">,</span> <span class="n">randint</span><span class="p">,</span> <span class="n">uniform</span><span class="p">,</span>
    <span class="n">linregress</span><span class="p">,</span> <span class="n">t</span> <span class="k">as</span> <span class="n">tdist</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm.auto</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">RegressorMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.ensemble</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">RandomForestRegressor</span><span class="p">,</span> <span class="n">StackingRegressor</span><span class="p">,</span>
    <span class="n">GradientBoostingRegressor</span><span class="p">,</span> <span class="n">AdaBoostRegressor</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearRegression</span><span class="p">,</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neural_network</span><span class="w"> </span><span class="kn">import</span> <span class="n">MLPRegressor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.svm</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVR</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.gaussian_process</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaussianProcessRegressor</span><span class="p">,</span> <span class="n">GaussianProcessClassifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.gaussian_process.kernels</span><span class="w"> </span><span class="kn">import</span> <span class="n">RBF</span><span class="p">,</span> <span class="n">Matern</span><span class="p">,</span> <span class="n">ConstantKernel</span> <span class="k">as</span> <span class="n">C</span><span class="p">,</span> <span class="n">WhiteKernel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">RandomizedSearchCV</span><span class="p">,</span> <span class="n">KFold</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span><span class="p">,</span> <span class="n">log_loss</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvergenceWarning</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">xgboost</span><span class="w"> </span><span class="kn">import</span> <span class="n">XGBRegressor</span>

<span class="c1"># Optional / third-party imports</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># fallback if tqdm.auto not available</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tqdm</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iterable</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="n">JOBLIB_AVAILABLE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">JOBLIB_AVAILABLE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">optuna</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">optuna.samplers</span><span class="w"> </span><span class="kn">import</span> <span class="n">TPESampler</span>
    <span class="n">OPTUNA_AVAILABLE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">OPTUNA_AVAILABLE</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Optuna not installed. Bayesian optimization will not be available.&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hpelm</span><span class="w"> </span><span class="kn">import</span> <span class="n">HPELM</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">HPELM</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># or raise/warn as needed</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">RandomizedSearchCV</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">RegressorMixin</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optuna</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">optuna.samplers</span><span class="w"> </span><span class="kn">import</span> <span class="n">TPESampler</span><span class="p">,</span> <span class="n">RandomSampler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hpelm</span><span class="w"> </span><span class="kn">import</span> <span class="n">HPELM</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">dask.distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>

<span class="c1"># Project-specific imports</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wass2s.utils</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wass2s.was_verification</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xcast</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xc</span>

<span class="c1"># Suppress specific warnings for cleaner output</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">ConvergenceWarning</span><span class="p">)</span>

<div class="viewcode-block" id="process_datasets_for_mme">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.process_datasets_for_mme">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">process_datasets_for_mme</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fcsted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">gcm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">agroparam</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Prob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hydro</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">ELM_ELR</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dir_to_save_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">best_models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">model</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">month_of_initialization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">lead_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">score_metric</span><span class="o">=</span><span class="s1">&#39;GROC&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s2">&quot;PRCP&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process hindcast and forecast datasets for a multi-model ensemble.</span>

<span class="sd">    This function loads, interpolates, and concatenates hindcast and forecast datasets from various sources </span>
<span class="sd">    (GCMs, agroparameters, or others) to prepare them for a multi-model ensemble. It supports different score </span>
<span class="sd">    metrics and configurations for probabilistic or deterministic outputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rainfall : xarray.DataArray</span>
<span class="sd">        Observed rainfall data used for interpolation and masking.</span>
<span class="sd">    hdcsted : dict, optional</span>
<span class="sd">        Dictionary of hindcast datasets for different models.</span>
<span class="sd">    fcsted : dict, optional</span>
<span class="sd">        Dictionary of forecast datasets for different models.</span>
<span class="sd">    gcm : bool, optional</span>
<span class="sd">        If True, process data as GCM data. Default is True.</span>
<span class="sd">    agroparam : bool, optional</span>
<span class="sd">        If True, process data as agroparameter data. Default is False.</span>
<span class="sd">    Prob : bool, optional</span>
<span class="sd">        If True, process data as probabilistic forecasts. Default is False.</span>
<span class="sd">    ELM_ELR : bool, optional</span>
<span class="sd">        If True, use ELM_ELR configuration for dimension renaming. Default is False.</span>
<span class="sd">    dir_to_save_model : str, optional</span>
<span class="sd">        Directory path to load model data.</span>
<span class="sd">    best_models : list, optional</span>
<span class="sd">        List of model names to include in the ensemble.</span>
<span class="sd">    scores : dict, optional</span>
<span class="sd">        Dictionary containing model scores, with the key specified by `score_metric`.</span>
<span class="sd">    year_start : int, optional</span>
<span class="sd">        Starting year for the data range.</span>
<span class="sd">    year_end : int, optional</span>
<span class="sd">        Ending year for the data range.</span>
<span class="sd">    model : bool, optional</span>
<span class="sd">        If True, treat data as model-based. Default is True.</span>
<span class="sd">    month_of_initialization : int, optional</span>
<span class="sd">        Month when the forecast is initialized.</span>
<span class="sd">    lead_time : int, optional</span>
<span class="sd">        Forecast lead time in months.</span>
<span class="sd">    year_forecast : int, optional</span>
<span class="sd">        Year for which the forecast is generated.</span>
<span class="sd">    score_metric : str, optional</span>
<span class="sd">        Metric used to organize scores (e.g., &#39;Pearson&#39;, &#39;MAE&#39;, &#39;GROC&#39;). Default is &#39;GROC&#39;.</span>
<span class="sd">    var: str, optional</span>
<span class="sd">        variables used ( e.g., &#39;PRCP&#39;)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_model_hdcst : xarray.DataArray</span>
<span class="sd">        Concatenated hindcast data across models.</span>
<span class="sd">    all_model_fcst : xarray.DataArray</span>
<span class="sd">        Concatenated forecast data across models.</span>
<span class="sd">    obs : xarray.DataArray</span>
<span class="sd">        Observed rainfall data expanded with a model dimension and masked.</span>
<span class="sd">    scores_organized : dict</span>
<span class="sd">        Dictionary of organized scores for selected models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">gcm</span><span class="p">:</span>
        <span class="c1"># Standardize model keys for matching.</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="c1"># Use the provided score_metric to extract the appropriate scores.</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">:</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span>
                <span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> 
                <span class="n">year_forecast</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">load_gridded_predictor</span><span class="p">(</span>
                <span class="n">dir_to_save_model</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">year_start</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">month_of_initialization</span><span class="o">=</span><span class="n">month_of_initialization</span><span class="p">,</span> <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span> 
                <span class="n">year_forecast</span><span class="o">=</span><span class="n">year_forecast</span>
            <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">agroparam</span><span class="p">:</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">best_models</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
                        <span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">:</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>        
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">hdcst</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">hdcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>
            <span class="n">fic</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fcsted</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="ow">in</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fic</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                            <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                            <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                        <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfill</span><span class="p">(</span><span class="n">fcst</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">hydro</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdcsted</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">target_prefixes</span> <span class="o">=</span> <span class="n">best_models</span>
            <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">scores_organized</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
            <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">scores_organized</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">hdcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">hdcsted</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                <span class="n">hdcst</span> <span class="o">=</span> <span class="n">hdcst</span><span class="p">[</span><span class="s1">&#39;Observation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcst</span>
    
                <span class="n">fcst</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fcsted</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;Observation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># target_prefixes = [m.replace(m.split(&#39;.&#39;)[1], &#39;&#39;) for m in best_models]</span>
        <span class="n">target_prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">best_models</span><span class="p">]</span>
        <span class="n">scores_organized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">da</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">[</span><span class="n">score_metric</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcsted</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">target_prefixes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">scores_organized</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">all_model_hdcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">all_model_fcst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcsted</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> 
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
    
    <span class="c1"># Concatenate datasets along the &#39;M&#39; dimension.</span>
    <span class="n">hindcast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> 
    <span class="n">forecast_det_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_fcst</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">predictor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>    
    
    <span class="c1"># Create a mask based on the rainfall data.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">ELM_ELR</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="n">all_model_fcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">Prob</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="n">all_model_fcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hindcast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_hdcst</span> <span class="o">=</span> <span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">forecast_det_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
              <span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">predictor_names</span><span class="p">})</span>
              <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">all_model_fcst</span> <span class="o">=</span> <span class="n">all_model_fcst</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">all_model_hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">all_model_hdcst</span><span class="p">,</span> <span class="n">all_model_fcst</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">scores_organized</span></div>



<div class="viewcode-block" id="myfill">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.myfill">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">myfill</span><span class="p">(</span><span class="n">all_model_fcst</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill missing values in forecast data using random samples from observations.</span>

<span class="sd">    This function fills NaN values in the forecast data by randomly sampling values from the observed </span>
<span class="sd">    rainfall data along the time dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_model_fcst : xarray.DataArray</span>
<span class="sd">        Forecast data with dimensions (T, M, Y, X) containing possible NaN values.</span>
<span class="sd">    obs : xarray.DataArray</span>
<span class="sd">        Observed rainfall data with dimensions (T, Y, X) used for filling NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da_filled_random : xarray.DataArray</span>
<span class="sd">        Forecast data with NaN values filled using random samples from observations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Suppose all_model_hdcst has dimensions: T, M, Y, X</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">all_model_fcst</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
    
    <span class="c1"># Create a DataArray of random T indices with shape (T, M, Y, X)</span>
    <span class="c1"># so that each element gets its own random index along T</span>
    <span class="n">random_t_indices_full</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)),</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    
    <span class="c1"># Use vectorized indexing: for each (T, M, Y, X) location,</span>
    <span class="c1"># this picks the value at a random T index for that M, Y, X location.</span>
    <span class="n">random_slices_full</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">random_t_indices_full</span><span class="p">)</span>
    
    <span class="c1"># Fill missing values with these randomly selected values</span>
    <span class="n">da_filled_random</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">random_slices_full</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">da_filled_random</span>   </div>





<div class="viewcode-block" id="WAS_mme_Weighted">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_Weighted</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weighted Multi-Model Ensemble (MME) for climate forecasting.</span>

<span class="sd">    This class implements a weighted ensemble approach for combining multiple climate models, </span>
<span class="sd">    supporting both equal weighting and score-based weighting. It also provides methods for </span>
<span class="sd">    computing tercile probabilities using various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    equal_weighted : bool, optional</span>
<span class="sd">        If True, use equal weights for all models; otherwise, use score-based weights. Default is False.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Statistical distribution for probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;normal&#39;, &#39;lognormal&#39;, </span>
<span class="sd">        &#39;weibull_min&#39;, &#39;nonparam&#39;). Default is &#39;gamma&#39;.</span>
<span class="sd">    metric : str, optional</span>
<span class="sd">        Performance metric for weighting (&#39;MAE&#39;, &#39;Pearson&#39;, &#39;GROC&#39;). Default is &#39;GROC&#39;.</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        Threshold for score transformation. Default is 0.5.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_Weighted.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equal_weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;GROC&quot;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            equal_weighted (bool): If True, use a simple unweighted mean.</span>
<span class="sd">            dist_method (str): Distribution method (kept for compatibility).</span>
<span class="sd">            metric (str): Score metric name (e.g., &#39;MAE&#39;, &#39;Pearson&#39;, &#39;GROC&#39;).</span>
<span class="sd">            threshold (numeric): Threshold value for masking the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equal_weighted</span> <span class="o">=</span> <span class="n">equal_weighted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.transform_score">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.transform_score">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform score array based on the chosen metric and threshold.</span>

<span class="sd">        For &#39;MAE&#39;, scores below the threshold are set to 1, others to 0. For &#39;Pearson&#39; or &#39;GROC&#39;, </span>
<span class="sd">        scores above the threshold are set to 1, others to 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        score_array : xarray.DataArray</span>
<span class="sd">            Score array to transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transformed_score : xarray.DataArray</span>
<span class="sd">            Transformed score array with binary weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mae&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pearson&#39;</span><span class="p">,</span> <span class="s1">&#39;groc&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
               <span class="c1"># xr.where(</span>
               <span class="c1">#     score_array &lt;= 0.6,</span>
               <span class="c1">#     0.6,</span>
               <span class="c1">#     xr.where(score_array &lt;= 0.8, 0.8, 1)</span>
               <span class="c1"># )</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default: no masking applied.</span>
            <span class="k">return</span> <span class="n">score_array</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcst</span><span class="p">,</span> <span class="n">fcst</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute weighted hindcast and forecast using model scores.</span>

<span class="sd">        This method calculates weighted averages of hindcast and forecast data based on model scores. </span>
<span class="sd">        If `complete` is True, missing values are filled with unweighted averages.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rainfall : xarray.DataArray</span>
<span class="sd">            Observed rainfall data with dimensions (T, Y, X, M).</span>
<span class="sd">        hdcst : xarray.DataArray</span>
<span class="sd">            Hindcast data with dimensions (T, M, Y, X).</span>
<span class="sd">        fcst : xarray.DataArray</span>
<span class="sd">            Forecast data with dimensions (T, M, Y, X).</span>
<span class="sd">        scores : dict</span>
<span class="sd">            Dictionary mapping model names to score arrays.</span>
<span class="sd">        complete : bool, optional</span>
<span class="sd">            If True, fill missing values with unweighted averages. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Weighted hindcast data with dimensions (T, Y, X).</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Weighted forecast data with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Adjust time coordinates as needed.</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        
        <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="n">hdcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create a mask based on non-NaN values in the rainfall data.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>\
                 <span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_weighted</span><span class="p">:</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">selected_models</span> <span class="o">=</span> <span class="n">model_names</span>
            
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">score_sum</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">selected_models</span><span class="p">:</span>
                <span class="c1"># Interpolate and mask the score array for the current model.</span>
                <span class="n">score_array</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="n">weight_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_score</span><span class="p">(</span><span class="n">score_array</span><span class="p">)</span>
    
                <span class="c1"># Interpolate hindcast and forecast data to the rainfall grid.</span>
                <span class="n">hindcast_data</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
    
                <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
                <span class="p">)</span>
    
                <span class="c1"># Multiply by the weight.</span>
                <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_data</span> <span class="o">*</span> <span class="n">weight_array</span>
                <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_data</span> <span class="o">*</span> <span class="n">weight_array</span>
    
                <span class="c1"># Also keep an unweighted version for optional complete blending.</span>
                <span class="k">if</span> <span class="n">hindcast_det</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_weighted</span>
                    <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_weighted</span>
                    <span class="n">score_sum</span> <span class="o">=</span> <span class="n">weight_array</span>
                    <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="n">hindcast_data</span>
                    <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="n">forecast_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hindcast_det</span> <span class="o">+=</span> <span class="n">hindcast_weighted</span>
                    <span class="n">forecast_det</span> <span class="o">+=</span> <span class="n">forecast_weighted</span>
                    <span class="n">score_sum</span> <span class="o">+=</span> <span class="n">weight_array</span>
                    <span class="n">hindcast_det_unweighted</span> <span class="o">+=</span> <span class="n">hindcast_data</span>
                    <span class="n">forecast_det_unweighted</span> <span class="o">+=</span> <span class="n">forecast_data</span>
                    
            <span class="c1"># Compute the weighted averages.</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span> <span class="o">/</span> <span class="n">score_sum</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span> <span class="o">/</span> <span class="n">score_sum</span>

            <span class="c1"># If complete==True, use unweighted averages to fill in missing grid cells.</span>
            <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
                <span class="n">num_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_models</span><span class="p">)</span>
                <span class="n">hindcast_det_unweighted</span> <span class="o">=</span> <span class="n">hindcast_det_unweighted</span> <span class="o">/</span> <span class="n">num_models</span>
                <span class="n">forecast_det_unweighted</span> <span class="o">=</span> <span class="n">forecast_det_unweighted</span> <span class="o">/</span> <span class="n">num_models</span>
                <span class="n">mask_hd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">mask_fc</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_det</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hindcast_det_unweighted</span> <span class="o">*</span> <span class="n">mask_hd</span>
                <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">forecast_det_unweighted</span> <span class="o">*</span> <span class="n">mask_fc</span>
                
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
                         
        <span class="k">return</span> <span class="n">hindcast_det</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">forecast_det</span> <span class="o">*</span> <span class="n">mask</span></div>



    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_Weighted._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_Weighted.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_Weighted.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_Weighted.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_Weighted.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Weighted.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">forecast_det</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        
        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">forecast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">forecast_det</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_ProbWeighted">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_ProbWeighted">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_ProbWeighted</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Probability-Weighted Multi-Model Ensemble for seasonal rainfall forecasting.</span>

<span class="sd">    Implements a threshold-based weighting scheme for combining multiple climate</span>
<span class="sd">    model outputs (hindcasts and forecasts). Model weights are derived from performance.</span>
<span class="sd">    It&#39;s currently for only GROC scores. With a stepwise transformation:</span>
<span class="sd">    -  threshold  weight = 0 (excluded)</span>
<span class="sd">    - threshold &lt; score  0.6  weight = 0.6</span>
<span class="sd">    - 0.6 &lt; score  0.8  weight = 0.8</span>
<span class="sd">    - &gt; 0.8  weight = 1.0</span>

<span class="sd">    This approach aims to emphasize better-performing models while maintaining some</span>
<span class="sd">    contribution from moderately skilled ones, and completely excluding very poor models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - All input data (hindcast, forecast, scores) are interpolated to the rainfall grid</span>
<span class="sd">      using nearest-neighbor interpolation with extrapolation.</span>
<span class="sd">    - A spatial mask is derived from the first time step of rainfall observations.</span>
<span class="sd">    - Supports an optional &#39;complete&#39; mode that fills missing values with simple</span>
<span class="sd">      unweighted ensemble mean.</span>
<span class="sd">    - Designed primarily for seasonal climate forecasting applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_ProbWeighted.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_ProbWeighted.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize any required attributes here</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="WAS_ProbWeighted.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_ProbWeighted.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rainfall</span><span class="p">,</span> <span class="n">hdcst</span><span class="p">,</span> <span class="n">fcst</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute probability-weighted multi-model ensemble mean for hindcast and forecast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rainfall : xarray.DataArray</span>
<span class="sd">            Observed rainfall used as reference grid and for masking.</span>
<span class="sd">            Expected dimensions: (T, Y, X, M) or (T, Y, X).</span>
<span class="sd">            The M dimension (if present) is ignored.</span>
<span class="sd">        hdcst : xarray.DataArray</span>
<span class="sd">            Multi-model hindcast dataset.</span>
<span class="sd">            Expected dimensions: (T, M, Y, X)</span>
<span class="sd">        fcst : xarray.DataArray</span>
<span class="sd">            Multi-model forecast dataset (single lead time).</span>
<span class="sd">            Expected dimensions: (T, M, Y, X)</span>
<span class="sd">        scores : dict</span>
<span class="sd">            Dictionary mapping model names (str) to performance score arrays.</span>
<span class="sd">            Each score array should be an xarray.DataArray with spatial coordinates (Y, X).</span>
<span class="sd">        threshold : float, default=0.5 for GROC</span>
<span class="sd">            Minimum score value below which a model is completely excluded (weight = 0).</span>
<span class="sd">        complete : bool, default=False</span>
<span class="sd">            If True, areas where weighted mean is NaN are filled with the simple</span>
<span class="sd">            unweighted ensemble mean.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_weighted : xarray.DataArray</span>
<span class="sd">            Weighted hindcast ensemble mean.</span>
<span class="sd">            Dimensions: (T, Y, X)</span>
<span class="sd">        forecast_weighted : xarray.DataArray</span>
<span class="sd">            Weighted forecast ensemble mean.</span>
<span class="sd">            Dimensions: (T, Y, X)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Time coordinate of forecast is adjusted to match the expected seasonal month</span>
<span class="sd">          based on the first timestep of rainfall observations.</span>
<span class="sd">        - All interpolations use &#39;nearest&#39; method with extrapolation for boundary points.</span>
<span class="sd">        - Final output is masked using the spatial coverage of observed rainfall.</span>
<span class="sd">        - Models with NaN scores or failed interpolation will contribute zero weight.</span>
<span class="sd">        - The stepwise weighting is currently hardcoded (0.6 / 0.8 / 1.0 breakpoints). </span>
<span class="sd">        - It&#39;s only for GROC currently.</span>
<span class="sd"> </span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        - Make sure that model names in `hdcst.M`, `fcst.M` and `scores.keys()` match exactly.</span>
<span class="sd">        - Performance may degrade if score grids have very different resolution/spatial extent</span>
<span class="sd">          from the rainfall target grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="c1"># --- Adjust time coordinates ---</span>
        <span class="c1"># Extract the year from the forecast&#39;s T coordinate (assuming epoch conversion)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the initial time value from rainfall</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month (1-12)</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        
        <span class="c1"># Update forecast and hindcast time coordinates</span>
        <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="n">hdcst</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create a spatial mask from rainfall (using first time and model)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rainfall</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># --- Initialize accumulators for weighted and unweighted sums ---</span>
        <span class="n">weighted_hindcast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">weighted_forecast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">score_sum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">hindcast_sum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">forecast_sum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdcst</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># --- Loop over each model ---</span>
        <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">:</span>
            <span class="c1"># Interpolate the score array to the rainfall grid</span>
            <span class="n">score_array</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="c1"># Apply weighting rules: below threshold set to 0; between threshold and 0.6 -&gt; 0.6; </span>
            <span class="c1"># between 0.6 and 0.8 -&gt; 0.8; above 0.8 -&gt; 1.</span>

            <span class="n">score_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
               <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">score_array</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">,</span>
                    <span class="mf">0.6</span><span class="p">,</span>
                   <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">score_array</span> <span class="o">&lt;=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># score_array = xr.where(</span>
            <span class="c1">#     score_array &lt;= threshold,</span>
            <span class="c1">#     0,1</span>
            <span class="c1"># )</span>
            
            <span class="c1"># Interpolate hindcast and forecast data for the model to the rainfall grid</span>
            <span class="n">hindcast_data</span> <span class="o">=</span> <span class="n">hdcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">model_name</span><span class="p">)</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rainfall</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Weight the datasets by the score_array</span>
            <span class="n">weighted_hindcast</span> <span class="o">=</span> <span class="n">hindcast_data</span> <span class="o">*</span> <span class="n">score_array</span>
            <span class="n">weighted_forecast</span> <span class="o">=</span> <span class="n">forecast_data</span> <span class="o">*</span> <span class="n">score_array</span>

            <span class="c1"># Accumulate weighted and unweighted sums</span>
            <span class="k">if</span> <span class="n">weighted_hindcast_sum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weighted_hindcast_sum</span> <span class="o">=</span> <span class="n">weighted_hindcast</span>
                <span class="n">weighted_forecast_sum</span> <span class="o">=</span> <span class="n">weighted_forecast</span>
                <span class="n">score_sum</span> <span class="o">=</span> <span class="n">score_array</span>
                <span class="n">hindcast_sum</span> <span class="o">=</span> <span class="n">hindcast_data</span>
                <span class="n">forecast_sum</span> <span class="o">=</span> <span class="n">forecast_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weighted_hindcast_sum</span> <span class="o">+=</span> <span class="n">weighted_hindcast</span>
                <span class="n">weighted_forecast_sum</span> <span class="o">+=</span> <span class="n">weighted_forecast</span>
                <span class="n">score_sum</span> <span class="o">+=</span> <span class="n">score_array</span>
                <span class="n">hindcast_sum</span> <span class="o">+=</span> <span class="n">hindcast_data</span>
                <span class="n">forecast_sum</span> <span class="o">+=</span> <span class="n">forecast_data</span>

        <span class="c1"># --- Compute weighted ensemble (weighted average) ---</span>
        <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">weighted_hindcast_sum</span> <span class="o">/</span> <span class="n">score_sum</span>
        <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">weighted_forecast_sum</span> <span class="o">/</span> <span class="n">score_sum</span>
        
        <span class="c1"># --- Optionally complete missing values with unweighted average ---</span>
        <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
            <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span>
            <span class="n">hindcast_unweighted</span> <span class="o">=</span> <span class="n">hindcast_sum</span> <span class="o">/</span> <span class="n">n_models</span>
            <span class="n">forecast_unweighted</span> <span class="o">=</span> <span class="n">forecast_sum</span> <span class="o">/</span> <span class="n">n_models</span>
            
            <span class="c1"># Identify missing areas in the weighted estimates</span>
            <span class="n">mask_hd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hindcast_weighted</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">mask_fc</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_weighted</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hindcast_unweighted</span> <span class="o">*</span> <span class="n">mask_hd</span>
            <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">forecast_unweighted</span> <span class="o">*</span> <span class="n">mask_fc</span>

        <span class="c1"># --- Drop the &#39;M&#39; dimension if present ---</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">hindcast_weighted</span> <span class="o">=</span> <span class="n">hindcast_weighted</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">forecast_weighted</span> <span class="o">=</span> <span class="n">forecast_weighted</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">hindcast_weighted</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">forecast_weighted</span> <span class="o">*</span> <span class="n">mask</span></div>
</div>







<div class="viewcode-block" id="WAS_Min2009_ProbWeighted">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_Min2009_ProbWeighted</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of Min et al. (2009) Probability-Weighted Multi-Model Ensemble.</span>
<span class="sd">    </span>
<span class="sd">    Based on: &quot;Probabilistic Multimodel Ensemble (PMME) forecasting at APCC&quot;</span>
<span class="sd">    Journal: Weather and Forecasting, 2009</span>
<span class="sd">    </span>
<span class="sd">    Key methodology:</span>
<span class="sd">    1. Individual model probabilistic forecasts are computed using Gaussian approximation</span>
<span class="sd">    2. Model weights are proportional to sqrt(ensemble_size) [Eq. 6 in paper]</span>
<span class="sd">    3. Tercile probabilities (BN, NN, AN) are combined using total probability formula</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    - For temperature: Gaussian assumption is reasonable</span>
<span class="sd">    - For precipitation: Consider using log-normal, Gamma distribution, or empirical methods</span>
<span class="sd">    - The  test uses configurable n (ensemble size) - avoid overly conservative n=1</span>
<span class="sd">    - Cross-validation is recommended for hindcast statistics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">cv_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples_for_chisq</span><span class="o">=</span><span class="s1">&#39;total_ensemble&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize PMME processor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distribution : str</span>
<span class="sd">            Distribution assumption: &#39;gaussian&#39;, &#39;gamma&#39;, &#39;lognormal&#39;, or &#39;empirical&#39;</span>
<span class="sd">        cv_method : str or None</span>
<span class="sd">            Cross-validation method: None, &#39;leave_one_out&#39;, or &#39;rolling_window&#39;</span>
<span class="sd">        n_samples_for_chisq : str or int</span>
<span class="sd">            How to compute n for  test: </span>
<span class="sd">            &#39;total_ensemble&#39; (default), &#39;effective_sample_size&#39;, or integer value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_method</span> <span class="o">=</span> <span class="n">cv_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_for_chisq</span> <span class="o">=</span> <span class="n">n_samples_for_chisq</span></div>

        
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted._compute_cross_validated_stats">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted._compute_cross_validated_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_cross_validated_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hindcasts</span><span class="p">,</span> <span class="n">climatology</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cross-validated mean and standard deviation from hindcasts.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hindcasts : xarray.DataArray</span>
<span class="sd">            Hindcast ensemble data with dimensions (T, M, Y, X)</span>
<span class="sd">        climatology : xarray.DataArray</span>
<span class="sd">            Climatological data with dimensions (Y, X)</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu_cv : xarray.DataArray</span>
<span class="sd">            Cross-validated mean with dimensions (T, Y, X)</span>
<span class="sd">        sigma_cv : xarray.DataArray</span>
<span class="sd">            Cross-validated standard deviation with dimensions (T, Y, X)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_times</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use full hindcast period (not recommended for operational use)</span>
            <span class="n">mu_cv</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
            <span class="n">sigma_cv</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
            <span class="c1"># Expand to match time dimension</span>
            <span class="n">mu_cv</span> <span class="o">=</span> <span class="n">mu_cv</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
            <span class="n">sigma_cv</span> <span class="o">=</span> <span class="n">sigma_cv</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_method</span> <span class="o">==</span> <span class="s1">&#39;leave_one_out&#39;</span><span class="p">:</span>
            <span class="c1"># Leave-one-out cross-validation</span>
            <span class="n">mu_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sigma_list</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_times</span><span class="p">):</span>
                <span class="c1"># Leave out year i</span>
                <span class="n">hindcast_train</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_times</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">mu_i</span> <span class="o">=</span> <span class="n">hindcast_train</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
                <span class="n">sigma_i</span> <span class="o">=</span> <span class="n">hindcast_train</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
                <span class="n">mu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu_i</span><span class="p">)</span>
                <span class="n">sigma_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigma_i</span><span class="p">)</span>
            
            <span class="n">mu_cv</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">mu_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="n">sigma_cv</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">sigma_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_method</span> <span class="o">==</span> <span class="s1">&#39;rolling_window&#39;</span><span class="p">:</span>
            <span class="c1"># Rolling window validation (e.g., 15-year window)</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">mu_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sigma_list</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_times</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_times</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">hindcast_train</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                <span class="c1"># Exclude the current year if possible</span>
                <span class="n">hindcast_train</span> <span class="o">=</span> <span class="n">hindcast_train</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hindcast_train</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span> 
                                                          <span class="k">if</span> <span class="n">start</span> <span class="o">+</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
                
                <span class="n">mu_i</span> <span class="o">=</span> <span class="n">hindcast_train</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
                <span class="n">sigma_i</span> <span class="o">=</span> <span class="n">hindcast_train</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">])</span>
                <span class="n">mu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu_i</span><span class="p">)</span>
                <span class="n">sigma_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigma_i</span><span class="p">)</span>
            
            <span class="n">mu_cv</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">mu_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="n">sigma_cv</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">sigma_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">hindcasts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">mu_cv</span><span class="p">,</span> <span class="n">sigma_cv</span></div>

    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted._compute_tercile_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted._compute_tercile_probabilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_tercile_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">hindcasts</span><span class="p">,</span> <span class="n">climatology</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for individual models.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts : xarray.DataArray</span>
<span class="sd">            Forecast ensemble data with dimensions (T, M, Y, X)</span>
<span class="sd">        hindcasts : xarray.DataArray</span>
<span class="sd">            Hindcast ensemble data with dimensions (T, M, Y, X)</span>
<span class="sd">        climatology : xarray.DataArray</span>
<span class="sd">            Climatological data with dimensions (Y, X)</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        probs_bn : xarray.DataArray</span>
<span class="sd">            Probability of below-normal category</span>
<span class="sd">        probs_nn : xarray.DataArray</span>
<span class="sd">            Probability of near-normal category</span>
<span class="sd">        probs_an : xarray.DataArray</span>
<span class="sd">            Probability of above-normal category</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute cross-validated statistics</span>
        <span class="n">mu_cv</span><span class="p">,</span> <span class="n">sigma_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cross_validated_stats</span><span class="p">(</span><span class="n">hindcasts</span><span class="p">,</span> <span class="n">climatology</span><span class="p">)</span>
        
        <span class="c1"># Compute forecast ensemble mean</span>
        <span class="n">forecast_mean</span> <span class="o">=</span> <span class="n">forecasts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;ensemble&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="c1"># Gaussian approximation (suitable for temperature)</span>
            <span class="c1"># Tercile boundaries at approximately 0.43 (for Gaussian)</span>
            <span class="c1"># Actually, for terciles, boundaries are at (1/3)  -0.43 and (2/3)  0.43</span>
            <span class="c1"># The paper uses 1.43 which seems incorrect - this would be for much wider intervals</span>
            <span class="c1"># Let&#39;s use the correct tercile boundaries:</span>
            <span class="n">lower_boundary</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.4307</span>  <span class="c1"># (1/3)</span>
            <span class="n">upper_boundary</span> <span class="o">=</span> <span class="mf">0.4307</span>   <span class="c1"># (2/3)</span>
            
            <span class="c1"># Standardized anomalies</span>
            <span class="n">z_lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu_cv</span> <span class="o">+</span> <span class="n">lower_boundary</span> <span class="o">*</span> <span class="n">sigma_cv</span> <span class="o">-</span> <span class="n">forecast_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma_cv</span>
            <span class="n">z_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu_cv</span> <span class="o">+</span> <span class="n">upper_boundary</span> <span class="o">*</span> <span class="n">sigma_cv</span> <span class="o">-</span> <span class="n">forecast_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma_cv</span>
            
            <span class="c1"># Gaussian CDF probabilities</span>
            <span class="n">probs_bn</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z_lower</span><span class="p">)</span>
            <span class="n">probs_an</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z_upper</span><span class="p">)</span>
            <span class="n">probs_nn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">probs_bn</span> <span class="o">-</span> <span class="n">probs_an</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="c1"># Log-normal distribution (suitable for precipitation)</span>
            <span class="c1"># Transform to log space</span>
            <span class="n">log_hindcasts</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hindcasts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hindcasts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
            <span class="n">log_mu_cv</span><span class="p">,</span> <span class="n">log_sigma_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cross_validated_stats</span><span class="p">(</span><span class="n">log_hindcasts</span><span class="p">,</span> <span class="n">climatology</span><span class="p">)</span>
            <span class="n">log_forecast</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">forecasts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">forecasts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
            <span class="n">log_forecast_mean</span> <span class="o">=</span> <span class="n">log_forecast</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;ensemble&#39;</span><span class="p">)</span>
            
            <span class="c1"># Compute tercile boundaries in log space</span>
            <span class="n">lower_boundary</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.4307</span>
            <span class="n">upper_boundary</span> <span class="o">=</span> <span class="mf">0.4307</span>
            
            <span class="n">z_lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_mu_cv</span> <span class="o">+</span> <span class="n">lower_boundary</span> <span class="o">*</span> <span class="n">log_sigma_cv</span> <span class="o">-</span> <span class="n">log_forecast_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">log_sigma_cv</span>
            <span class="n">z_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_mu_cv</span> <span class="o">+</span> <span class="n">upper_boundary</span> <span class="o">*</span> <span class="n">log_sigma_cv</span> <span class="o">-</span> <span class="n">log_forecast_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">log_sigma_cv</span>
            
            <span class="n">probs_bn</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z_lower</span><span class="p">)</span>
            <span class="n">probs_an</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z_upper</span><span class="p">)</span>
            <span class="n">probs_nn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">probs_bn</span> <span class="o">-</span> <span class="n">probs_an</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;empirical&#39;</span><span class="p">:</span>
            <span class="c1"># Empirical quantile mapping</span>
            <span class="c1"># This is a simplified version - consider more sophisticated methods</span>
            <span class="n">forecast_flat</span> <span class="o">=</span> <span class="n">forecasts</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
            <span class="n">hindcast_flat</span> <span class="o">=</span> <span class="n">hindcasts</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
            
            <span class="c1"># Compute empirical CDF for each grid point</span>
            <span class="n">probs_bn</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">forecast_mean</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">probs_nn</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">forecast_mean</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">probs_an</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">forecast_mean</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># This is computationally intensive - consider optimization</span>
            <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">forecast_mean</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lon</span> <span class="ow">in</span> <span class="n">forecast_mean</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                    <span class="n">hindcast_vals</span> <span class="o">=</span> <span class="n">hindcast_flat</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">forecast_val</span> <span class="o">=</span> <span class="n">forecast_mean</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                    
                    <span class="c1"># Compute empirical terciles from hindcast</span>
                    <span class="n">lower_tercile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">hindcast_vals</span><span class="p">,</span> <span class="mi">100</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">upper_tercile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">hindcast_vals</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
                    
                    <span class="c1"># Empirical probabilities</span>
                    <span class="n">probs_bn</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forecast_val</span> <span class="o">&lt;</span> <span class="n">lower_tercile</span><span class="p">)</span>
                    <span class="n">probs_an</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forecast_val</span> <span class="o">&gt;</span> <span class="n">upper_tercile</span><span class="p">)</span>
                    <span class="n">probs_nn</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">probs_bn</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)]</span> <span class="o">-</span> <span class="n">probs_an</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">)]</span>
        
        <span class="c1"># Ensure probabilities are between 0 and 1</span>
        <span class="n">probs_bn</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_bn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_bn</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">probs_bn</span><span class="p">))</span>
        <span class="n">probs_an</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_an</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_an</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">probs_an</span><span class="p">))</span>
        <span class="n">probs_nn</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_nn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">probs_nn</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">probs_nn</span><span class="p">))</span>
        
        <span class="c1"># Renormalize to ensure sum to 1 (accounting for numerical errors)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">probs_bn</span> <span class="o">+</span> <span class="n">probs_nn</span> <span class="o">+</span> <span class="n">probs_an</span>
        <span class="n">probs_bn</span> <span class="o">=</span> <span class="n">probs_bn</span> <span class="o">/</span> <span class="n">total</span>
        <span class="n">probs_nn</span> <span class="o">=</span> <span class="n">probs_nn</span> <span class="o">/</span> <span class="n">total</span>
        <span class="n">probs_an</span> <span class="o">=</span> <span class="n">probs_an</span> <span class="o">/</span> <span class="n">total</span>
        
        <span class="k">return</span> <span class="n">probs_bn</span><span class="p">,</span> <span class="n">probs_nn</span><span class="p">,</span> <span class="n">probs_an</span></div>

    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted._compute_model_weights">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted._compute_model_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_model_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ensemble_sizes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute model weights according to Min et al. (2009) Eq. 6.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ensemble_sizes : dict</span>
<span class="sd">            Dictionary mapping model names to ensemble sizes</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        weights : dict</span>
<span class="sd">            Dictionary mapping model names to normalized weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Weight proportional to sqrt(ensemble_size)</span>
        <span class="n">sqrt_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="n">model</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">ensemble_sizes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sqrt_sizes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        
        <span class="c1"># Normalize so weights sum to 1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="n">model</span><span class="p">:</span> <span class="n">sqrt_sizes</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">/</span> <span class="n">total</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">ensemble_sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        
        <span class="k">return</span> <span class="n">weights</span></div>

    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted._compute_n_for_chisq">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted._compute_n_for_chisq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_n_for_chisq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ensemble_sizes</span><span class="p">,</span> <span class="n">model_names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute n for  test based on configuration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ensemble_sizes : dict</span>
<span class="sd">            Dictionary mapping model names to ensemble sizes</span>
<span class="sd">        model_names : list</span>
<span class="sd">            List of model names</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : float</span>
<span class="sd">            Value to use for n in  test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples_for_chisq</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples_for_chisq</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_for_chisq</span> <span class="o">==</span> <span class="s1">&#39;total_ensemble&#39;</span><span class="p">:</span>
            <span class="c1"># Sum of all ensemble members across models</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ensemble_sizes</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_for_chisq</span> <span class="o">==</span> <span class="s1">&#39;effective_sample_size&#39;</span><span class="p">:</span>
            <span class="c1"># Approximate effective sample size</span>
            <span class="n">total_ensemble</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ensemble_sizes</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">)</span>
            <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span>
            <span class="c1"># Simple approximation: account for correlation between models</span>
            <span class="k">return</span> <span class="n">total_ensemble</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default to total ensemble size</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ensemble_sizes</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted.compute_pmme_probabilities">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted.compute_pmme_probabilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pmme_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">hindcasts</span><span class="p">,</span> <span class="n">climatology</span><span class="p">,</span> <span class="n">ensemble_sizes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute PMME probabilities according to Min et al. (2009).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts : dict of xarray.DataArray</span>
<span class="sd">            Dictionary of forecast ensembles for each model</span>
<span class="sd">        hindcasts : dict of xarray.DataArray</span>
<span class="sd">            Dictionary of hindcast ensembles for each model</span>
<span class="sd">        climatology : xarray.DataArray</span>
<span class="sd">            Climatological data</span>
<span class="sd">        ensemble_sizes : dict</span>
<span class="sd">            Dictionary mapping model names to ensemble sizes</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pmme_probs : dict</span>
<span class="sd">            Dictionary with keys &#39;BN&#39;, &#39;NN&#39;, &#39;AN&#39; containing PMME probabilities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get model names</span>
        <span class="n">model_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">forecasts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="c1"># Compute individual model probabilities</span>
        <span class="n">model_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">:</span>
            <span class="n">probs_bn</span><span class="p">,</span> <span class="n">probs_nn</span><span class="p">,</span> <span class="n">probs_an</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tercile_probabilities</span><span class="p">(</span>
                <span class="n">forecasts</span><span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="n">hindcasts</span><span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="n">climatology</span>
            <span class="p">)</span>
            <span class="n">model_probs</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;BN&#39;</span><span class="p">:</span> <span class="n">probs_bn</span><span class="p">,</span>
                <span class="s1">&#39;NN&#39;</span><span class="p">:</span> <span class="n">probs_nn</span><span class="p">,</span>
                <span class="s1">&#39;AN&#39;</span><span class="p">:</span> <span class="n">probs_an</span>
            <span class="p">}</span>
        
        <span class="c1"># Compute model weights (Eq. 6)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_model_weights</span><span class="p">(</span><span class="n">ensemble_sizes</span><span class="p">)</span>
        
        <span class="c1"># Combine probabilities using total probability formula (Eq. 1)</span>
        <span class="n">pmme_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;BN&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">,</span> <span class="s1">&#39;AN&#39;</span><span class="p">]:</span>
            <span class="n">weighted_sum</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">model_probs</span><span class="o">.</span><span class="n">values</span><span class="p">()))[</span><span class="n">category</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_names</span><span class="p">:</span>
                <span class="n">weighted_prob</span> <span class="o">=</span> <span class="n">model_probs</span><span class="p">[</span><span class="n">model</span><span class="p">][</span><span class="n">category</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">model</span><span class="p">]</span>
                <span class="n">weighted_sum</span> <span class="o">=</span> <span class="n">weighted_sum</span> <span class="o">+</span> <span class="n">weighted_prob</span>
            
            <span class="n">pmme_probs</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum</span>
        
        <span class="k">return</span> <span class="n">pmme_probs</span></div>

    
<div class="viewcode-block" id="WAS_Min2009_ProbWeighted.compute_combined_map">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_Min2009_ProbWeighted.compute_combined_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_combined_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmme_probs</span><span class="p">,</span> <span class="n">ensemble_sizes</span><span class="p">,</span> <span class="n">model_names</span><span class="p">,</span> <span class="n">significance_level</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute combined map with significance testing ( test).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pmme_probs : dict</span>
<span class="sd">            PMME probabilities for BN, NN, AN categories</span>
<span class="sd">        ensemble_sizes : dict</span>
<span class="sd">            Dictionary mapping model names to ensemble sizes</span>
<span class="sd">        model_names : list</span>
<span class="sd">            List of model names</span>
<span class="sd">        significance_level : float</span>
<span class="sd">            Significance level for  test (default 0.05)</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_map : xarray.DataArray</span>
<span class="sd">            Combined map showing dominant category where significant</span>
<span class="sd">        chi_square : xarray.DataArray</span>
<span class="sd">             statistic values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find dominant category</span>
        <span class="n">probs_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;BN&#39;</span><span class="p">],</span> <span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;NN&#39;</span><span class="p">],</span> <span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;AN&#39;</span><span class="p">]],</span> 
                               <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        <span class="n">dominant_category</span> <span class="o">=</span> <span class="n">probs_array</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        
        <span class="c1"># Compute n for  test</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_n_for_chisq</span><span class="p">(</span><span class="n">ensemble_sizes</span><span class="p">,</span> <span class="n">model_names</span><span class="p">)</span>
        
        <span class="c1"># Compute  statistic (Eq. in section 5)</span>
        <span class="c1">#  = n *  (P(Ej) - 1/3) / (1/3)</span>
        <span class="n">expected_prob</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
        
        <span class="n">chi_square</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;BN&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">expected_prob</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected_prob</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;NN&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">expected_prob</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected_prob</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">pmme_probs</span><span class="p">[</span><span class="s1">&#39;AN&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">expected_prob</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected_prob</span>
        <span class="p">)</span>
        
        <span class="c1"># Critical value for  with 2 degrees of freedom</span>
        <span class="n">critical_value</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">significance_level</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Create combined map: show dominant category where significant</span>
        <span class="n">combined_map</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">chi_square</span> <span class="o">&gt;</span> <span class="n">critical_value</span><span class="p">,</span>
            <span class="n">dominant_category</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># 1 for BN, 2 for NN, 3 for AN</span>
            <span class="mi">0</span>  <span class="c1"># No significant deviation from climatology</span>
        <span class="p">)</span>
        
        <span class="c1"># Add attributes for interpretation</span>
        <span class="n">combined_map</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;PMME combined forecast map&#39;</span><span class="p">,</span>
            <span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="s1">&#39;0=no significant deviation, 1=BN, 2=NN, 3=AN&#39;</span><span class="p">,</span>
            <span class="s1">&#39;significance_level&#39;</span><span class="p">:</span> <span class="n">significance_level</span><span class="p">,</span>
            <span class="s1">&#39;chi2_critical_value&#39;</span><span class="p">:</span> <span class="n">critical_value</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">combined_map</span><span class="p">,</span> <span class="n">chi_square</span></div>
</div>



<span class="c1"># # Example usage function</span>
<span class="c1"># def example_usage():</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Example of how to use the PMME class with proper cross-validation.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # Initialize with cross-validation and appropriate settings</span>
<span class="c1">#     pmme = WAS_Min2009_ProbWeighted(</span>
<span class="c1">#         distribution=&#39;gaussian&#39;,  # Use &#39;gamma&#39; or &#39;lognormal&#39; for precipitation</span>
<span class="c1">#         cv_method=&#39;leave_one_out&#39;,  # Use cross-validation</span>
<span class="c1">#         n_samples_for_chisq=&#39;total_ensemble&#39;  # Use total ensemble size for  test</span>
<span class="c1">#     )</span>
    
<span class="c1">#     # Example data structure (adapt to your actual data)</span>
<span class="c1">#     forecasts = {</span>
<span class="c1">#         &#39;model1&#39;: xr.DataArray(np.random.randn(10, 5, 20, 40), </span>
<span class="c1">#                               dims=[&#39;time&#39;, &#39;ensemble&#39;, &#39;lat&#39;, &#39;lon&#39;]),</span>
<span class="c1">#         &#39;model2&#39;: xr.DataArray(np.random.randn(10, 8, 20, 40),</span>
<span class="c1">#                               dims=[&#39;time&#39;, &#39;ensemble&#39;, &#39;lat&#39;, &#39;lon&#39;])</span>
<span class="c1">#     }</span>
    
<span class="c1">#     hindcasts = {</span>
<span class="c1">#         &#39;model1&#39;: xr.DataArray(np.random.randn(20, 5, 20, 40),</span>
<span class="c1">#                               dims=[&#39;time&#39;, &#39;ensemble&#39;, &#39;lat&#39;, &#39;lon&#39;]),</span>
<span class="c1">#         &#39;model2&#39;: xr.DataArray(np.random.randn(20, 8, 20, 40),</span>
<span class="c1">#                               dims=[&#39;time&#39;, &#39;ensemble&#39;, &#39;lat&#39;, &#39;lon&#39;])</span>
<span class="c1">#     }</span>
    
<span class="c1">#     climatology = xr.DataArray(np.random.randn(20, 40),</span>
<span class="c1">#                               dims=[&#39;lat&#39;, &#39;lon&#39;])</span>
    
<span class="c1">#     ensemble_sizes = {&#39;model1&#39;: 5, &#39;model2&#39;: 8}</span>
<span class="c1">#     model_names = [&#39;model1&#39;, &#39;model2&#39;]</span>
    
<span class="c1">#     # Compute PMME probabilities</span>
<span class="c1">#     pmme_probs = pmme.compute_pmme_probabilities(</span>
<span class="c1">#         forecasts, hindcasts, climatology, ensemble_sizes</span>
<span class="c1">#     )</span>
    
<span class="c1">#     # Compute combined map with significance</span>
<span class="c1">#     combined_map, chi_square = pmme.compute_combined_map(</span>
<span class="c1">#         pmme_probs, ensemble_sizes, model_names, significance_level=0.05</span>
<span class="c1">#     )</span>
    
<span class="c1">#     return pmme_probs, combined_map, chi_square</span>

<span class="c1"># class WAS_Min2009_ProbWeighted_:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Implementation of Min et al. (2009) Probability-Weighted Multi-Model Ensemble.</span>
    
<span class="c1">#     Based on: &quot;Probabilistic Multimodel Ensemble (PMME) forecasting at APCC&quot;</span>
<span class="c1">#     Journal: Weather and Forecasting, 2009</span>
    
<span class="c1">#     Key methodology:</span>
<span class="c1">#     1. Individual model probabilistic forecasts are computed using Gaussian approximation</span>
<span class="c1">#     2. Model weights are proportional to sqrt(ensemble_size) [Eq. 6 in paper]</span>
<span class="c1">#     3. Tercile probabilities (BN, NN, AN) are combined using total probability formula</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     def __init__(self):</span>
<span class="c1">#         pass</span>
    
<span class="c1">#     def _compute_tercile_probabilities(self, forecasts, hindcasts, climatology):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute tercile probabilities for individual models using Gaussian approximation.</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         forecasts : xarray.DataArray</span>
<span class="c1">#             Forecast ensemble data with dimensions (T, M, Y, X)</span>
<span class="c1">#         hindcasts : xarray.DataArray</span>
<span class="c1">#             Hindcast ensemble data with dimensions (T, M, Y, X)</span>
<span class="c1">#         climatology : xarray.DataArray</span>
<span class="c1">#             Climatological data with dimensions (Y, X)</span>
            
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         probs_bn : xarray.DataArray</span>
<span class="c1">#             Probability of below-normal category</span>
<span class="c1">#         probs_nn : xarray.DataArray</span>
<span class="c1">#             Probability of near-normal category</span>
<span class="c1">#         probs_an : xarray.DataArray</span>
<span class="c1">#             Probability of above-normal category</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Compute mean and std from hindcasts (cross-validated)</span>
<span class="c1">#         mu = hindcasts.mean(dim=&#39;ensemble&#39;)  # Model ensemble mean</span>
<span class="c1">#         sigma = hindcasts.std(dim=&#39;ensemble&#39;)  # Model ensemble spread</span>
        
<span class="c1">#         # Compute tercile boundaries (Eq. in section 5)</span>
<span class="c1">#         # Lower tercile:  - 1.43, Upper tercile:  + 1.43</span>
<span class="c1">#         lower_tercile = mu - 1.43 * sigma</span>
<span class="c1">#         upper_tercile = mu + 1.43 * sigma</span>
        
<span class="c1">#         # Compute forecast ensemble mean</span>
<span class="c1">#         forecast_mean = forecasts.mean(dim=&#39;ensemble&#39;)</span>
        
<span class="c1">#         # For Gaussian approximation, compute probabilities using CDF</span>
<span class="c1">#         # Probability of below-normal: ((lower_tercile - forecast_mean)/sigma)</span>
<span class="c1">#         # Probability of above-normal: 1 - ((upper_tercile - forecast_mean)/sigma)</span>
<span class="c1">#         # Probability of near-normal: 1 - P(BN) - P(AN)</span>
        
<span class="c1">#         # Standardized anomalies</span>
<span class="c1">#         z_lower = (lower_tercile - forecast_mean) / sigma</span>
<span class="c1">#         z_upper = (upper_tercile - forecast_mean) / sigma</span>
        
<span class="c1">#         # Gaussian CDF probabilities</span>
<span class="c1">#         probs_bn = stats.norm.cdf(z_lower)</span>
<span class="c1">#         probs_an = 1 - stats.norm.cdf(z_upper)</span>
<span class="c1">#         probs_nn = 1 - probs_bn - probs_an</span>
        
<span class="c1">#         # Ensure probabilities are between 0 and 1</span>
<span class="c1">#         probs_bn = xr.where(probs_bn &lt; 0, 0, xr.where(probs_bn &gt; 1, 1, probs_bn))</span>
<span class="c1">#         probs_an = xr.where(probs_an &lt; 0, 0, xr.where(probs_an &gt; 1, 1, probs_an))</span>
<span class="c1">#         probs_nn = xr.where(probs_nn &lt; 0, 0, xr.where(probs_nn &gt; 1, 1, probs_nn))</span>
        
<span class="c1">#         return probs_bn, probs_nn, probs_an</span>
    
<span class="c1">#     def _compute_model_weights(self, ensemble_sizes):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute model weights according to Min et al. (2009) Eq. 6.</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         ensemble_sizes : dict</span>
<span class="c1">#             Dictionary mapping model names to ensemble sizes</span>
            
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         weights : dict</span>
<span class="c1">#             Dictionary mapping model names to normalized weights</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Weight proportional to sqrt(ensemble_size)</span>
<span class="c1">#         sqrt_sizes = {model: np.sqrt(size) for model, size in ensemble_sizes.items()}</span>
<span class="c1">#         total = sum(sqrt_sizes.values())</span>
        
<span class="c1">#         # Normalize so weights sum to 1</span>
<span class="c1">#         weights = {model: sqrt_sizes[model] / total for model in ensemble_sizes.keys()}</span>
        
<span class="c1">#         return weights</span>
    
<span class="c1">#     def compute_pmme_probabilities(self, forecasts, hindcasts, climatology, ensemble_sizes):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute PMME probabilities according to Min et al. (2009).</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         forecasts : dict of xarray.DataArray</span>
<span class="c1">#             Dictionary of forecast ensembles for each model</span>
<span class="c1">#         hindcasts : dict of xarray.DataArray</span>
<span class="c1">#             Dictionary of hindcast ensembles for each model</span>
<span class="c1">#         climatology : xarray.DataArray</span>
<span class="c1">#             Climatological data</span>
<span class="c1">#         ensemble_sizes : dict</span>
<span class="c1">#             Dictionary mapping model names to ensemble sizes</span>
            
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         pmme_probs : dict</span>
<span class="c1">#             Dictionary with keys &#39;BN&#39;, &#39;NN&#39;, &#39;AN&#39; containing PMME probabilities</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Get model names</span>
<span class="c1">#         model_names = list(forecasts.keys())</span>
        
<span class="c1">#         # Compute individual model probabilities</span>
<span class="c1">#         model_probs = {}</span>
<span class="c1">#         for model in model_names:</span>
<span class="c1">#             probs_bn, probs_nn, probs_an = self._compute_tercile_probabilities(</span>
<span class="c1">#                 forecasts[model], hindcasts[model], climatology</span>
<span class="c1">#             )</span>
<span class="c1">#             model_probs[model] = {</span>
<span class="c1">#                 &#39;BN&#39;: probs_bn,</span>
<span class="c1">#                 &#39;NN&#39;: probs_nn,</span>
<span class="c1">#                 &#39;AN&#39;: probs_an</span>
<span class="c1">#             }</span>
        
<span class="c1">#         # Compute model weights (Eq. 6)</span>
<span class="c1">#         weights = self._compute_model_weights(ensemble_sizes)</span>
        
<span class="c1">#         # Combine probabilities using total probability formula (Eq. 1)</span>
<span class="c1">#         pmme_probs = {}</span>
<span class="c1">#         for category in [&#39;BN&#39;, &#39;NN&#39;, &#39;AN&#39;]:</span>
<span class="c1">#             weighted_sum = None</span>
<span class="c1">#             for model in model_names:</span>
<span class="c1">#                 weighted_prob = model_probs[model][category] * weights[model]</span>
<span class="c1">#                 if weighted_sum is None:</span>
<span class="c1">#                     weighted_sum = weighted_prob</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     weighted_sum = weighted_sum + weighted_prob</span>
            
<span class="c1">#             pmme_probs[category] = weighted_sum</span>
        
<span class="c1">#         return pmme_probs</span>
    
<span class="c1">#     def compute_combined_map(self, pmme_probs, significance_level=0.05):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute combined map with significance testing ( test).</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         pmme_probs : dict</span>
<span class="c1">#             PMME probabilities for BN, NN, AN categories</span>
<span class="c1">#         significance_level : float</span>
<span class="c1">#             Significance level for  test (default 0.05)</span>
            
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         combined_map : xarray.DataArray</span>
<span class="c1">#             Combined map showing dominant category where significant</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Find dominant category</span>
<span class="c1">#         probs_array = xr.concat([pmme_probs[&#39;BN&#39;], pmme_probs[&#39;NN&#39;], pmme_probs[&#39;AN&#39;]], </span>
<span class="c1">#                                dim=&#39;category&#39;)</span>
<span class="c1">#         dominant_category = probs_array.argmax(dim=&#39;category&#39;)</span>
        
<span class="c1">#         # Compute  statistic (Eq. in section 5)</span>
<span class="c1">#         #  = n *  (P(Ej) - 1/3) / (1/3)</span>
<span class="c1">#         n = 1  # This should be total ensemble size across all models</span>
<span class="c1">#         expected_prob = 1/3</span>
        
<span class="c1">#         chi_square = n * (</span>
<span class="c1">#             (pmme_probs[&#39;BN&#39;] - expected_prob)**2 / expected_prob +</span>
<span class="c1">#             (pmme_probs[&#39;NN&#39;] - expected_prob)**2 / expected_prob +</span>
<span class="c1">#             (pmme_probs[&#39;AN&#39;] - expected_prob)**2 / expected_prob</span>
<span class="c1">#         )</span>
        
<span class="c1">#         # Critical value for  with 2 degrees of freedom</span>
<span class="c1">#         critical_value = stats.chi2.ppf(1 - significance_level, df=2)</span>
        
<span class="c1">#         # Create combined map: show dominant category where significant</span>
<span class="c1">#         combined_map = xr.where(</span>
<span class="c1">#             chi_square &gt; critical_value,</span>
<span class="c1">#             dominant_category + 1,  # 1 for BN, 2 for NN, 3 for AN</span>
<span class="c1">#             0  # No significant deviation from climatology</span>
<span class="c1">#         )</span>
        
<span class="c1">#         return combined_map</span>
    
<span class="c1"># # Example </span>
<span class="c1"># forecasts = {</span>
<span class="c1">#     &#39;model1&#39;: xr.DataArray(...),  # dimensions: (time, ensemble, lat, lon)</span>
<span class="c1">#     &#39;model2&#39;: xr.DataArray(...),</span>
<span class="c1">#     # ... more models</span>
<span class="c1"># }</span>

<span class="c1"># hindcasts = {</span>
<span class="c1">#     &#39;model1&#39;: xr.DataArray(...),  # cross-validated hindcasts</span>
<span class="c1">#     &#39;model2&#39;: xr.DataArray(...),</span>
<span class="c1">#     # ... more models</span>
<span class="c1"># }</span>

<span class="c1"># ensemble_sizes = {</span>
<span class="c1">#     &#39;model1&#39;: 20,</span>
<span class="c1">#     &#39;model2&#39;: 10,</span>
<span class="c1">#     # ... ensemble sizes for each model</span>
<span class="c1"># }</span>

<span class="c1"># # Initialize and compute</span>
<span class="c1"># pmme = WAS_Min2009_ProbWeighted()</span>

<span class="c1"># # Compute PMME probabilities</span>
<span class="c1"># pmme_probs = pmme.compute_pmme_probabilities(</span>
<span class="c1">#     forecasts, hindcasts, climatology, ensemble_sizes</span>
<span class="c1"># )</span>

<span class="c1"># # Get combined map</span>
<span class="c1"># combined_map = pmme.compute_combined_map(pmme_probs)</span>



<div class="viewcode-block" id="WAS_mme_xcELR">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELR">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_xcELR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extended Logistic Regression (ELR) for Multi-Model Ensemble (MME) forecasting derived from xcast package.</span>

<span class="sd">    This class implements an Extended Logistic Regression for probabilistic forecasting,</span>
<span class="sd">    directly computing tercile probabilities without requiring separate probability calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    elm_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments to pass to the xcast ELR model. If None, an empty dictionary is used.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_xcELR.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELR.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elm_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elm_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="n">elm_kwargs</span>     </div>


<div class="viewcode-block" id="WAS_mme_xcELR.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELR.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute probabilistic hindcast using the ELR model.</span>

<span class="sd">        Fits the ELR model on training data and predicts tercile probabilities for the test data.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">MELR</span><span class="p">(</span><span class="n">preprocessing</span><span class="o">=</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span> <span class="c1"># **self.elm_kwargs</span>
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="s1">&#39;probability&#39;</span><span class="p">})</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;PN&#39;</span><span class="p">,</span><span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_xcELR.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELR.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate probabilistic forecast for a target year using the ELR model.</span>

<span class="sd">        Fits the ELR model on hindcast data and predicts tercile probabilities for the target year.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period (not used in this method).</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period (not used in this method).</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">clim_year_end</span> <span class="o">=</span> <span class="n">clim_year_end</span>
        <span class="n">clim_year_start</span> <span class="o">=</span> <span class="n">clim_year_start</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">Predictant</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">hindcast_det_</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">MELR</span><span class="p">(</span><span class="n">preprocessing</span><span class="o">=</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="s1">&#39;probability&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_logistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_logistic</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multinomial Logistic Regression MME with multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    This class implements a unified approach for logistic regression with spatial clustering</span>
<span class="sd">    and three hyperparameter optimization strategies:</span>
<span class="sd">    1. Grid Search</span>
<span class="sd">    2. Random Search</span>
<span class="sd">    3. Bayesian Optimization (using Optuna)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    optimization_method : str, optional</span>
<span class="sd">        Method for hyperparameter optimization. Options: </span>
<span class="sd">        &#39;grid&#39;, &#39;random&#39;, &#39;bayesian&#39;, &#39;none&#39; (default: &#39;grid&#39;)</span>
<span class="sd">    C_range : list or tuple, optional</span>
<span class="sd">        For grid/random search: list of C values</span>
<span class="sd">        For Bayesian: tuple of (min_C, max_C) for log-uniform sampling</span>
<span class="sd">    solver_options : list, optional</span>
<span class="sd">        List of solver algorithms to consider</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Random seed for reproducibility (default: 42)</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default: 5)</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of spatial clusters (default: 4)</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for random/bayesian search (default: 20)</span>
<span class="sd">    n_trials : int, optional</span>
<span class="sd">        Number of trials for Bayesian optimization (default: 50)</span>
<span class="sd">    timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Bayesian optimization (default: None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="WAS_mme_logistic.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">optimization_method</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span>
                 <span class="n">C_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">],</span>
                 <span class="n">solver_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;sag&#39;</span><span class="p">,</span> <span class="s1">&#39;saga&#39;</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                 <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">=</span> <span class="n">optimization_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span> <span class="o">=</span> <span class="n">C_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="o">=</span> <span class="n">solver_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For storing Optuna studies</span></div>

        
<div class="viewcode-block" id="WAS_mme_logistic._create_parameter_grids">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._create_parameter_grids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_parameter_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create parameter grids for different optimization methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grid 1: L2 Penalty</span>
        <span class="n">solvers_l2</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> 
                     <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;sag&#39;</span><span class="p">,</span> <span class="s1">&#39;saga&#39;</span><span class="p">]]</span>
        <span class="n">param_grid_l2</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;penalty&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;l2&#39;</span><span class="p">],</span>
            <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="n">solvers_l2</span><span class="p">,</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span>
        <span class="p">}</span>
        
        <span class="c1"># Grid 2: L1 Penalty (ONLY for &#39;saga&#39;)</span>
        <span class="n">solvers_l1</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;saga&#39;</span><span class="p">]</span>
        <span class="n">param_grid_l1</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">solvers_l1</span><span class="p">:</span>
            <span class="n">param_grid_l1</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;penalty&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">],</span>
                <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="n">solvers_l1</span><span class="p">,</span>
                <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span>
            <span class="p">}</span>
        
        <span class="n">param_grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">param_grid_l2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">param_grid_l1</span><span class="p">:</span>
            <span class="n">param_grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_grid_l1</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">param_grids</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic._create_parameter_distributions">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._create_parameter_distributions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_parameter_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create parameter distributions for random search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">,</span>
            <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span><span class="p">,</span>
            <span class="s1">&#39;penalty&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="s1">&#39;l1&#39;</span><span class="p">]</span>  <span class="c1"># Include both penalties</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">param_dist</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic._grid_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._grid_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_grid_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform grid search optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">param_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_parameter_grids</span><span class="p">()</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> 
            <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span>
        <span class="p">)</span>
        
        <span class="n">cv_splitter</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span>
            <span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        
        <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> 
            <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grids</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="n">cv_splitter</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_log_loss&#39;</span><span class="p">,</span>
            <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic._random_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._random_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_random_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform random search optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">param_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_parameter_distributions</span><span class="p">()</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> 
            <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span>
        <span class="p">)</span>
        
        <span class="n">cv_splitter</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span>
            <span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> 
            <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
            <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="n">cv_splitter</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_log_loss&#39;</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic._bayesian_objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._bayesian_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Bayesian optimization with Optuna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;penalty&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="s1">&#39;l1&#39;</span><span class="p">])</span>
        
        <span class="c1"># Choose solver based on penalty</span>
        <span class="k">if</span> <span class="n">penalty</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;saga&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;solver&#39;</span><span class="p">,</span> 
                <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;saga&#39;</span><span class="p">])</span>
        
        <span class="c1"># Define C with log-uniform distribution</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">C_min</span><span class="p">,</span> <span class="n">C_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">C_min</span><span class="p">,</span> <span class="n">C_max</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use discrete values if provided</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_range</span><span class="p">)</span>
        
        <span class="c1"># Create and evaluate model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
            <span class="n">penalty</span><span class="o">=</span><span class="n">penalty</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
            <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span>
        <span class="p">)</span>
        
        <span class="c1"># Cross-validation</span>
        <span class="n">cv_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                   <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">X_val</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            
            <span class="c1"># Use negative log loss (higher is better for Optuna)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
                <span class="n">cv_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">cv_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="c1"># Return mean score (handle NaN)</span>
        <span class="n">cv_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
        <span class="n">valid_scores</span> <span class="o">=</span> <span class="n">cv_scores</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_scores</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_scores</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic._bayesian_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic._bayesian_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Bayesian optimization using Optuna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create study</span>
        <span class="n">study_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;logistic_cluster_</span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">cluster_id</span> <span class="k">else</span> <span class="s1">&#39;logistic&#39;</span>
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
            <span class="n">study_name</span><span class="o">=</span><span class="n">study_name</span><span class="p">,</span>
            <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We want to maximize accuracy/score</span>
            <span class="n">sampler</span><span class="o">=</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Define objective function with data</span>
        <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># Optimize</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
            <span class="n">objective_with_data</span><span class="p">,</span>
            <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
            <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        
        <span class="c1"># Store study for later analysis</span>
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">study</span>
        
        <span class="c1"># Extract best parameters</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
        
        <span class="c1"># Ensure penalty-solver compatibility</span>
        <span class="k">if</span> <span class="n">best_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;penalty&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;saga&#39;</span>
        
        <span class="k">return</span> <span class="n">best_params</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes best hyperparameters using the selected optimization method.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Predictor data with dimensions (T, M, Y, X)</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Predictand data with dimensions (T, Y, X)</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatology period</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatology period</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params_dict : dict</span>
<span class="sd">            Best hyperparameters for each cluster</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels for each spatial point</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>

        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Assuming WAS_Verification is available</span>
        <span class="n">verify</span> <span class="o">=</span> <span class="n">WAS_Verification</span><span class="p">()</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">verify</span><span class="o">.</span><span class="n">compute_class</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
               
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train_std</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>

        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>

        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

        
<span class="c1">###############################&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="c1"># # Remove M dimension if present</span>
        <span class="c1"># if &quot;M&quot; in Predictand.coords:</span>
        <span class="c1">#     Predictand = Predictand.isel(M=0).drop_vars(&#39;M&#39;).squeeze()</span>
        
        <span class="c1"># # Standardize predictors</span>
        <span class="c1"># X_train_std = standardize_timeseries(Predictors, clim_year_start, clim_year_end)</span>
        
        <span class="c1"># # Cluster on predictand time series</span>
        <span class="c1"># y_for_cluster = Predictand.stack(space=(&#39;Y&#39;, &#39;X&#39;)).transpose(&#39;space&#39;, &#39;T&#39;).values</span>
        <span class="c1"># finite_mask = np.all(np.isfinite(y_for_cluster), axis=1)</span>
        <span class="c1"># y_cluster = y_for_cluster[finite_mask]</span>
        
        <span class="c1"># kmeans = KMeans(n_clusters=self.n_clusters, random_state=self.random_state)</span>
        <span class="c1"># labels = kmeans.fit_predict(y_cluster)</span>
        
        <span class="c1"># full_labels = np.full(y_for_cluster.shape[0], np.nan)</span>
        <span class="c1"># full_labels[finite_mask] = labels</span>
        <span class="c1"># cluster_da = xr.DataArray(</span>
        <span class="c1">#     full_labels.reshape(len(Predictand[&#39;Y&#39;]), len(Predictand[&#39;X&#39;])),</span>
        <span class="c1">#     coords={&#39;Y&#39;: Predictand[&#39;Y&#39;], &#39;X&#39;: Predictand[&#39;X&#39;]},</span>
        <span class="c1">#     dims=[&#39;Y&#39;, &#39;X&#39;]</span>
        <span class="c1"># )</span>
        
        <span class="c1"># clusters = np.unique(labels[~np.isnan(labels)])</span>
        
        <span class="c1"># # Assuming WAS_Verification is available</span>
        <span class="c1"># verify = WAS_Verification()</span>
        <span class="c1"># Predictand = verify.compute_class(Predictand, clim_year_start, clim_year_end)</span>
        
        <span class="c1"># X_train_std[&#39;T&#39;] = Predictand[&#39;T&#39;]</span>
        
        <span class="c1"># best_params_dict = {}</span>
        
        <span class="c1"># for c in clusters:</span>
        <span class="c1">#     mask_3d = (cluster_da == c).expand_dims({&#39;T&#39;: Predictand[&#39;T&#39;]})</span>
            
        <span class="c1">#     # Stack data for current cluster</span>
        <span class="c1">#     X_stacked_c = X_train_std.where(mask_3d).stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).transpose(&#39;sample&#39;, &#39;M&#39;).values</span>
        <span class="c1">#     y_stacked_c = Predictand.where(mask_3d).stack(sample=(&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)).values.ravel()</span>
            
        <span class="c1">#     # Remove NaN values</span>
        <span class="c1">#     nan_mask_c = np.any(~np.isfinite(X_stacked_c), axis=1) | ~np.isfinite(y_stacked_c)</span>
        <span class="c1">#     X_clean_c = X_stacked_c[~nan_mask_c]</span>
        <span class="c1">#     y_clean_c = y_stacked_c[~nan_mask_c]</span>
            
        <span class="c1">#     if len(X_clean_c) == 0 or len(np.unique(y_clean_c)) &lt; 2:</span>
        <span class="c1">#         continue</span>
            
            <span class="c1"># Apply selected optimization method</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_search_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_search_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="c1"># Use default parameters</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;penalty&#39;</span><span class="p">:</span> <span class="s1">&#39;l2&#39;</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown optimization method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_params</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span> <span class="o">=</span> <span class="n">best_params_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="n">cluster_da</span>
        
        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> 
                      <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train models and compute predictions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data (classes)</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatology period</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatology period</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best parameters</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Predicted classes</span>
<span class="sd">        predicted_prob_da : xarray.DataArray</span>
<span class="sd">            Predicted probabilities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standardize data</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span> <span class="c1">#standardize_timeseries(X_train, clim_year_start, clim_year_end)</span>
        
        <span class="c1"># Standardize test data using training statistics</span>
        <span class="c1"># clim_slice = slice(str(clim_year_start), str(clim_year_end))</span>
        <span class="c1"># mean_val = X_train.sel(T=clim_slice).mean(dim=&#39;T&#39;)</span>
        <span class="c1"># std_val = X_train.sel(T=clim_slice).std(dim=&#39;T&#39;)</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span> <span class="c1"># (X_test - mean_val) / std_val</span>
        
        <span class="c1"># Get or compute hyperparameters</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>
        
        <span class="c1"># Extract coordinates</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        
        <span class="c1"># Initialize prediction arrays</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Train model for each cluster</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            
            <span class="c1"># Stack training data</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            
            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            
            <span class="c1"># Stack testing data</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>
            
            <span class="c1"># Create and train model</span>
            <span class="n">model_c</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
                <span class="o">**</span><span class="n">bp</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span>
            <span class="p">)</span>
            
            <span class="n">model_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_c</span>
            
            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="n">y_prob_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            
            <span class="c1"># Reconstruct spatial fields</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
            
            <span class="n">full_stacked_prob_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_prob_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_prob_c</span>
            <span class="n">pred_prob_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_prob_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions_prob</span><span class="p">),</span> 
                                        <span class="n">pred_prob_c_reshaped</span><span class="p">,</span> <span class="n">predictions_prob</span><span class="p">)</span>
        
        <span class="c1"># Create output DataArrays</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="n">predicted_prob_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_prob</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="n">predicted_prob_da</span> <span class="o">=</span> <span class="n">predicted_prob_da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">predicted_prob_da</span> <span class="o">=</span> <span class="n">predicted_prob_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">predicted_da</span><span class="p">,</span> <span class="n">predicted_prob_da</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> 
                 <span class="n">Predictors_train</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> 
                 <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate forecasts for a target year.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of climatology period</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of climatology period</span>
<span class="sd">        Predictors_train : xarray.DataArray</span>
<span class="sd">            Training predictor data</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for target year</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best parameters</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast (classes)</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Probabilistic forecast</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove M dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>
            
        <span class="c1"># Compute classes</span>
        <span class="n">verify</span> <span class="o">=</span> <span class="n">WAS_Verification</span><span class="p">()</span>
        <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">verify</span><span class="o">.</span><span class="n">compute_class</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> 
                                               <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="c1"># Create mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="c1"># Standardize data</span>
        <span class="n">Predictors_train_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors_train</span><span class="p">,</span> 
                                                     <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        
        <span class="n">clim_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">Predictors_train</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">clim_slice</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">Predictors_train</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">clim_slice</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        
        <span class="c1"># Align time coordinates</span>
        <span class="n">Predictors_train_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="c1"># Get or compute hyperparameters</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">Predictors_train</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> 
                <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>
        
        <span class="c1"># Extract coordinates</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        
        <span class="c1"># Initialize prediction arrays</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Train and predict for each cluster</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictors_train_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            
            <span class="c1"># Stack training data</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictors_train_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            
            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            
            <span class="c1"># Stack forecast data</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>
            
            <span class="c1"># Create and train model</span>
            <span class="n">model_c</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
                <span class="o">**</span><span class="n">bp</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span>
            <span class="p">)</span>
            
            <span class="n">model_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_c</span>
            
            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="n">y_prob_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            
            <span class="c1"># Reconstruct spatial fields</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
            
            <span class="n">full_stacked_prob_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_prob_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_prob_c</span>
            <span class="n">pred_prob_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_prob_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions_prob</span><span class="p">),</span> 
                                        <span class="n">pred_prob_c_reshaped</span><span class="p">,</span> <span class="n">predictions_prob</span><span class="p">)</span>
        
        <span class="c1"># Create output DataArrays</span>
        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_prob</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="c1"># Update time coordinate for forecast year</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        
        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_prob</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">forecast_det</span><span class="p">,</span> <span class="n">forecast_prob</span></div>

    
<div class="viewcode-block" id="WAS_mme_logistic.get_optimization_results">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_logistic.get_optimization_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_optimization_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get detailed results from hyperparameter optimization.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : dict</span>
<span class="sd">            Dictionary containing optimization results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;optimization_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span><span class="p">,</span>
            <span class="s1">&#39;best_parameters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span><span class="p">,</span>
            <span class="s1">&#39;cluster_labels&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="p">,</span>
            <span class="s1">&#39;models&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;optuna_studies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_dict</span>
            
        <span class="k">return</span> <span class="n">results</span>    </div>
</div>

<span class="c1"># #Exmaple MINE</span>
<span class="c1"># # Grid Search (default)</span>
<span class="c1"># model_grid = WAS_mme_logistic(optimization_method=&#39;grid&#39;)</span>
<span class="c1"># best_params, clusters = model_grid.compute_hyperparameters(predictors, predictand, 1981, 2010)</span>

<span class="c1"># # Random Search</span>
<span class="c1"># model_random = WAS_mme_logistic(</span>
<span class="c1">#     optimization_method=&#39;random&#39;,</span>
<span class="c1">#     n_iter_search=30</span>
<span class="c1"># )</span>

<span class="c1"># # Bayesian Optimization</span>
<span class="c1"># model_bayesian = WAS_mme_logistic(</span>
<span class="c1">#     optimization_method=&#39;bayesian&#39;,</span>
<span class="c1">#     C_range=(0.01, 1000.0),  # Continuous range for Bayesian</span>
<span class="c1">#     n_trials=100,</span>
<span class="c1">#     timeout=300  # 5 minutes timeout</span>
<span class="c1"># )</span>

<span class="c1"># # No optimization (use defaults)</span>
<span class="c1"># model_default = WAS_mme_logistic(optimization_method=&#39;none&#39;)</span>
    




<div class="viewcode-block" id="WAS_mme_gaussian_process">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_gaussian_process</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gaussian Process Classifier MME (multiclass via One-vs-Rest in sklearn).</span>

<span class="sd">    This class mirrors the structure of WAS_mme_logistic:</span>
<span class="sd">      - cluster the predictand time series (per gridpoint) -&gt; cluster_da</span>
<span class="sd">      - for each cluster: stack samples (T,Y,X), fit a classifier, predict class + proba</span>
<span class="sd">      - reconstruct to (T,Y,X) and return deterministic forecast + tercile probabilities</span>

<span class="sd">    IMPORTANT: GP classification scales cubically with N samples. To avoid infeasible runs,</span>
<span class="sd">    we subsample per cluster to max_train_samples during training and HPO.</span>

<span class="sd">    Supports three hyperparameter optimization methods:</span>
<span class="sd">      - &#39;grid&#39;: GridSearchCV (default)</span>
<span class="sd">      - &#39;random&#39;: RandomizedSearchCV</span>
<span class="sd">      - &#39;bayesian&#39;: Optuna Bayesian optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_mme_gaussian_process.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
        <span class="n">cv_folds</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="c1"># GP-related controls</span>
        <span class="n">kernel_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_restarts_optimizer_options</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">max_iter_predict_options</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
        <span class="n">max_train_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
        <span class="c1"># HPO method selection</span>
        <span class="n">hpo_method</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span>  <span class="c1"># &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;</span>
        <span class="c1"># RandomizedSearchCV parameters</span>
        <span class="n">n_random_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="c1"># Optuna parameters</span>
        <span class="n">n_trials</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># seconds</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># for Optuna</span>
        <span class="c1"># if you want a little numerical stability:</span>
        <span class="n">warm_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># kept for compatibility; sklearn GPC ignores this concept</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>

        <span class="c1"># Default kernels (reasonable starters for standardized predictors)</span>
        <span class="k">if</span> <span class="n">kernel_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kernel_options</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">C</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)),</span>
                <span class="n">C</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)),</span>
                <span class="n">C</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)),</span>
            <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_options</span> <span class="o">=</span> <span class="n">kernel_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer_options</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n_restarts_optimizer_options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict_options</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">max_iter_predict_options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_train_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_train_samples</span><span class="p">)</span>
        
        <span class="c1"># HPO method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">=</span> <span class="n">hpo_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hpo_method must be &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;, got </span><span class="si">{</span><span class="n">hpo_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># RandomizedSearchCV parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_random_iter</span> <span class="o">=</span> <span class="n">n_random_iter</span>
        
        <span class="c1"># Optuna parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">OPTUNA_AVAILABLE</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Optuna not available. Falling back to RandomizedSearchCV.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process._subsample">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process._subsample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_subsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">nmax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reproducible subsampling to keep GP feasible.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nmax</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nmax</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">nmax</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process._create_param_grid">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process._create_param_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_param_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create parameter grid for grid/random search.&quot;&quot;&quot;</span>
        <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;kernel&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_options</span><span class="p">,</span>
            <span class="s2">&quot;n_restarts_optimizer&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer_options</span><span class="p">),</span>
            <span class="s2">&quot;max_iter_predict&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict_options</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">param_grid</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process._create_param_distributions">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process._create_param_distributions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_param_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create parameter distributions for RandomizedSearchCV.&quot;&quot;&quot;</span>
        <span class="c1"># For randomized search, we can sample from distributions</span>
        <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;kernel&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_options</span><span class="p">,</span>
            <span class="s2">&quot;n_restarts_optimizer&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer_options</span><span class="p">),</span>
            <span class="s2">&quot;max_iter_predict&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict_options</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">param_dist</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process._optuna_objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process._optuna_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_optuna_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv_splitter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Objective function for Optuna Bayesian optimization.&quot;&quot;&quot;</span>
        <span class="c1"># Suggest kernel type</span>
        <span class="n">kernel_type</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;kernel_type&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="s1">&#39;Matern_1.5&#39;</span><span class="p">,</span> <span class="s1">&#39;Matern_2.5&#39;</span><span class="p">])</span>
        
        <span class="c1"># Suggest kernel parameters</span>
        <span class="n">length_scale</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;length_scale&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constant_value</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;constant_value&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Build kernel</span>
        <span class="k">if</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="s1">&#39;RBF&#39;</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span>
                <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="s1">&#39;Matern_1.5&#39;</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span>
                <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                <span class="n">nu</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> 
                <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;Matern_2.5&#39;</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span>
                <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                <span class="n">nu</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> 
                <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Add white noise kernel for numerical stability</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">+</span> <span class="n">WhiteKernel</span><span class="p">(</span><span class="n">noise_level</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">noise_level_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">))</span>
        
        <span class="c1"># Suggest other hyperparameters</span>
        <span class="n">n_restarts_optimizer</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span><span class="s1">&#39;n_restarts_optimizer&#39;</span><span class="p">,</span> 
                                                 <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer_options</span><span class="p">),</span>
                                                 <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer_options</span><span class="p">))</span>
        <span class="n">max_iter_predict</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span><span class="s1">&#39;max_iter_predict&#39;</span><span class="p">,</span>
                                            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict_options</span><span class="p">),</span>
                                            <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict_options</span><span class="p">))</span>
        
        <span class="c1"># Create and evaluate model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">GaussianProcessClassifier</span><span class="p">(</span>
            <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
            <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="n">n_restarts_optimizer</span><span class="p">,</span>
            <span class="n">max_iter_predict</span><span class="o">=</span><span class="n">max_iter_predict</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        
        <span class="c1"># Perform cross-validation</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">cv_splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
            <span class="n">X_train_fold</span><span class="p">,</span> <span class="n">X_val_fold</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">X_train</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            <span class="n">y_train_fold</span><span class="p">,</span> <span class="n">y_val_fold</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">y_train</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_fold</span><span class="p">,</span> <span class="n">y_train_fold</span><span class="p">)</span>
            
            <span class="c1"># Use negative log loss (to maximize)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">y_proba</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_val_fold</span><span class="p">)</span>
                <span class="n">score</span> <span class="o">=</span> <span class="o">-</span><span class="n">log_loss</span><span class="p">(</span><span class="n">y_val_fold</span><span class="p">,</span> <span class="n">y_proba</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mf">1e10</span><span class="p">)</span>  <span class="c1"># Very bad score for failed trials</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes best hyperparameters using selected HPO method.</span>

<span class="sd">        NOTE: As in your logistic version, this uses pre-standardized data.</span>
<span class="sd">        That preserves your current behavior but can introduce leakage if the</span>
<span class="sd">        standardization includes information beyond each CV fold.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>

        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Assuming WAS_Verification is available</span>
        <span class="n">verify</span> <span class="o">=</span> <span class="n">WAS_Verification</span><span class="p">()</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">verify</span><span class="o">.</span><span class="n">compute_class</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
               
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y_train_std</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>

        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>

        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>


        
<span class="c1">###########################################&quot;&quot;&quot;&quot;&quot;</span>
        <span class="c1"># if &quot;M&quot; in Predictand.coords:</span>
        <span class="c1">#     Predictand = Predictand.isel(M=0).drop_vars(&quot;M&quot;).squeeze()</span>

        <span class="c1"># # Standardize predictors </span>
        <span class="c1"># X_train_std = standardize_timeseries(Predictors, clim_year_start, clim_year_end)</span>

        <span class="c1"># # Cluster on predictand time series </span>
        <span class="c1"># y_for_cluster = Predictand.stack(space=(&quot;Y&quot;, &quot;X&quot;)).transpose(&quot;space&quot;, &quot;T&quot;).values</span>
        <span class="c1"># finite_mask = np.all(np.isfinite(y_for_cluster), axis=1)</span>
        <span class="c1"># y_cluster = y_for_cluster[finite_mask]</span>

        <span class="c1"># kmeans = KMeans(n_clusters=self.n_clusters, random_state=self.random_state)</span>
        <span class="c1"># labels = kmeans.fit_predict(y_cluster)</span>

        <span class="c1"># full_labels = np.full(y_for_cluster.shape[0], np.nan)</span>
        <span class="c1"># full_labels[finite_mask] = labels</span>

        <span class="c1"># cluster_da = xr.DataArray(</span>
        <span class="c1">#     full_labels.reshape(len(Predictand[&quot;Y&quot;]), len(Predictand[&quot;X&quot;])),</span>
        <span class="c1">#     coords={&quot;Y&quot;: Predictand[&quot;Y&quot;], &quot;X&quot;: Predictand[&quot;X&quot;]},</span>
        <span class="c1">#     dims=[&quot;Y&quot;, &quot;X&quot;],</span>
        <span class="c1"># )</span>
        <span class="c1"># clusters = np.unique(labels)</span>
        
        <span class="c1"># # Import WAS_Verification from your module</span>
        <span class="c1"># # Assuming WAS_Verification is available in the namespace</span>
        <span class="c1"># verify = WAS_Verification()</span>
        <span class="c1"># y_train_std = verify.compute_class(Predictand, clim_year_start, clim_year_end)</span>
        <span class="c1"># X_train_std[&#39;T&#39;] = y_train_std[&#39;T&#39;]</span>
        <span class="c1"># best_params_dict = {}</span>
        <span class="c1"># for c in clusters:</span>
        <span class="c1">#     mask_3d = (cluster_da == c).expand_dims({&quot;T&quot;: y_train_std[&quot;T&quot;]})</span>

        <span class="c1">#     X_stacked_c = (</span>
        <span class="c1">#         X_train_std.where(mask_3d)</span>
        <span class="c1">#         .stack(sample=(&quot;T&quot;, &quot;Y&quot;, &quot;X&quot;))</span>
        <span class="c1">#         .transpose(&quot;sample&quot;, &quot;M&quot;)</span>
        <span class="c1">#         .values</span>
        <span class="c1">#     )</span>
        <span class="c1">#     y_stacked_c = (</span>
        <span class="c1">#         y_train_std.where(mask_3d)</span>
        <span class="c1">#         .stack(sample=(&quot;T&quot;, &quot;Y&quot;, &quot;X&quot;))</span>
        <span class="c1">#         .values</span>
        <span class="c1">#         .ravel()</span>
        <span class="c1">#     )</span>
            
        <span class="c1">#     nan_mask_c = np.any(~np.isfinite(X_stacked_c), axis=1) | ~np.isfinite(y_stacked_c)</span>
        <span class="c1">#     X_clean_c = X_stacked_c[~nan_mask_c]</span>
        <span class="c1">#     y_clean_c = y_stacked_c[~nan_mask_c].astype(int)</span>

        <span class="c1">#     if len(X_clean_c) == 0 or len(np.unique(y_clean_c)) &lt; 2:</span>
        <span class="c1">#         best_params_dict[c] = None</span>
        <span class="c1">#         continue</span>

<span class="c1">###############</span>
            
            <span class="c1"># Subsample to keep GP feasible</span>
            <span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_samples</span><span class="p">)</span>
            
            <span class="c1"># Create CV splitter</span>
            <span class="n">cv_splitter</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                               <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="c1"># Grid Search</span>
                <span class="n">param_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_param_grid</span><span class="p">()</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">GaussianProcessClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                
                <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                    <span class="n">estimator</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                    <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="n">cv_splitter</span><span class="p">,</span>
                    <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_log_loss&quot;</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                
                <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="c1"># Randomized Search</span>
                <span class="n">param_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_param_distributions</span><span class="p">()</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">GaussianProcessClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                
                <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">estimator</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                    <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                    <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_random_iter</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="n">cv_splitter</span><span class="p">,</span>
                    <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_log_loss&quot;</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                
                <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="c1"># Optuna Bayesian Optimization</span>
                <span class="c1"># Create study</span>
                <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                    <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>
                    <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">()</span>
                <span class="p">)</span>
                
                <span class="c1"># Define objective with closure</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optuna_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">,</span> <span class="n">cv_splitter</span><span class="p">)</span>
                
                <span class="c1"># Optimize</span>
                <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                    <span class="n">objective</span><span class="p">,</span>
                    <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                    <span class="n">show_progress_bar</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                
                <span class="k">if</span> <span class="n">study</span><span class="o">.</span><span class="n">best_trial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">continue</span>
                    
                <span class="c1"># Convert best trial to sklearn-compatible parameters</span>
                <span class="n">best_trial</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_trial</span>
                <span class="n">kernel_type</span> <span class="o">=</span> <span class="n">best_trial</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;kernel_type&#39;</span><span class="p">]</span>
                <span class="n">length_scale</span> <span class="o">=</span> <span class="n">best_trial</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;length_scale&#39;</span><span class="p">]</span>
                <span class="n">constant_value</span> <span class="o">=</span> <span class="n">best_trial</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;constant_value&#39;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="s1">&#39;RBF&#39;</span><span class="p">:</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span>
                        <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                        <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="s1">&#39;Matern_1.5&#39;</span><span class="p">:</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span>
                        <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                        <span class="n">nu</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> 
                        <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;Matern_2.5&#39;</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">constant_value</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Matern</span><span class="p">(</span>
                        <span class="n">length_scale</span><span class="o">=</span><span class="n">length_scale</span><span class="p">,</span> 
                        <span class="n">nu</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> 
                        <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
                    <span class="p">)</span>
                
                <span class="c1"># Add white noise kernel</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">+</span> <span class="n">WhiteKernel</span><span class="p">(</span><span class="n">noise_level</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">noise_level_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">))</span>
                
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="p">,</span>
                    <span class="s1">&#39;n_restarts_optimizer&#39;</span><span class="p">:</span> <span class="n">best_trial</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;n_restarts_optimizer&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;max_iter_predict&#39;</span><span class="p">:</span> <span class="n">best_trial</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;max_iter_predict&#39;</span><span class="p">]</span>
                <span class="p">}</span>

        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X_train</span><span class="p">,</span>
        <span class="n">y_train</span><span class="p">,</span>
        <span class="n">X_test</span><span class="p">,</span>
        <span class="n">y_test</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit per-cluster GP models and predict on X_test.</span>

<span class="sd">        Assumes y_train already contains classes (0/1/2) consistent with your pipeline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">y_train</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">bp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]})</span>

            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">values</span>
                <span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Subsample training for feasibility</span>
            <span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample</span><span class="p">(</span>
                <span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_samples</span>
            <span class="p">)</span>

            <span class="n">model_c</span> <span class="o">=</span> <span class="n">GaussianProcessClassifier</span><span class="p">(</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="o">**</span><span class="n">bp</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">model_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_c</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="n">y_prob_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>

            <span class="c1"># Reconstruct</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            
            <span class="c1"># Use np.nan_to_num to handle NaN values in the mask</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>

            <span class="c1"># Ensure we always output 3 columns (PB, PN, PA)</span>
            <span class="n">full_stacked_prob_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Map model class columns -&gt; [0,1,2]</span>
            <span class="c1"># In sklearn, classes_ may be subset if a class was absent from training.</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">y_prob_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">cls</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[:,</span> <span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_prob_c</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">full_stacked_prob_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">pred_prob_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_prob_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">mask_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions_prob</span><span class="p">)</span>
            <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_prob</span><span class="p">,</span> <span class="n">pred_prob_c_reshaped</span><span class="p">,</span> <span class="n">predictions_prob</span><span class="p">)</span>

        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">predicted_prob_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_prob</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">],</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">predicted_prob_da</span> <span class="o">=</span> <span class="n">predicted_prob_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span><span class="p">,</span> <span class="n">predicted_prob_da</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">Predictors_train</span><span class="p">,</span>
        <span class="n">Predictor_for_year</span><span class="p">,</span>
        <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train on Predictors_train / Predictant, forecast for Predictor_for_year (1 time slice),</span>
<span class="sd">        returning deterministic class + tercile probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">verify</span> <span class="o">=</span> <span class="n">WAS_Verification</span><span class="p">()</span>
        <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">verify</span><span class="o">.</span><span class="n">compute_class</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">Predictors_train_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">Predictors_train</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">Predictors_train</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>

        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_no_m</span>
        <span class="n">Predictors_train_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>  <span class="c1"># Align time</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">Predictors_train</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">best_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">bp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">Predictors_train_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]})</span>

            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Predictors_train_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Predictant_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">values</span>
                <span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Subsample training for feasibility</span>
            <span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample</span><span class="p">(</span>
                <span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_samples</span>
            <span class="p">)</span>

            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">model_c</span> <span class="o">=</span> <span class="n">GaussianProcessClassifier</span><span class="p">(</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="o">**</span><span class="n">bp</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">model_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_c</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="n">y_prob_c</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>

            <span class="c1"># Reconstruct deterministic</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="n">mask_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_det</span><span class="p">,</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>

            <span class="c1"># Reconstruct probabilities (always PB/PN/PA)</span>
            <span class="n">full_stacked_prob_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">model_c</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">y_prob_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">cls</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[:,</span> <span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_prob_c</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">full_stacked_prob_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">pred_prob_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_prob_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">mask_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions_prob</span><span class="p">)</span>
            <span class="n">predictions_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_prob</span><span class="p">,</span> <span class="n">pred_prob_c_reshaped</span><span class="p">,</span> <span class="n">predictions_prob</span><span class="p">)</span>

        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_prob</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>

        <span class="c1"># Update T coordinate (same as your logistic version)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[Y]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[M]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>

        <span class="n">forecast_det</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_det</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_det</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">forecast_prob</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">forecast_det</span><span class="p">,</span> <span class="n">forecast_prob</span></div>


<div class="viewcode-block" id="WAS_mme_gaussian_process.get_hpo_summary">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_gaussian_process.get_hpo_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hpo_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get summary of HPO method and parameters.&quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;hpo_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span><span class="p">,</span>
            <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
            <span class="s1">&#39;max_train_samples&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_samples</span><span class="p">,</span>
            <span class="s1">&#39;cv_folds&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;n_random_iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_random_iter</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpo_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;n_trials&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span>
            <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;timeout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        
        <span class="k">return</span> <span class="n">summary</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_xcELM">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_xcELM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extreme Learning Machine (ELM) for Multi-Model Ensemble (MME) forecasting derived from xcast.</span>

<span class="sd">    This class implements an Extreme Learning Machine model for deterministic forecasting,</span>
<span class="sd">    with optional tercile probability calculations using various statistical distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    elm_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments to pass to the xcast ELM model. If None, default parameters are used:</span>
<span class="sd">        {&#39;regularization&#39;: 10, &#39;hidden_layer_size&#39;: 5, &#39;activation&#39;: &#39;lin&#39;, &#39;preprocessing&#39;: &#39;none&#39;, &#39;n_estimators&#39;: 5}.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probability calculations (&#39;t&#39;, &#39;gamma&#39;, &#39;nonparam&#39;, &#39;normal&#39;, &#39;lognormal&#39;, &#39;weibull_min&#39;).</span>
<span class="sd">        Default is &#39;gamma&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_xcELM.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elm_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elm_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;regularization&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;hidden_layer_size&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="s1">&#39;lin&#39;</span><span class="p">,</span>  <span class="c1"># &#39;sigm&#39;, &#39;tanh&#39;, &#39;lin&#39;, &#39;leaky&#39;, &#39;relu&#39;, &#39;softplus&#39;],</span>
                <span class="s1">&#39;preprocessing&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>  <span class="c1"># &#39;minmax&#39;, &#39;std&#39;, &#39;none&#39; ],</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span> <span class="o">=</span> <span class="n">elm_kwargs</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>         </div>


<div class="viewcode-block" id="WAS_mme_xcELM.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the ELM model.</span>

<span class="sd">        Fits the ELM model on training data and predicts deterministic values for the test data.</span>
<span class="sd">        Applies regridding and drymasking to ensure data consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">X_train</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">y_train</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        
        <span class="c1"># X_train = X_train.fillna(0)</span>
        <span class="c1"># y_train = y_train.fillna(0)</span>
        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELM</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span><span class="p">)</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_xcELM._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_xcELM.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_xcELM.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_xcELM.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_xcELM.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_xcELM.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_xcELM.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross_val</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the ELM model.</span>

<span class="sd">        Fits the ELM model on hindcast data, predicts deterministic values for the target year,</span>
<span class="sd">        and computes tercile probabilities. Applies regridding, drymasking, and standardization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross_val : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result_ : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X), where probability</span>
<span class="sd">            includes [&#39;PB&#39;, &#39;PN&#39;, &#39;PA&#39;] (below-normal, normal, above-normal).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">Predictant</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">drymask</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">drymask</span><span class="p">(</span>
            <span class="n">Predictant</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quantile_threshold</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">)</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">*</span><span class="n">drymask</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">*</span><span class="n">drymask</span>
        
        <span class="c1"># hindcast_det_ = hindcast_det.fillna(0)</span>
        <span class="c1"># Predictant_ = Predictant.fillna(0)</span>
        <span class="c1"># Predictor_for_year_ = Predictor_for_year.fillna(0)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">ELM</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">elm_kwargs</span><span class="p">)</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>  <span class="c1"># Convert from epoch</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Get the datetime64 value from da1</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Extract month</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_</span> <span class="o">=</span> <span class="n">result_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>


        <span class="c1"># Compute tercile probabilities on the predictions</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det_cross_val</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="HPELMWrapper">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HPELMWrapper</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">RegressorMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for HPELM to make it compatible with scikit-learn&#39;s hyperparameter optimization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HPELMWrapper.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neurons</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigm&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span> <span class="o">=</span> <span class="n">neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="HPELMWrapper.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">HPELM</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">classification</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add_neurons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="HPELMWrapper.predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>


<div class="viewcode-block" id="HPELMWrapper.score">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.score">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>  <span class="c1"># Negative MSE for optimization</span></div>


<div class="viewcode-block" id="HPELMWrapper.get_params">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.get_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;neurons&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">}</span></div>


<div class="viewcode-block" id="HPELMWrapper.set_params">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.HPELMWrapper.set_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_hpELM">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_hpELM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extreme Learning Machine (ELM) based Multi-Model Ensemble (MME) forecasting using hpelm library.</span>
<span class="sd">    This class implements a single-model forecasting approach using HPELM for deterministic predictions,</span>
<span class="sd">    with optional tercile probability calculations using various statistical distributions.</span>
<span class="sd">    Implements hyperparameter optimization via multiple methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neurons_range : list of int, optional</span>
<span class="sd">        List of neuron counts to tune for HPELM (default is [10, 20, 50, 100]).</span>
<span class="sd">    activation_options : list of str, optional</span>
<span class="sd">        Activation functions to tune for HPELM (default is [&#39;sigm&#39;, &#39;tanh&#39;, &#39;lin&#39;, &#39;rbf_l1&#39;, &#39;rbf_l2&#39;, &#39;rbf_linf&#39;]).</span>
<span class="sd">    norm_range : list of float, optional</span>
<span class="sd">        Regularization parameters to tune for HPELM (default is [0.1, 1.0, 10.0, 100.0]).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities.</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for homogenized zones (default is 4).</span>
<span class="sd">    n_trials_bayesian : int, optional</span>
<span class="sd">        Number of trials for Bayesian optimization (default=50).</span>
<span class="sd">    bayesian_sampler : str, optional</span>
<span class="sd">        Sampler for Bayesian optimization: &#39;tpe&#39; or &#39;random&#39; (default=&#39;tpe&#39;).</span>
<span class="sd">    scoring : str, optional</span>
<span class="sd">        Scoring metric for optimization (default=&#39;neg_mean_squared_error&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_hpELM.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">neurons_range</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
                 <span class="n">activation_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sigm&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_linf&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_gauss&#39;</span><span class="p">],</span>
                 <span class="n">norm_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">n_trials_bayesian</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">bayesian_sampler</span><span class="o">=</span><span class="s1">&#39;tpe&#39;</span><span class="p">,</span>
                 <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span> <span class="o">=</span> <span class="n">neurons_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span> <span class="o">=</span> <span class="n">activation_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span> <span class="o">=</span> <span class="n">norm_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials_bayesian</span> <span class="o">=</span> <span class="n">n_trials_bayesian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">=</span> <span class="n">bayesian_sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scoring</span> <span class="o">=</span> <span class="n">scoring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Validate optimization method</span>
        <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;search_method must be one of </span><span class="si">{</span><span class="n">valid_methods</span><span class="si">}</span><span class="s2">, got &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM._get_bounds">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._get_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_range</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper to extract (min, max, is_dist) from a list or scipy distribution.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">param_range</span><span class="p">,</span> <span class="s1">&#39;support&#39;</span><span class="p">):</span> <span class="c1"># Scipy distribution</span>
                <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">param_range</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">low</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">high</span><span class="p">),</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># List or array</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">param_range</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">param_range</span><span class="p">)),</span> <span class="kc">False</span></div>

    

<div class="viewcode-block" id="WAS_mme_hpELM._create_bayesian_sampler">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._create_bayesian_sampler">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_bayesian_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create sampler for Bayesian optimization.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">==</span> <span class="s1">&#39;tpe&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RandomSampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span></div>


    <span class="c1"># def _bayesian_objective(self, trial, X, y):</span>
    <span class="c1">#     &quot;&quot;&quot;Objective function for Bayesian optimization.&quot;&quot;&quot;</span>
    <span class="c1">#     neurons = trial.suggest_categorical(&#39;neurons&#39;, self.neurons_range)</span>
    <span class="c1">#     activation = trial.suggest_categorical(&#39;activation&#39;, self.activation_options)</span>
    <span class="c1">#     norm = trial.suggest_float(&#39;norm&#39;, min(self.norm_range), max(self.norm_range), log=True)</span>
        
    <span class="c1">#     # Create and evaluate model</span>
    <span class="c1">#     model = HPELMWrapper(neurons=neurons, activation=activation, norm=norm, </span>
    <span class="c1">#                        random_state=self.random_state)</span>
        
    <span class="c1">#     # Simple cross-validation</span>
    <span class="c1">#     from sklearn.model_selection import cross_val_score</span>
    <span class="c1">#     scores = cross_val_score(model, X, y, cv=self.cv_folds, </span>
    <span class="c1">#                              scoring=self.scoring, n_jobs=-1)</span>
    <span class="c1">#     return np.mean(scores)</span>

<div class="viewcode-block" id="WAS_mme_hpELM._bayesian_objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._bayesian_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Objective function for Bayesian optimization.&quot;&quot;&quot;</span>
            <span class="c1"># Handle Neurons</span>
            <span class="n">low_n</span><span class="p">,</span> <span class="n">high_n</span><span class="p">,</span> <span class="n">is_dist_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_dist_n</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">low_n</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">high_n</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">])</span>
    
            <span class="c1"># Handle Activation</span>
            <span class="n">activation</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;activation&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span><span class="p">)</span>
    
            <span class="c1"># Handle Norm</span>
            <span class="n">low_f</span><span class="p">,</span> <span class="n">high_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span><span class="p">)</span>
            <span class="c1"># We use log=True assuming regularization parameters often span orders of magnitude</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">low_f</span><span class="p">,</span> <span class="n">high_f</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">neurons</span><span class="o">=</span><span class="n">neurons</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> 
                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            
            <span class="c1"># Set n_jobs=1 here to avoid conflicts with Optuna&#39;s n_jobs=-1</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
                                     <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


    <span class="c1"># def _grid_search_optimization(self, X, y):</span>
    <span class="c1">#     &quot;&quot;&quot;Perform grid search optimization.&quot;&quot;&quot;</span>
    <span class="c1">#     param_grid = {</span>
    <span class="c1">#         &#39;neurons&#39;: self.neurons_range,</span>
    <span class="c1">#         &#39;activation&#39;: self.activation_options,</span>
    <span class="c1">#         &#39;norm&#39;: self.norm_range</span>
    <span class="c1">#     }</span>
        
    <span class="c1">#     model = HPELMWrapper(random_state=self.random_state)</span>
    <span class="c1">#     grid_search = GridSearchCV(</span>
    <span class="c1">#         model, param_grid=param_grid, cv=self.cv_folds,</span>
    <span class="c1">#         scoring=self.scoring, n_jobs=-1, verbose=0</span>
    <span class="c1">#     )</span>
    <span class="c1">#     grid_search.fit(X, y)</span>
    <span class="c1">#     return grid_search.best_params_</span>

<div class="viewcode-block" id="WAS_mme_hpELM._grid_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._grid_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_grid_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Perform grid search optimization with distribution handling.&quot;&quot;&quot;</span>
            <span class="c1"># Grid search CANNOT take a distribution object. </span>
            <span class="c1"># If a distribution is provided, we must sample N points to create a grid.</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
            <span class="p">}</span>
    
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p_range</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">p_range</span><span class="p">,</span> <span class="s1">&#39;support&#39;</span><span class="p">):</span>
                    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">p_range</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
                    <span class="c1"># Create 5 pointall_model_hdcsts across the range for the grid</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span>
                        <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">low</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">high</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_range</span>
            
            <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span>
                                       <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM._random_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._random_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_random_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform random search optimization.&quot;&quot;&quot;</span>
        <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;neurons&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">,</span>
            <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span><span class="p">,</span>
            <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span>
        <span class="p">}</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM._bayesian_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._bayesian_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform Bayesian optimization with Optuna.&quot;&quot;&quot;</span>
        <span class="n">study_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;cluster_</span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;global&quot;</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># maximize negative MSE = minimize MSE</span>
            <span class="n">sampler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_bayesian_sampler</span><span class="p">(),</span>
            <span class="n">study_name</span><span class="o">=</span><span class="n">study_name</span>
        <span class="p">)</span>
        
        <span class="c1"># Optimize</span>
        <span class="n">objective_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_objective</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective_func</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials_bayesian</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Store study for analysis</span>
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">study</span>
        
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data for each homogenized zone.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params_dict : dict</span>
<span class="sd">            Best hyperparameters for each cluster.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels with dimensions (Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>

        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
               
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>

        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>

        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Select optimization method</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_search_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_search_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_optimization</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown optimization method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span> <span class="o">=</span> <span class="n">best_params_dict</span>
        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.get_optimization_results">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.get_optimization_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_optimization_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return optimization results for analysis.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing optimization results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;best_params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params_dict</span><span class="p">,</span>
            <span class="s1">&#39;search_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="p">,</span>
            <span class="s1">&#39;bayesian_studies&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">study</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;bayesian_trials_cluster_</span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">trials_dataframe</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.plot_optimization_history">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.plot_optimization_history">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_optimization_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot optimization history (for Bayesian optimization only).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_id : int, optional</span>
<span class="sd">            Specific cluster to plot. If None, plots all clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">!=</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting only available for Bayesian optimization&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">visualization</span><span class="o">.</span><span class="n">plot_optimization_history</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> 
                                     <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">c_id</span><span class="p">,</span> <span class="n">study</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">trials_dataframe</span><span class="p">()</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="s1">&#39;o-&#39;</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">c_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Trial&#39;</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Score (Negative MSE)&#39;</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="WAS_mme_hpELM.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the HPELM model with injected hyperparameters for each zone.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters per cluster. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standardize inputs</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">y_train</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span>
        <span class="n">y_test_std</span> <span class="o">=</span> <span class="n">y_test</span>

        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train_std</span><span class="p">,</span> <span class="n">y_train_std</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>

            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>

            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_test_stacked_c</span> <span class="o">=</span> <span class="n">y_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>

            <span class="c1"># Initialize and train the HPELM model for this cluster</span>
            <span class="n">hpelm_c</span> <span class="o">=</span> <span class="n">HPELM</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">X_train_clean_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">classification</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Initialize weights and biases for the neurons</span>
            <span class="c1"># Use a random number generator for reproducibility</span>
            <span class="c1"># rng = np.random.default_rng(1234)    # isolated RNG</span>
            <span class="c1"># n = bp[&#39;neurons&#39;]</span>
            <span class="c1"># W = rng.standard_normal((X_train_clean_c.shape[1], n))</span>
            <span class="c1"># B = rng.standard_normal(n)</span>
            <span class="c1"># hpelm_c.add_neurons(bp[&#39;neurons&#39;], bp[&#39;activation&#39;],W=W, B=B)</span>
            
            <span class="n">hpelm_c</span><span class="o">.</span><span class="n">add_neurons</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;neurons&#39;</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">])</span>
            <span class="n">hpelm_c</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">hpelm_c</span>

            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">hpelm_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>

            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>

        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_hpELM._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_hpELM.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_hpELM.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_hpELM._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single HPELM model with optimized hyperparameters.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
            
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask_c</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span>
            <span class="c1"># Initialize and train the HPELM model for this cluster</span>
            <span class="n">hpelm_c</span> <span class="o">=</span> <span class="n">HPELM</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">X_train_clean_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">classification</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Initialize weights and biases for the neurons</span>
            <span class="c1"># Use a random number generator for reproducibility</span>
            <span class="c1"># rng = np.random.default_rng(1234)    # isolated RNG</span>
            <span class="c1"># n = bp[&#39;neurons&#39;]</span>
            <span class="c1"># W = rng.standard_normal((X_train_clean_c.shape[1], n))</span>
            <span class="c1"># B = rng.standard_normal(n)</span>
            <span class="c1"># hpelm_c.add_neurons(bp[&#39;neurons&#39;], bp[&#39;activation&#39;],W=W, B=B)</span>
    
            <span class="n">hpelm_c</span><span class="o">.</span><span class="n">add_neurons</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;neurons&#39;</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">])</span>
            <span class="n">hpelm_c</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">hpelm_c</span>
            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">hpelm_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">full_stacked_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">full_stacked_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM.compare_optimization_methods">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM.compare_optimization_methods">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compare_optimization_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare different hyperparameter optimization methods.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : array-like</span>
<span class="sd">            Training features</span>
<span class="sd">        y_train : array-like</span>
<span class="sd">            Training targets</span>
<span class="sd">        methods : list</span>
<span class="sd">            List of methods to compare</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Comparison results for each method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing </span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> optimization&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
            
            <span class="c1"># Create model with specific optimization method</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">WAS_mme_hpELM</span><span class="p">(</span>
                <span class="n">search_method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">n_trials_bayesian</span><span class="o">=</span><span class="mi">30</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            
            <span class="c1"># Time the optimization</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1"># Create dummy cluster data for single cluster test</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span>
            
            <span class="c1"># Optimize for single cluster</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_grid_search_optimization</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_random_search_optimization</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># bayesian</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_bayesian_optimization</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
            
            <span class="c1"># Store results</span>
            <span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;best_params&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">,</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">elapsed_time</span><span class="p">,</span>
                <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span>
            <span class="p">}</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best parameters: </span><span class="si">{</span><span class="n">best_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time elapsed: </span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">results</span></div>
</div>



<span class="c1"># # 1. Grid Search (exhaustive)</span>
<span class="c1"># model_grid = WAS_mme_hpELM(</span>
<span class="c1">#     search_method=&#39;grid&#39;,</span>
<span class="c1">#     neurons_range=[10, 50, 100],</span>
<span class="c1">#     activation_options=[&#39;sigm&#39;, &#39;tanh&#39;],</span>
<span class="c1">#     norm_range=[0.1, 1.0, 10.0]</span>
<span class="c1"># )</span>

<span class="c1"># # 2. Random Search (default)</span>
<span class="c1"># model_random = WAS_mme_hpELM(</span>
<span class="c1">#     search_method=&#39;random&#39;,  # Default</span>
<span class="c1">#     n_iter_search=20,</span>
<span class="c1">#     cv_folds=3</span>
<span class="c1"># )</span>

<span class="c1"># # 3. Bayesian Optimization</span>
<span class="c1"># model_bayesian = WAS_mme_hpELM(</span>
<span class="c1">#     search_method=&#39;bayesian&#39;,</span>
<span class="c1">#     n_trials_bayesian=100,</span>
<span class="c1">#     bayesian_sampler=&#39;tpe&#39;,  # Tree-structured Parzen Estimator</span>
<span class="c1">#     cv_folds=3</span>
<span class="c1"># )</span>

<span class="c1"># # Compute hyperparameters with selected method</span>
<span class="c1"># best_params, cluster_da = model_bayesian.compute_hyperparameters(</span>
<span class="c1">#     predictors, predictand, 1981, 2010</span>
<span class="c1"># )</span>

<span class="c1"># # Get optimization results</span>
<span class="c1"># results = model_bayesian.get_optimization_results()</span>
<span class="c1"># print(f&quot;Optimization method: {results[&#39;search_method&#39;]}&quot;)</span>
<span class="c1"># print(f&quot;Best parameters: {results[&#39;best_params&#39;]}&quot;)</span>

<span class="c1"># # Plot optimization history for Bayesian method</span>
<span class="c1"># if model_bayesian.search_method == &#39;bayesian&#39;:</span>
<span class="c1">#     model_bayesian.plot_optimization_history(cluster_id=0)</span>
    
<div class="viewcode-block" id="WAS_mme_hpELM_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_hpELM_</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extreme Learning Machine (ELM) based Multi-Model Ensemble (MME) forecasting using hpelm library.</span>
<span class="sd">    This class implements a single-model forecasting approach using HPELM for deterministic predictions,</span>
<span class="sd">    with optional tercile probability calculations using various statistical distributions.</span>
<span class="sd">    Implements hyperparameter optimization via multiple methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neurons_range : list of int, optional</span>
<span class="sd">        List of neuron counts to tune for HPELM (default is [10, 20, 50, 100]).</span>
<span class="sd">    activation_options : list of str, optional</span>
<span class="sd">        Activation functions to tune for HPELM (default is [&#39;sigm&#39;, &#39;tanh&#39;, &#39;lin&#39;, &#39;rbf_l1&#39;, &#39;rbf_l2&#39;, &#39;rbf_linf&#39;]).</span>
<span class="sd">    norm_range : list of float, optional</span>
<span class="sd">        Regularization parameters to tune for HPELM (default is [0.1, 1.0, 10.0, 100.0]).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39; or &#39;nonparam&#39;.) (default is &#39;bestfit&#39;).</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    n_trials_bayesian : int, optional</span>
<span class="sd">        Number of trials for Bayesian optimization (default=50).</span>
<span class="sd">    bayesian_sampler : str, optional</span>
<span class="sd">        Sampler for Bayesian optimization: &#39;tpe&#39; or &#39;random&#39; (default=&#39;tpe&#39;).</span>
<span class="sd">    scoring : str, optional</span>
<span class="sd">        Scoring metric for optimization (default=&#39;neg_mean_squared_error&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_hpELM_.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">neurons_range</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
                 <span class="n">activation_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sigm&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_linf&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_gauss&#39;</span><span class="p">],</span>
                 <span class="n">norm_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">n_trials_bayesian</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">bayesian_sampler</span><span class="o">=</span><span class="s1">&#39;tpe&#39;</span><span class="p">,</span>
                 <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span> <span class="o">=</span> <span class="n">neurons_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span> <span class="o">=</span> <span class="n">activation_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span> <span class="o">=</span> <span class="n">norm_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials_bayesian</span> <span class="o">=</span> <span class="n">n_trials_bayesian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">=</span> <span class="n">bayesian_sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scoring</span> <span class="o">=</span> <span class="n">scoring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Validate optimization method</span>
        <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;search_method must be one of </span><span class="si">{</span><span class="n">valid_methods</span><span class="si">}</span><span class="s2">, got &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_._get_bounds">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._get_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_range</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper to extract (min, max, is_dist) from a list or scipy distribution.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">param_range</span><span class="p">,</span> <span class="s1">&#39;support&#39;</span><span class="p">):</span> <span class="c1"># Scipy distribution</span>
                <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">param_range</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">low</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">high</span><span class="p">),</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># List or array</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">param_range</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">param_range</span><span class="p">)),</span> <span class="kc">False</span></div>

    

<div class="viewcode-block" id="WAS_mme_hpELM_._create_bayesian_sampler">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._create_bayesian_sampler">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_bayesian_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create sampler for Bayesian optimization.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">==</span> <span class="s1">&#39;tpe&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_sampler</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RandomSampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span></div>


    <span class="c1"># def _bayesian_objective(self, trial, X, y):</span>
    <span class="c1">#     &quot;&quot;&quot;Objective function for Bayesian optimization.&quot;&quot;&quot;</span>
    <span class="c1">#     neurons = trial.suggest_categorical(&#39;neurons&#39;, self.neurons_range)</span>
    <span class="c1">#     activation = trial.suggest_categorical(&#39;activation&#39;, self.activation_options)</span>
    <span class="c1">#     norm = trial.suggest_float(&#39;norm&#39;, min(self.norm_range), max(self.norm_range), log=True)</span>
        
    <span class="c1">#     # Create and evaluate model</span>
    <span class="c1">#     model = HPELMWrapper(neurons=neurons, activation=activation, norm=norm, </span>
    <span class="c1">#                        random_state=self.random_state)</span>
        
    <span class="c1">#     # Simple cross-validation</span>
    <span class="c1">#     from sklearn.model_selection import cross_val_score</span>
    <span class="c1">#     scores = cross_val_score(model, X, y, cv=self.cv_folds, </span>
    <span class="c1">#                              scoring=self.scoring, n_jobs=-1)</span>
    <span class="c1">#     return np.mean(scores)</span>

<div class="viewcode-block" id="WAS_mme_hpELM_._bayesian_objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._bayesian_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Objective function for Bayesian optimization.&quot;&quot;&quot;</span>
            <span class="c1"># Handle Neurons</span>
            <span class="n">low_n</span><span class="p">,</span> <span class="n">high_n</span><span class="p">,</span> <span class="n">is_dist_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_dist_n</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">low_n</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">high_n</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">])</span>
    
            <span class="c1"># Handle Activation</span>
            <span class="n">activation</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;activation&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span><span class="p">)</span>
    
            <span class="c1"># Handle Norm</span>
            <span class="n">low_f</span><span class="p">,</span> <span class="n">high_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span><span class="p">)</span>
            <span class="c1"># We use log=True assuming regularization parameters often span orders of magnitude</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">low_f</span><span class="p">,</span> <span class="n">high_f</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">neurons</span><span class="o">=</span><span class="n">neurons</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> 
                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            
            <span class="c1"># Set n_jobs=1 here to avoid conflicts with Optuna&#39;s n_jobs=-1</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
                                     <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


    <span class="c1"># def _grid_search_optimization(self, X, y):</span>
    <span class="c1">#     &quot;&quot;&quot;Perform grid search optimization.&quot;&quot;&quot;</span>
    <span class="c1">#     param_grid = {</span>
    <span class="c1">#         &#39;neurons&#39;: self.neurons_range,</span>
    <span class="c1">#         &#39;activation&#39;: self.activation_options,</span>
    <span class="c1">#         &#39;norm&#39;: self.norm_range</span>
    <span class="c1">#     }</span>
        
    <span class="c1">#     model = HPELMWrapper(random_state=self.random_state)</span>
    <span class="c1">#     grid_search = GridSearchCV(</span>
    <span class="c1">#         model, param_grid=param_grid, cv=self.cv_folds,</span>
    <span class="c1">#         scoring=self.scoring, n_jobs=-1, verbose=0</span>
    <span class="c1">#     )</span>
    <span class="c1">#     grid_search.fit(X, y)</span>
    <span class="c1">#     return grid_search.best_params_</span>

<div class="viewcode-block" id="WAS_mme_hpELM_._grid_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._grid_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_grid_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Perform grid search optimization with distribution handling.&quot;&quot;&quot;</span>
            <span class="c1"># Grid search CANNOT take a distribution object. </span>
            <span class="c1"># If a distribution is provided, we must sample N points to create a grid.</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
            <span class="p">}</span>
    
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p_range</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;neurons&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">p_range</span><span class="p">,</span> <span class="s1">&#39;support&#39;</span><span class="p">):</span>
                    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">p_range</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
                    <span class="c1"># Create 5 pointall_model_hdcsts across the range for the grid</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span>
                        <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">low</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">high</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_range</span>
            
            <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span>
                                       <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_._random_search_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._random_search_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_random_search_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform random search optimization.&quot;&quot;&quot;</span>
        <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;neurons&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_range</span><span class="p">,</span>
            <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span><span class="p">,</span>
            <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_range</span>
        <span class="p">}</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">HPELMWrapper</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_._bayesian_optimization">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._bayesian_optimization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bayesian_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform Bayesian optimization with Optuna.&quot;&quot;&quot;</span>
        <span class="n">study_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;cluster_</span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;global&quot;</span>
        
        <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># maximize negative MSE = minimize MSE</span>
            <span class="n">sampler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_bayesian_sampler</span><span class="p">(),</span>
            <span class="n">study_name</span><span class="o">=</span><span class="n">study_name</span>
        <span class="p">)</span>
        
        <span class="c1"># Optimize</span>
        <span class="n">objective_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_objective</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective_func</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials_bayesian</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Store study for analysis</span>
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_studies</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">study</span>
        
        <span class="k">return</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the best hyperparameters using selected optimization method on stacked training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Best hyperparameters found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Predictand.name = &quot;varname&quot;</span>
        
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid training data after removing NaNs&quot;</span><span class="p">)</span>

        <span class="c1"># Select optimization method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_search_optimization</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_search_optimization</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bayesian_optimization</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown optimization method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_params</span> <span class="o">=</span> <span class="n">best_params</span>
        <span class="k">return</span> <span class="n">best_params</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_.get_optimization_results">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.get_optimization_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_optimization_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return optimization results for analysis.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing optimization results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;best_params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params</span><span class="p">,</span>
            <span class="s1">&#39;search_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="p">,</span>
            <span class="s1">&#39;bayesian_study&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;bayesian_trials&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span><span class="o">.</span><span class="n">trials_dataframe</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;best_trial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span><span class="o">.</span><span class="n">best_trial</span><span class="o">.</span><span class="n">params</span>
        
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_.plot_optimization_history">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.plot_optimization_history">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_optimization_history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot optimization history (for Bayesian optimization only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">!=</span> <span class="s1">&#39;bayesian&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting only available for Bayesian optimization with completed study&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span><span class="o">.</span><span class="n">trials_dataframe</span><span class="p">()</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="s1">&#39;o-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Trial Score&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span><span class="o">.</span><span class="n">best_value</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> 
                   <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Best Score: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesian_study</span><span class="o">.</span><span class="n">best_value</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Trial Number&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Score (Negative MSE)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Bayesian Optimization History&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="WAS_mme_hpELM_.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the HPELM model with injected hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize the HPELM model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="n">HPELM</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">X_train_clean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">classification</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">add_neurons</span><span class="p">(</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;neurons&#39;</span><span class="p">],</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Reconstruct predictions</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_hpELM_._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_hpELM_.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_hpELM_.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_hpELM_.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_mme_hpELM_._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>



<div class="viewcode-block" id="WAS_mme_hpELM_.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_hpELM_.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single HPELM model with optimized hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>



        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">)</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize and fit the HPELM model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span> <span class="o">=</span> <span class="n">HPELM</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">X_train_clean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">classification</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">add_neurons</span><span class="p">(</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;neurons&#39;</span><span class="p">],</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hpelm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Reconstruct the prediction array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_MLP_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_MLP_</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi-Layer Perceptron (MLP) for Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a Multi-Layer Perceptron model using scikit-learn&#39;s MLPRegressor</span>
<span class="sd">    for deterministic forecasting, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    hidden_layer_sizes_range : list of tuples, optional</span>
<span class="sd">        List of hidden layer sizes to tune, e.g., [(10,), (10, 5), (20, 10)] (default).</span>
<span class="sd">    activation_options : list of str, optional</span>
<span class="sd">        Activation functions to tune (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;) (default is [&#39;relu&#39;, &#39;tanh&#39;, &#39;logistic&#39;]).</span>
<span class="sd">    solver_options : list of str, optional</span>
<span class="sd">        Solvers to tune (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;) (default is [&#39;adam&#39;, &#39;sgd&#39;, &#39;lbfgs&#39;]).</span>
<span class="sd">    alpha_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        L2 regularization parameters to tune (default is [0.0001, 0.001, 0.01, 0.1]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    learning_rate_init_range : list or scipy.stats distribution, optional</span>
<span class="sd">        Learning rate initialization range (default is loguniform(0.0001, 0.01)).</span>
<span class="sd">        For grid search, provide a list of values.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum iterations (default is 200).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;, etc.) (default is &#39;nonparam&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized/bayesian search or points to sample for grid search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    optuna_n_jobs : int, optional</span>
<span class="sd">        Number of parallel jobs for Optuna (default is 1).</span>
<span class="sd">    optuna_timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Optuna optimization (default is None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_MLP_.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">hidden_layer_sizes_range</span><span class="o">=</span><span class="p">[(</span><span class="mi">10</span><span class="p">,),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
                 <span class="n">learning_rate_init_range</span><span class="o">=</span><span class="n">loguniform</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span>
                 <span class="n">activation_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;logistic&#39;</span><span class="p">],</span>
                 <span class="n">solver_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="s1">&#39;sgd&#39;</span><span class="p">,</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">],</span>
                 <span class="n">alpha_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> 
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">optuna_n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">optuna_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span> <span class="o">=</span> <span class="n">hidden_layer_sizes_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span> <span class="o">=</span> <span class="n">learning_rate_init_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span> <span class="o">=</span> <span class="n">activation_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="o">=</span> <span class="n">solver_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span> <span class="o">=</span> <span class="n">optuna_n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span> <span class="o">=</span> <span class="n">optuna_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_MLP_._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Optuna optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="n">hidden_layer_sizes</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
        <span class="p">)</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;activation&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
        <span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;solver&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
        <span class="p">)</span>
        
        <span class="c1"># Handle learning_rate_init based on search method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">learning_rate_init</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">learning_rate_init</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle alpha based on search method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Create and train model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
            <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">learning_rate_init</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        
        <span class="c1"># Use cross-validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_MLP_.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Best hyperparameters found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">X_train</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten to 1D</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="c1"># Prepare parameter grid for GridSearchCV</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># Handle hidden_layer_sizes</span>
            <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
            
            <span class="c1"># Handle learning_rate_init</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Handle activation</span>
            <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
            
            <span class="c1"># Handle solver</span>
            <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
            
            <span class="c1"># Handle alpha</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Initialize MLPRegressor base model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            
            <span class="c1"># Grid search</span>
            <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="c1"># Prepare parameter distributions for RandomizedSearchCV</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># Handle hidden_layer_sizes</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
            
            <span class="c1"># Handle learning_rate_init</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
            
            <span class="c1"># Handle activation</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
            
            <span class="c1"># Handle solver</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
            
            <span class="c1"># Handle alpha</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span>
            
            <span class="c1"># Initialize MLPRegressor base model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            
            <span class="c1"># Randomized search</span>
            <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="c1"># Bayesian optimization with Optuna</span>
            <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We&#39;re maximizing negative MSE</span>
                <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">(</span><span class="n">n_startup_trials</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Create objective function with data</span>
            <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            
            <span class="c1"># Optimize</span>
            <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                <span class="n">objective_with_data</span><span class="p">,</span>
                <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span>
            <span class="p">)</span>
            
            <span class="c1"># Extract best parameters</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
            
            <span class="c1"># Convert Optuna&#39;s best_params to scikit-learn format</span>
            <span class="n">sklearn_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
                <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
                <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">sklearn_params</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown search_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">. Choose from &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">best_params</span></div>



<div class="viewcode-block" id="WAS_mme_MLP_.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the MLP model with injected hyperparameters.</span>

<span class="sd">        Stacks and cleans the data, uses provided best_params (or computes if None),</span>
<span class="sd">        fits the final MLP with best params, and predicts on test data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract coordinates</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten to 1D</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>


        <span class="c1"># Initialize and fit MLP with best params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
            <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten to 1D</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">)</span>

        <span class="c1"># Predict</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct the prediction array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>



    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_MLP_._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_MLP_.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_MLP_.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_MLP_.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_MLP_.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_MLP_._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>



<div class="viewcode-block" id="WAS_mme_MLP_.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP_.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the MLP model with injected hyperparameters.</span>

<span class="sd">        Stacks and cleans the data, uses provided best_params (or computes if None),</span>
<span class="sd">        fits the final MLP with best params, predicts for the target year, reverses standardization,</span>
<span class="sd">        and computes tercile probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>

        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Extract coordinates</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>

        <span class="c1"># Initialize and fit MLP with best params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
            <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">)</span>

        <span class="c1"># Predict</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct the prediction array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                 <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span>
                                             <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_MLP">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_MLP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi-Layer Perceptron (MLP) for Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a Multi-Layer Perceptron model using scikit-learn&#39;s MLPRegressor</span>
<span class="sd">    for deterministic forecasting, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    hidden_layer_sizes_range : list of tuples, optional</span>
<span class="sd">        List of hidden layer sizes to tune, e.g., [(10,), (10, 5), (20, 10)] (default).</span>
<span class="sd">    activation_options : list of str, optional</span>
<span class="sd">        Activation functions to tune (&#39;identity&#39;, &#39;logistic&#39;, &#39;tanh&#39;, &#39;relu&#39;) (default is [&#39;relu&#39;, &#39;tanh&#39;, &#39;logistic&#39;]).</span>
<span class="sd">    solver_options : list of str, optional</span>
<span class="sd">        Solvers to tune (&#39;lbfgs&#39;, &#39;sgd&#39;, &#39;adam&#39;) (default is [&#39;adam&#39;, &#39;sgd&#39;, &#39;lbfgs&#39;]).</span>
<span class="sd">    alpha_range : list of float, optional</span>
<span class="sd">        L2 regularization parameters to tune (default is [0.0001, 0.001, 0.01, 0.1]).</span>
<span class="sd">    learning_rate_init_range : list or scipy.stats distribution, optional</span>
<span class="sd">        Learning rate initialization range for random/bayesian search (default is loguniform(0.0001, 0.01)).</span>
<span class="sd">        For grid search, provide a list of values.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum iterations (default is 200).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;) (default is &#39;nonparam&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized/bayesian search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for homogenized zones (default is 4).</span>
<span class="sd">    optuna_n_jobs : int, optional</span>
<span class="sd">        Number of parallel jobs for Optuna (default is 1).</span>
<span class="sd">    optuna_timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Optuna optimization (default is None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_MLP.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">hidden_layer_sizes_range</span><span class="o">=</span><span class="p">[(</span><span class="mi">10</span><span class="p">,),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
                 <span class="n">activation_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;logistic&#39;</span><span class="p">],</span>
                 <span class="n">learning_rate_init_range</span><span class="o">=</span><span class="n">loguniform</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span>
                 <span class="n">solver_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="s1">&#39;sgd&#39;</span><span class="p">,</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">],</span>
                 <span class="n">alpha_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> 
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">optuna_n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">optuna_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span> <span class="o">=</span> <span class="n">hidden_layer_sizes_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span> <span class="o">=</span> <span class="n">learning_rate_init_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span> <span class="o">=</span> <span class="n">activation_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="o">=</span> <span class="n">solver_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span> <span class="o">=</span> <span class="n">optuna_n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span> <span class="o">=</span> <span class="n">optuna_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_MLP._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Optuna optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="n">hidden_layer_sizes</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
        <span class="p">)</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;activation&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
        <span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
            <span class="s1">&#39;solver&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
        <span class="p">)</span>
        
        <span class="c1"># Handle learning_rate_init based on search method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">learning_rate_init</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">learning_rate_init</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle alpha based on search method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Create and train model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
            <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">hidden_layer_sizes</span><span class="p">,</span>
            <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">learning_rate_init</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        
        <span class="c1"># Use cross-validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data for each homogenized zone.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params_dict : dict</span>
<span class="sd">            Best hyperparameters for each cluster.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels with dimensions (Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>
        
        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
        
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter grid for GridSearchCV</span>
                <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle hidden_layer_sizes</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
                
                <span class="c1"># Handle learning_rate_init</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Handle activation</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
                
                <span class="c1"># Handle solver</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
                
                <span class="c1"># Handle alpha</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Initialize MLPRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                
                <span class="c1"># Grid search</span>
                <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter distributions for RandomizedSearchCV</span>
                <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle hidden_layer_sizes</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_sizes_range</span>
                
                <span class="c1"># Handle learning_rate_init</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_init_range</span>
                
                <span class="c1"># Handle activation</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_options</span>
                
                <span class="c1"># Handle solver</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span>
                
                <span class="c1"># Handle alpha</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span>
                
                <span class="c1"># Initialize MLPRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                
                <span class="c1"># Randomized search</span>
                <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="c1"># Bayesian optimization with Optuna</span>
                <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                    <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We&#39;re maximizing negative MSE</span>
                    <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">(</span><span class="n">n_startup_trials</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                <span class="p">)</span>
                
                <span class="c1"># Create objective function with data</span>
                <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                
                <span class="c1"># Optimize</span>
                <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                    <span class="n">objective_with_data</span><span class="p">,</span>
                    <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span>
                <span class="p">)</span>
                
                <span class="c1"># Extract best parameters</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
                
                <span class="c1"># Convert Optuna&#39;s best_params to scikit-learn format</span>
                <span class="n">sklearn_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;learning_rate_init&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sklearn_params</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown search_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">. Choose from &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the MLP model with injected hyperparameters for each zone.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters per cluster. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standardize inputs</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">y_train</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span>
        <span class="n">y_test_std</span> <span class="o">=</span> <span class="n">y_test</span>
        
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_test_stacked_c</span> <span class="o">=</span> <span class="n">y_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            
            <span class="c1"># Initialize and fit MLP with best params for this cluster</span>
            <span class="n">mlp_c</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
                <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
                <span class="n">solver</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
            <span class="p">)</span>
            <span class="n">mlp_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlp_c</span>
            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">mlp_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_MLP._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_MLP.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_MLP.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_MLP._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows with NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_MLP.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MLP.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate deterministic and probabilistic forecast for a target year using the MLP model with injected hyperparameters.</span>
<span class="sd">        Stacks and cleans the data, uses provided best_params (or computes if None),</span>
<span class="sd">        fits the final MLP with best params, predicts for the target year, reverses standardization,</span>
<span class="sd">        and computes tercile probabilities.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="c1"># Extract coordinates</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            <span class="c1"># Initialize and fit MLP with best params for this cluster</span>
            <span class="n">mlp_c</span> <span class="o">=</span> <span class="n">MLPRegressor</span><span class="p">(</span>
                <span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;hidden_layer_sizes&#39;</span><span class="p">],</span>
                <span class="n">learning_rate_init</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;learning_rate_init&#39;</span><span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;activation&#39;</span><span class="p">],</span>
                <span class="n">solver</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
            <span class="p">)</span>
            <span class="n">mlp_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlp_c</span>
            <span class="c1"># Predict</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">mlp_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>       </div>
</div>




<div class="viewcode-block" id="WAS_mme_XGBoosting_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_XGBoosting_</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XGBoost-based Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a single-model forecasting approach using XGBoost&#39;s XGBRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    n_estimators_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of n_estimators values to tune (default is [50, 100, 200, 300]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    learning_rate_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of learning rates to tune (default is [0.01, 0.05, 0.1, 0.2]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    max_depth_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of max depths to tune (default is [3, 5, 7, 9]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    min_child_weight_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of minimum child weights to tune (default is [1, 3, 5]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    subsample_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of subsample ratios to tune (default is [0.6, 0.8, 1.0]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    colsample_bytree_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of column sampling ratios to tune (default is [0.6, 0.8, 1.0]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;, etc.) (default is &#39;nonparam&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized/bayesian search or points to sample for grid search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    optuna_n_jobs : int, optional</span>
<span class="sd">        Number of parallel jobs for Optuna (default is 1).</span>
<span class="sd">    optuna_timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Optuna optimization (default is None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_XGBoosting_.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">n_estimators_range</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>
                 <span class="n">learning_rate_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                 <span class="n">max_depth_range</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                 <span class="n">min_child_weight_range</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                 <span class="n">subsample_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                 <span class="n">colsample_bytree_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">optuna_n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">optuna_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span> <span class="o">=</span> <span class="n">n_estimators_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span> <span class="o">=</span> <span class="n">learning_rate_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span> <span class="o">=</span> <span class="n">max_depth_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span> <span class="o">=</span> <span class="n">min_child_weight_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span> <span class="o">=</span> <span class="n">subsample_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span> <span class="o">=</span> <span class="n">colsample_bytree_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span> <span class="o">=</span> <span class="n">optuna_n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span> <span class="o">=</span> <span class="n">optuna_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting_._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Optuna optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="c1"># Handle n_estimators</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle learning_rate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle max_depth</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle min_child_weight</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">min_child_weight</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">min_child_weight</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;min_child_weight&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle subsample</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;subsample&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;subsample&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle colsample_bytree</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">colsample_bytree</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">colsample_bytree</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;colsample_bytree&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Create and train model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span>
            <span class="n">learning_rate</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="n">min_child_weight</span><span class="o">=</span><span class="n">min_child_weight</span><span class="p">,</span>
            <span class="n">subsample</span><span class="o">=</span><span class="n">subsample</span><span class="p">,</span>
            <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">colsample_bytree</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="c1"># Use cross-validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting_.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Best hyperparameters found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">Predictors</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">Predictand</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="c1"># Prepare parameter grid for GridSearchCV</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># Handle n_estimators</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            
            <span class="c1"># Handle learning_rate</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Handle max_depth</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            
            <span class="c1"># Handle min_child_weight</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Handle subsample</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Handle colsample_bytree</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Sample from distribution for grid search</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            
            <span class="c1"># Initialize XGBRegressor base model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Grid search</span>
            <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="c1"># Prepare parameter distributions for RandomizedSearchCV</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># Handle n_estimators</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
            
            <span class="c1"># Handle learning_rate</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span>
            
            <span class="c1"># Handle max_depth</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
            
            <span class="c1"># Handle min_child_weight</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span>
            
            <span class="c1"># Handle subsample</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span>
            
            <span class="c1"># Handle colsample_bytree</span>
            <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span>
            
            <span class="c1"># Initialize XGBRegressor base model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Randomized search</span>
            <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="c1"># Bayesian optimization with Optuna</span>
            <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We&#39;re maximizing negative MSE</span>
                <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">(</span><span class="n">n_startup_trials</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Create objective function with data</span>
            <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            
            <span class="c1"># Optimize</span>
            <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                <span class="n">objective_with_data</span><span class="p">,</span>
                <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span>
            <span class="p">)</span>
            
            <span class="c1"># Extract best parameters</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
            
            <span class="c1"># Convert Optuna&#39;s best_params to scikit-learn format</span>
            <span class="n">sklearn_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                <span class="s1">&#39;min_child_weight&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
                <span class="s1">&#39;subsample&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
                <span class="s1">&#39;colsample_bytree&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">sklearn_params</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown search_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">. Choose from &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">best_params</span></div>



<div class="viewcode-block" id="WAS_mme_XGBoosting_.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the XGBRegressor model with injected hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize the model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
            <span class="n">learning_rate</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
            <span class="n">min_child_weight</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
            <span class="n">subsample</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
            <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">],</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Fit the model and predict on non-NaN testing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct predictions</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_XGBoosting_._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_XGBoosting_.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting_.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting_.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_XGBoosting_.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_XGBoosting_._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting_.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting_.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single XGBoost model with optimized hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="c1"># Predictor_for_year_st = (Predictor_for_year - mean_val) / std_val</span>
        
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="n">Predictor_for_year</span>

        <span class="c1"># hindcast_det_st = standardize_timeseries(hindcast_det, clim_year_start, clim_year_end)</span>
        
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">hindcast_det</span>
        
        <span class="c1"># Predictant_st = standardize_timeseries(Predictant_no_m, clim_year_start, clim_year_end)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_no_m</span>
        
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">)</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize and fit the model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
            <span class="n">learning_rate</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
            <span class="n">min_child_weight</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
            <span class="n">subsample</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
            <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">],</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct the prediction array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                 <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># result_da = reverse_standardize(result_da, Predictant_no_m, clim_year_start, clim_year_end)</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_XGBoosting">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_XGBoosting</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XGBoost-based Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a single-model forecasting approach using XGBoost&#39;s XGBRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    n_estimators_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of n_estimators values to tune (default is [50, 100, 200, 300]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    learning_rate_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of learning rates to tune (default is [0.01, 0.05, 0.1, 0.2]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    max_depth_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of max depths to tune (default is [3, 5, 7, 9]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    min_child_weight_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of minimum child weights to tune (default is [1, 3, 5]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    subsample_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of subsample ratios to tune (default is [0.6, 0.8, 1.0]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    colsample_bytree_range : list of float or scipy.stats distribution, optional</span>
<span class="sd">        List of column sampling ratios to tune (default is [0.6, 0.8, 1.0]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;, etc.) (default is &#39;nonparam&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized/bayesian search or points to sample for grid search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for homogenized zones (default is 4).</span>
<span class="sd">    optuna_n_jobs : int, optional</span>
<span class="sd">        Number of parallel jobs for Optuna (default is 1).</span>
<span class="sd">    optuna_timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Optuna optimization (default is None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_XGBoosting.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">n_estimators_range</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>
                 <span class="n">learning_rate_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                 <span class="n">max_depth_range</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                 <span class="n">min_child_weight_range</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                 <span class="n">subsample_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                 <span class="n">colsample_bytree_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">optuna_n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">optuna_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span> <span class="o">=</span> <span class="n">n_estimators_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span> <span class="o">=</span> <span class="n">learning_rate_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span> <span class="o">=</span> <span class="n">max_depth_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span> <span class="o">=</span> <span class="n">min_child_weight_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span> <span class="o">=</span> <span class="n">subsample_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span> <span class="o">=</span> <span class="n">colsample_bytree_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span> <span class="o">=</span> <span class="n">optuna_n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span> <span class="o">=</span> <span class="n">optuna_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Optuna optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="c1"># Handle n_estimators</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle learning_rate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">log</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle max_depth</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle min_child_weight</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">min_child_weight</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">min_child_weight</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;min_child_weight&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle subsample</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;subsample&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;subsample&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle colsample_bytree</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">colsample_bytree</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">colsample_bytree</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_float</span><span class="p">(</span>
                <span class="s1">&#39;colsample_bytree&#39;</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
        
        <span class="c1"># Create and train model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span>
            <span class="n">learning_rate</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="n">min_child_weight</span><span class="o">=</span><span class="n">min_child_weight</span><span class="p">,</span>
            <span class="n">subsample</span><span class="o">=</span><span class="n">subsample</span><span class="p">,</span>
            <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">colsample_bytree</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="c1"># Use cross-validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data for each homogenized zone.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params_dict : dict</span>
<span class="sd">            Best hyperparameters for each cluster.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels with dimensions (Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">Predictors</span>
        
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>
        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
        
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">Predictand</span>
        
        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter grid for GridSearchCV</span>
                <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle n_estimators</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                
                <span class="c1"># Handle learning_rate</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Handle max_depth</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                
                <span class="c1"># Handle min_child_weight</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Handle subsample</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Handle colsample_bytree</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                
                <span class="c1"># Initialize XGBRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Grid search</span>
                <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter distributions for RandomizedSearchCV</span>
                <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle n_estimators</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
                
                <span class="c1"># Handle learning_rate</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate_range</span>
                
                <span class="c1"># Handle max_depth</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
                
                <span class="c1"># Handle min_child_weight</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_child_weight_range</span>
                
                <span class="c1"># Handle subsample</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsample_range</span>
                
                <span class="c1"># Handle colsample_bytree</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colsample_bytree_range</span>
                
                <span class="c1"># Initialize XGBRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Randomized search</span>
                <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="c1"># Bayesian optimization with Optuna</span>
                <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                    <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We&#39;re maximizing negative MSE</span>
                    <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">(</span><span class="n">n_startup_trials</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                <span class="p">)</span>
                
                <span class="c1"># Create objective function with data</span>
                <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                
                <span class="c1"># Optimize</span>
                <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                    <span class="n">objective_with_data</span><span class="p">,</span>
                    <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span>
                <span class="p">)</span>
                
                <span class="c1"># Extract best parameters</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
                
                <span class="c1"># Convert Optuna&#39;s best_params to scikit-learn format</span>
                <span class="n">sklearn_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;min_child_weight&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;subsample&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;colsample_bytree&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sklearn_params</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown search_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">. Choose from &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>



<div class="viewcode-block" id="WAS_mme_XGBoosting.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the XGBRegressor model with injected hyperparameters for each zone.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters per cluster. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standardize inputs</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">y_train</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span>
        <span class="n">y_test_std</span> <span class="o">=</span> <span class="n">y_test</span>
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_test_stacked_c</span> <span class="o">=</span> <span class="n">y_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            <span class="c1"># Initialize the model with best parameters for this cluster</span>
            <span class="n">xgb_c</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                <span class="n">learning_rate</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                <span class="n">min_child_weight</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
                <span class="n">subsample</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
                <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">],</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="c1"># Fit and predict</span>
            <span class="n">xgb_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">xgb_c</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">xgb_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_XGBoosting._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_XGBoosting.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_XGBoosting.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_XGBoosting._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_XGBoosting.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_XGBoosting.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single XGBoost model with optimized hyperparameters.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="c1"># Predictor_for_year_st = (Predictor_for_year - mean_val) / std_val</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="n">Predictor_for_year</span>
        <span class="c1"># hindcast_det_st = standardize_timeseries(hindcast_det, clim_year_start, clim_year_end)</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">hindcast_det</span>
        <span class="c1"># Predictant_st = standardize_timeseries(Predictant_no_m, clim_year_start, clim_year_end)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_no_m</span>
        <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            <span class="c1"># Initialize the model with best parameters for this cluster</span>
            <span class="n">xgb_c</span> <span class="o">=</span> <span class="n">XGBRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                <span class="n">learning_rate</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">],</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                <span class="n">min_child_weight</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_child_weight&#39;</span><span class="p">],</span>
                <span class="n">subsample</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;subsample&#39;</span><span class="p">],</span>
                <span class="n">colsample_bytree</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;colsample_bytree&#39;</span><span class="p">],</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="c1"># Fit and predict</span>
            <span class="n">xgb_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xgb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">xgb_c</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">xgb_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        
        <span class="c1"># result_da = reverse_standardize(result_da, Predictant_no_m, clim_year_start, clim_year_end)</span>
        
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_RF_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_RF_</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random Forest-based Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a single-model forecasting approach using scikit-learn&#39;s RandomForestRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_estimators_range : list of int, optional</span>
<span class="sd">        List of n_estimators values to tune (default is [50, 100, 200, 300]).</span>
<span class="sd">    max_depth_range : list of int, optional</span>
<span class="sd">        List of max depths to tune (default is [None, 10, 20, 30]).</span>
<span class="sd">    min_samples_split_range : list of int, optional</span>
<span class="sd">        List of minimum samples required to split to tune (default is [2, 5, 10]).</span>
<span class="sd">    min_samples_leaf_range : list of int, optional</span>
<span class="sd">        List of minimum samples required at leaf node to tune (default is [1, 2, 4]).</span>
<span class="sd">    max_features_range : list of str or float, optional</span>
<span class="sd">        List of max features to tune (default is [None, &#39;sqrt&#39;, 0.33, 0.5]).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;, etc.) (default is &#39;nonparam&#39;).</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;random&#39; (RandomizedSearchCV), </span>
<span class="sd">        &#39;grid&#39; (GridSearchCV), or &#39;bayesian&#39; (Optuna) (default is &#39;random&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized search (default is 10).</span>
<span class="sd">    n_trials : int, optional</span>
<span class="sd">        Number of trials for Bayesian optimization with Optuna (default is 100).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_RF_.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_estimators_range</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>
                 <span class="n">max_depth_range</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
                 <span class="n">min_samples_split_range</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                 <span class="n">min_samples_leaf_range</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                 <span class="n">max_features_range</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span> <span class="p">,</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">n_trials</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span> <span class="o">=</span> <span class="n">n_estimators_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span> <span class="o">=</span> <span class="n">max_depth_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span> <span class="o">=</span> <span class="n">min_samples_split_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span> <span class="o">=</span> <span class="n">min_samples_leaf_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span> <span class="o">=</span> <span class="n">max_features_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span> <span class="o">=</span> <span class="n">n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Store best parameters found</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Store Optuna study</span></div>


<div class="viewcode-block" id="WAS_mme_RF_._prepare_param_distributions">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_._prepare_param_distributions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_param_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare parameter distributions for different search methods.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="c1"># For GridSearch, we need all combinations</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span>
                <span class="s1">&#39;min_samples_split&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">,</span>
                <span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">,</span>
                <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">param_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For random search and bayesian, we can use distributions</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span>
                <span class="s1">&#39;min_samples_split&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">,</span>
                <span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">,</span>
                <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">param_dist</span></div>


<div class="viewcode-block" id="WAS_mme_RF_._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Objective function for Bayesian optimization with Optuna.&quot;&quot;&quot;</span>
        <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">)</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">)</span>
        <span class="n">min_samples_split</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">)</span>
        <span class="n">min_samples_leaf</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">)</span>
        <span class="n">max_features</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_features&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span><span class="p">)</span>
        
        <span class="c1"># Handle &#39;None&#39; and &#39;sqrt&#39; for max_features</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">max_features</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_features</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">max_features</span> <span class="o">==</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span>
                <span class="n">max_features</span> <span class="o">=</span> <span class="s1">&#39;sqrt&#39;</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="n">min_samples_split</span><span class="o">=</span><span class="n">min_samples_split</span><span class="p">,</span>
            <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">min_samples_leaf</span><span class="p">,</span>
            <span class="n">max_features</span><span class="o">=</span><span class="n">max_features</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="c1"># Simple cross-validation (could be improved with sklearn&#39;s cross_val_score)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">KFold</span>
        <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">kf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_train</span><span class="p">):</span>
            <span class="n">X_train_fold</span><span class="p">,</span> <span class="n">X_val_fold</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">X_train</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            <span class="n">y_train_fold</span><span class="p">,</span> <span class="n">y_val_fold</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">y_train</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>
            
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_fold</span><span class="p">,</span> <span class="n">y_train_fold</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_val_fold</span><span class="p">)</span>
            <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y_val_fold</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">mse</span><span class="p">)</span>  <span class="c1"># Negative MSE for maximization</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_RF_.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Best hyperparameters found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">Predictors</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">Predictand</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Initialize base model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="c1"># Grid Search</span>
            <span class="n">param_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_param_distributions</span><span class="p">()</span>
            <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_params_</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
            <span class="c1"># Bayesian Optimization with Optuna</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>
                <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span>
            <span class="p">)</span>
            
            <span class="c1"># Create objective function with data</span>
            <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">study_</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective_with_data</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trials</span><span class="p">)</span>
            
            <span class="c1"># Get best parameters</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_</span><span class="o">.</span><span class="n">best_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_params_</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Default to random search</span>
            <span class="c1"># Random Search (default)</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_param_distributions</span><span class="p">()</span>
            <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
            <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_params_</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="k">return</span> <span class="n">best_params</span></div>


<div class="viewcode-block" id="WAS_mme_RF_.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the RandomForestRegressor model with injected hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize the model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
            <span class="n">min_samples_split</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">],</span>
            <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">],</span>
            <span class="n">max_features</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">],</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Fit the model and predict on non-NaN testing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct predictions</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_RF_._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_RF_.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_RF_.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_RF_.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_RF_.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_RF_._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_RF_.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF_.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single Random Forest model with optimized hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="c1"># Predictor_for_year_st = (Predictor_for_year - mean_val) / std_val</span>

        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="n">Predictor_for_year</span>

        <span class="c1"># hindcast_det_st = standardize_timeseries(hindcast_det, clim_year_start, clim_year_end)</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">hindcast_det</span>
        
        <span class="c1"># Predictant_st = standardize_timeseries(Predictant_no_m, clim_year_start, clim_year_end)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_no_m</span>
        
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>

        <span class="c1"># Stack training data and remove rows with NaNs</span>
        <span class="n">X_train_stacked</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_train_stacked</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked</span><span class="p">)</span>
        <span class="n">X_train_clean</span> <span class="o">=</span> <span class="n">X_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
        <span class="n">y_train_clean</span> <span class="o">=</span> <span class="n">y_train_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>

        <span class="c1"># Stack testing data</span>
        <span class="n">X_test_stacked</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_test_stacked</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">)</span>

        <span class="c1"># Use provided best_params or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Initialize and fit the model with best parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
            <span class="n">min_samples_split</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">],</span>
            <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">],</span>
            <span class="n">max_features</span><span class="o">=</span><span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">],</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean</span><span class="p">,</span> <span class="n">y_train_clean</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_stacked</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">])</span>

        <span class="c1"># Reconstruct the prediction array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_test_stacked</span><span class="p">[</span><span class="n">test_nan_mask</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">test_nan_mask</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y_pred</span>

        <span class="n">predictions_reshaped</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">predictions_reshaped</span><span class="p">,</span>
                                 <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># result_da = reverse_standardize(result_da, Predictant_no_m, clim_year_start, clim_year_end)</span>
        
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>

        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="WAS_mme_RF">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_RF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random Forest-based Multi-Model Ensemble (MME) forecasting.</span>
<span class="sd">    This class implements a single-model forecasting approach using scikit-learn&#39;s RandomForestRegressor</span>
<span class="sd">    for deterministic predictions, with optional tercile probability calculations using</span>
<span class="sd">    various statistical distributions. Implements multiple hyperparameter optimization methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    search_method : str, optional</span>
<span class="sd">        Hyperparameter optimization method: &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39; (default: &#39;random&#39;).</span>
<span class="sd">    n_estimators_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of n_estimators values to tune (default is [50, 100, 200, 300]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    max_depth_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of max depths to tune (default is [None, 10, 20, 30]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    min_samples_split_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of minimum samples required to split to tune (default is [2, 5, 10]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    min_samples_leaf_range : list of int or scipy.stats distribution, optional</span>
<span class="sd">        List of minimum samples required at leaf node to tune (default is [1, 2, 4]).</span>
<span class="sd">        Can be a list for grid search or a distribution for random/bayesian search.</span>
<span class="sd">    max_features_range : list of str or float, optional</span>
<span class="sd">        List of max features to tune (default is [None, &#39;sqrt&#39;, 0.33, 0.5]).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Seed for reproducibility (default is 42).</span>
<span class="sd">    dist_method : str, optional</span>
<span class="sd">        Distribution method for tercile probabilities (&#39;bestfit&#39;, &#39;nonparam&#39;, etc.) (default is &#39;nonparam&#39;).</span>
<span class="sd">    n_iter_search : int, optional</span>
<span class="sd">        Number of iterations for randomized/bayesian search or points to sample for grid search (default is 10).</span>
<span class="sd">    cv_folds : int, optional</span>
<span class="sd">        Number of cross-validation folds (default is 3).</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for homogenized zones (default is 4).</span>
<span class="sd">    optuna_n_jobs : int, optional</span>
<span class="sd">        Number of parallel jobs for Optuna (default is 1).</span>
<span class="sd">    optuna_timeout : int, optional</span>
<span class="sd">        Timeout in seconds for Optuna optimization (default is None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WAS_mme_RF.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">n_estimators_range</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>
                 <span class="n">max_depth_range</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
                 <span class="n">min_samples_split_range</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                 <span class="n">min_samples_leaf_range</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                 <span class="n">max_features_range</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">,</span>  <span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>
                 <span class="n">n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">optuna_n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">optuna_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">=</span> <span class="n">search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span> <span class="o">=</span> <span class="n">n_estimators_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span> <span class="o">=</span> <span class="n">max_depth_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span> <span class="o">=</span> <span class="n">min_samples_split_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span> <span class="o">=</span> <span class="n">min_samples_leaf_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span> <span class="o">=</span> <span class="n">max_features_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span> <span class="o">=</span> <span class="n">n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span> <span class="o">=</span> <span class="n">cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span> <span class="o">=</span> <span class="n">optuna_n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span> <span class="o">=</span> <span class="n">optuna_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_mme_RF._objective">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF._objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Optuna optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define hyperparameter search space</span>
        <span class="c1"># Handle n_estimators</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;n_estimators&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle max_depth</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">max_depth_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
            <span class="c1"># Convert None to string for Optuna categorical suggestion</span>
            <span class="n">max_depth_str_options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="k">if</span> <span class="n">opt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">opt</span> <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">max_depth_options</span><span class="p">]</span>
            <span class="n">max_depth_str</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> <span class="n">max_depth_str_options</span><span class="p">)</span>
            <span class="c1"># Convert back to None if needed</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">max_depth_str</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_depth_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution for depth values (excluding None)</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span><span class="s1">&#39;max_depth&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        
        <span class="c1"># Handle min_samples_split</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">min_samples_split</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">min_samples_split</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;min_samples_split&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle min_samples_leaf</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">min_samples_leaf</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume it&#39;s a distribution</span>
            <span class="n">min_samples_leaf</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_int</span><span class="p">(</span>
                <span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">,</span> 
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="o">.</span><span class="n">a</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># Handle max_features</span>
        <span class="c1"># For Optuna, we need to handle both string and float options</span>
        <span class="n">max_features_options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">max_features_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_features_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="p">))</span>
        
        <span class="n">max_features_str</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;max_features&#39;</span><span class="p">,</span> <span class="n">max_features_options</span><span class="p">)</span>
        
        <span class="c1"># Convert back to appropriate type</span>
        <span class="k">if</span> <span class="n">max_features_str</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">]:</span>
            <span class="n">max_features</span> <span class="o">=</span> <span class="n">max_features_str</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_features</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_features_str</span><span class="p">)</span>
        
        <span class="c1"># Create and train model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
            <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="n">min_samples_split</span><span class="o">=</span><span class="n">min_samples_split</span><span class="p">,</span>
            <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">min_samples_leaf</span><span class="p">,</span>
            <span class="n">max_features</span><span class="o">=</span><span class="n">max_features</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="c1"># Use cross-validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> 
            <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_RF.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Independently computes the best hyperparameters using selected optimization method</span>
<span class="sd">        on stacked training data for each homogenized zone.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictors : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        Predictand : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params_dict : dict</span>
<span class="sd">            Best hyperparameters for each cluster.</span>
<span class="sd">        cluster_da : xarray.DataArray</span>
<span class="sd">            Cluster labels with dimensions (Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">Predictors</span>
        <span class="n">Predictand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;varname&quot;</span>
        
        <span class="c1"># Step 1: Perform KMeans clustering based on predictand&#39;s spatial distribution</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">Predictand_dropna</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
        <span class="n">variable_column</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Predictand_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
            <span class="n">Predictand_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert cluster assignments back into an xarray structure</span>
        <span class="n">df_unique</span> <span class="o">=</span> <span class="n">Predictand_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
        
        <span class="c1"># Align cluster array with the predictand array</span>
        <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">Predictand</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify unique cluster labels</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">Predictand</span>
        <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        
        <span class="n">best_params_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">y_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">X_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">nan_mask_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_stacked_c</span><span class="p">)</span>
            <span class="n">X_clean_c</span> <span class="o">=</span> <span class="n">X_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            <span class="n">y_clean_c</span> <span class="o">=</span> <span class="n">y_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_c</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter grid for GridSearchCV</span>
                <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle n_estimators</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                
                <span class="c1"># Handle max_depth</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="c1"># Filter out None values and convert to int</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">samples</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">unique_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                    <span class="c1"># Add None option back if it was in the original range</span>
                    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span><span class="p">:</span>
                        <span class="n">unique_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_samples</span><span class="p">)</span>
                        <span class="n">unique_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_samples</span>
                
                <span class="c1"># Handle min_samples_split</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                
                <span class="c1"># Handle min_samples_leaf</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Sample from distribution for grid search</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                
                <span class="c1"># Handle max_features</span>
                <span class="n">param_grid</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span>
                
                <span class="c1"># Initialize RandomForestRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Grid search</span>
                <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="c1"># Prepare parameter distributions for RandomizedSearchCV</span>
                <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="c1"># Handle n_estimators</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_estimators_range</span>
                
                <span class="c1"># Handle max_depth</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth_range</span>
                
                <span class="c1"># Handle min_samples_split</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_split_range</span>
                
                <span class="c1"># Handle min_samples_leaf</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples_leaf_range</span>
                
                <span class="c1"># Handle max_features</span>
                <span class="n">param_dist</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_features_range</span>
                
                <span class="c1"># Initialize RandomForestRegressor base model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Randomized search</span>
                <span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_search</span><span class="o">.</span><span class="n">best_params_</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;bayesian&#39;</span><span class="p">:</span>
                <span class="c1"># Bayesian optimization with Optuna</span>
                <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                    <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;maximize&#39;</span><span class="p">,</span>  <span class="c1"># We&#39;re maximizing negative MSE</span>
                    <span class="n">sampler</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">pruner</span><span class="o">=</span><span class="n">optuna</span><span class="o">.</span><span class="n">pruners</span><span class="o">.</span><span class="n">MedianPruner</span><span class="p">(</span><span class="n">n_startup_trials</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                <span class="p">)</span>
                
                <span class="c1"># Create objective function with data</span>
                <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">X_clean_c</span><span class="p">,</span> <span class="n">y_clean_c</span><span class="p">)</span>
                
                <span class="c1"># Optimize</span>
                <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
                    <span class="n">objective_with_data</span><span class="p">,</span>
                    <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_search</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_timeout</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optuna_n_jobs</span>
                <span class="p">)</span>
                
                <span class="c1"># Extract best parameters</span>
                <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
                
                <span class="c1"># Convert Optuna&#39;s best_params to scikit-learn format</span>
                <span class="c1"># Handle max_depth conversion</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span>
                
                <span class="c1"># Convert max_features back to appropriate type</span>
                <span class="n">max_features_str</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">max_features_str</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">]:</span>
                    <span class="n">max_features</span> <span class="o">=</span> <span class="n">max_features_str</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_features</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_features_str</span><span class="p">)</span>
                
                <span class="n">sklearn_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="n">max_depth</span><span class="p">,</span>
                    <span class="s1">&#39;min_samples_split&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">:</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="n">max_features</span>
                <span class="p">}</span>
                <span class="n">best_params_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sklearn_params</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown search_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_method</span><span class="si">}</span><span class="s2">. Choose from &#39;grid&#39;, &#39;random&#39;, or &#39;bayesian&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">best_params_dict</span><span class="p">,</span> <span class="n">cluster_da</span></div>



<div class="viewcode-block" id="WAS_mme_RF.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute deterministic hindcast using the RandomForestRegressor model with injected hyperparameters for each zone.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : xarray.DataArray</span>
<span class="sd">            Training predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_train : xarray.DataArray</span>
<span class="sd">            Training predictand data with dimensions (T, Y, X).</span>
<span class="sd">        X_test : xarray.DataArray</span>
<span class="sd">            Testing predictor data with dimensions (T, M, Y, X).</span>
<span class="sd">        y_test : xarray.DataArray</span>
<span class="sd">            Testing predictand data with dimensions (T, Y, X).</span>
<span class="sd">        clim_year_start : int</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters per cluster. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predicted_da : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast with dimensions (T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standardize inputs</span>
        <span class="n">X_train_std</span> <span class="o">=</span> <span class="n">X_train</span>
        <span class="n">y_train_std</span> <span class="o">=</span> <span class="n">y_train</span>
        <span class="n">X_test_std</span> <span class="o">=</span> <span class="n">X_test</span>
        <span class="n">y_test_std</span> <span class="o">=</span> <span class="n">y_test</span>
        <span class="c1"># Extract coordinate variables from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_train_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">X_test_std</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">X_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">y_train_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">X_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_test_stacked_c</span> <span class="o">=</span> <span class="n">y_test_std</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            <span class="c1"># Initialize the model with best parameters for this cluster</span>
            <span class="n">rf_c</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                <span class="n">min_samples_split</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">],</span>
                <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">],</span>
                <span class="n">max_features</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">],</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="c1"># Fit and predict</span>
            <span class="n">rf_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">rf_c</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">rf_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability Calculation Methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_RF._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tercile thresholds (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    </span>
<span class="sd">        dist_code:</span>
<span class="sd">            1: norm</span>
<span class="sd">            2: lognorm</span>
<span class="sd">            3: expon</span>
<span class="sd">            4: gamma</span>
<span class="sd">            5: weibull_min</span>
<span class="sd">            6: t</span>
<span class="sd">            7: poisson</span>
<span class="sd">            8: nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="c1"># Note: Renamed &#39;t_dist&#39; to &#39;t&#39; for standard scipy.stats</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="c1"># Poisson: poisson.ppf(q, mu, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;mu&#39; (mean) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="c1">#             &#39;scale&#39; is unused</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="c1"># Negative Binomial: nbinom.ppf(q, n, p, loc=0)</span>
                <span class="c1"># ASSUMPTION: &#39;n&#39; (successes) is passed as &#39;shape&#39;</span>
                <span class="c1">#             &#39;p&#39; (probability) is passed as &#39;scale&#39;</span>
                <span class="c1">#             &#39;loc&#39; is passed as &#39;loc&#39;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                    <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
        <span class="c1"># Fallback if code is not 1-8</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

        
<div class="viewcode-block" id="WAS_mme_RF.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find the root of the Weibull shape parameter &#39;k&#39;.</span>
<span class="sd">        We find &#39;k&#39; such that the theoretical variance/mean^2 ratio</span>
<span class="sd">        matches the observed V/M^2 ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Guard against invalid &#39;k&#39; values during solving</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
            
            <span class="c1"># This is the V/M^2 ratio *implied by k*</span>
            <span class="n">implied_v_over_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># This is the *observed* ratio</span>
            <span class="n">observed_v_over_m_sq</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Return the difference (we want this to be 0)</span>
            <span class="k">return</span> <span class="n">observed_v_over_m_sq</span> <span class="o">-</span> <span class="n">implied_v_over_m_sq</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># Handle math errors</span></div>


<div class="viewcode-block" id="WAS_mme_RF.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span> 
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>

<span class="sd">        Inputs (per grid cell):</span>
<span class="sd">        - best_guess : 1D array over T (hindcast_det or forecast_det)</span>
<span class="sd">        - T1, T2     : scalar terciles from climatological best-fit distribution</span>
<span class="sd">        - dist_code  : int, as in _ppf_terciles_from_code</span>
<span class="sd">        - shape, loc, scale : scalars from climatology fit</span>

<span class="sd">        Strategy:</span>
<span class="sd">        - For each time step, build a predictive distribution of the same family:</span>
<span class="sd">            * Use best_guess[t] to adjust mean / location;</span>
<span class="sd">            * Keep shape parameters from climatology.</span>
<span class="sd">        - Then compute probabilities:</span>
<span class="sd">            P(B) = F(T1), P(N) = F(T2) - F(T1), P(A) = 1 - F(T2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># T1 = np.asarray(T1, dtype=float)</span>
        <span class="c1"># T2 = np.asarray(T2, dtype=float)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal: loc = forecast; scale from clim</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">error_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">error_std</span><span class="p">)</span>

        <span class="c1"># Lognormal: shape = sigma from clim; enforce mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>      


        <span class="c1"># Exponential: keep scale from clim; shift loc so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma: use shape from clim; set scale so mean = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">best_guess</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Assuming 5 is for Weibull   </span>
        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get the scalar values for this specific element (e.g., grid cell)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                
                <span class="c1"># Handle cases with no variance to avoid division by zero</span>
                <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span> <span class="c1"># Skip to the next element</span>
        
                <span class="c1"># --- 1. Numerically solve for shape &#39;k&#39; ---</span>
                <span class="c1"># We need a reasonable starting guess. 2.0 is common (Rayleigh dist.)</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
                
                <span class="c1"># fsolve finds the root of our helper function</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
                <span class="c1"># --- 2. Check for bad solution and calculate scale &#39;lambda&#39; ---</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Solver failed</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                
                <span class="c1"># With &#39;k&#39; found, we can now algebraically find scale &#39;lambda&#39;</span>
                <span class="c1"># In scipy.stats, scale is &#39;scale&#39;</span>
                <span class="n">lambda_scale</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        
                <span class="c1"># --- 3. Calculate Probabilities ---</span>
                <span class="c1"># In scipy.stats, shape &#39;k&#39; is &#39;c&#39;</span>
                <span class="c1"># Use the T1 and T2 values for this specific element</span>
                
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lambda_scale</span><span class="p">)</span>
        
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t: df from clim; scale from clim; loc = best_guess</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>       
            <span class="c1"># Check if df is valid for variance calculation</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Cannot calculate scale, fill with NaNs</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1. Calculate t-distribution parameters</span>
                <span class="c1"># &#39;loc&#39; (mean) is just the best_guess</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span>
                <span class="c1"># &#39;scale&#39; is calculated from the variance and df</span>
                <span class="c1"># Variance = scale**2 * (df / (df - 2))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
                
                <span class="c1"># 2. Calculate probabilities</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># Assuming 7 is for Poisson</span>
            
            <span class="c1"># --- 1. Set the Poisson parameter &#39;mu&#39; ---</span>
            <span class="c1"># The &#39;mu&#39; parameter is the mean.</span>
            
            <span class="c1"># A warning is strongly recommended if error_variance is different from best_guess</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;error_variance&#39; is not equal to &#39;best_guess&#39;.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Poisson model assumes mean=variance and is likely inappropriate.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider using Negative Binomial.&quot;</span><span class="p">)</span>
            
            <span class="n">mu</span> <span class="o">=</span> <span class="n">best_guess</span>
        
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># poisson.cdf(k, mu) calculates P(X &lt;= k)</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># Assuming 8 is for Negative Binomial</span>
            
            <span class="c1"># --- 1. Calculate Negative Binomial Parameters ---</span>
            <span class="c1"># This model is ONLY valid for overdispersion (Variance &gt; Mean).</span>
            <span class="c1"># We will use np.where to set parameters to NaN if V &lt;= M.</span>
            
            <span class="c1"># p = Mean / Variance</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># n = Mean^2 / (Variance - Mean)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span> 
                         <span class="p">(</span><span class="n">best_guess</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
            <span class="c1"># --- 2. Calculate Probabilities ---</span>
            <span class="c1"># The nbinom.cdf function will propagate NaNs, correctly</span>
            <span class="c1"># handling the cases where the model was invalid.</span>
            
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distribution&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_RF.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
            <span class="n">pred_prob</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>




<div class="viewcode-block" id="WAS_mme_RF.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">            - Use cluster-based best-fit distributions to:</span>
<span class="sd">                * derive terciles analytically from (best_code_da, best_shape_da, best_loc_da, best_scale_da),</span>
<span class="sd">                * compute predictive probabilities using the same family.</span>

<span class="sd">        Otherwise:</span>
<span class="sd">            - Use empirical terciles from Predictant climatology and the selected</span>
<span class="sd">              parametric / nonparametric method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed data (T, Y, X) or (T, Y, X, M).</span>
<span class="sd">        clim_year_start, clim_year_end : int or str</span>
<span class="sd">            Climatology period (inclusive) for thresholds.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast (T, Y, X).</span>
<span class="sd">        best_code_da, best_shape_da, best_loc_da, best_scale_da : xarray.DataArray, optional</span>
<span class="sd">            Output from WAS_TransformData.fit_best_distribution_grid, required for &#39;bestfit&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hindcast_prob : xarray.DataArray</span>
<span class="sd">            Probabilities with dims (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Ensure dimension order</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Spatial mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Climatology subset</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># Error variance for predictive distributions</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Empirical terciles (used by non-bestfit methods)</span>
        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT: zone-wise optimal distributions ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># T1, T2 from best-fit distributions (per grid)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Predictive probabilities using same family</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_mme_RF._reshape_and_filter_data">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF._reshape_and_filter_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reshape_and_filter_data</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper: stack the DataArray from (T, Y, X[, M]) to (n_samples, n_features)</span>
<span class="sd">        and remove rows containing NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_stacked</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
        <span class="n">da_values</span> <span class="o">=</span> <span class="n">da_stacked</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">da_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_values</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">],</span> <span class="n">nan_mask</span><span class="p">,</span> <span class="n">da_values</span></div>


<div class="viewcode-block" id="WAS_mme_RF.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_RF.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">,</span> <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">hindcast_det_cross</span><span class="p">,</span> <span class="n">Predictor_for_year</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forecast method using a single Random Forest model with optimized hyperparameters.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Predictant : xarray.DataArray</span>
<span class="sd">            Observed predictand data with dimensions (T, Y, X) or (T, M, Y, X).</span>
<span class="sd">        clim_year_start : int or str</span>
<span class="sd">            Start year of the climatology period.</span>
<span class="sd">        clim_year_end : int or str</span>
<span class="sd">            End year of the climatology period.</span>
<span class="sd">        hindcast_det : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for training with dimensions (T, M, Y, X).</span>
<span class="sd">        hindcast_det_cross : xarray.DataArray</span>
<span class="sd">            Deterministic hindcast data for error estimation with dimensions (T, Y, X).</span>
<span class="sd">        Predictor_for_year : xarray.DataArray</span>
<span class="sd">            Predictor data for the target year with dimensions (T, M, Y, X).</span>
<span class="sd">        best_params : dict, optional</span>
<span class="sd">            Pre-computed best hyperparameters. If None, computes internally.</span>
<span class="sd">        cluster_da : xarray.DataArray, optional</span>
<span class="sd">            Pre-computed cluster labels. If None, computes internally.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast_det : xarray.DataArray</span>
<span class="sd">            Deterministic forecast with dimensions (T, Y, X).</span>
<span class="sd">        forecast_prob : xarray.DataArray</span>
<span class="sd">            Tercile probabilities with dimensions (probability, T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s1">&#39;T&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Standardize Predictor_for_year using hindcast climatology</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="c1"># Predictor_for_year_st = (Predictor_for_year - mean_val) / std_val</span>
        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="n">Predictor_for_year</span>
        <span class="c1"># hindcast_det_st = standardize_timeseries(hindcast_det, clim_year_start, clim_year_end)</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">hindcast_det</span>
        <span class="c1"># Predictant_st = standardize_timeseries(Predictant_no_m, clim_year_start, clim_year_end)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">Predictant_no_m</span>
        <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="c1"># Extract coordinates from X_test</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">n_lat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="c1"># Use provided best_params and cluster_da or compute if None</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="c1"># Initialize predictions array</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store models per cluster</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_params</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># Mask for this cluster</span>
            <span class="n">mask_3d_train</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="n">mask_3d_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
            <span class="c1"># Stack training data for cluster</span>
            <span class="n">X_train_stacked_c</span> <span class="o">=</span> <span class="n">hindcast_det_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_train_stacked_c</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_train</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">train_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_train_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_train_stacked_c</span><span class="p">)</span>
            <span class="n">X_train_clean_c</span> <span class="o">=</span> <span class="n">X_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="n">y_train_clean_c</span> <span class="o">=</span> <span class="n">y_train_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">train_nan_mask</span><span class="p">]</span>
            <span class="c1"># Stack testing data for cluster</span>
            <span class="n">X_test_stacked_c</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d_test</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">test_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">X_test_clean_c</span> <span class="o">=</span> <span class="n">X_test_stacked_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span>
            <span class="c1"># Initialize the model with best parameters for this cluster</span>
            <span class="n">rf_c</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">],</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">],</span>
                <span class="n">min_samples_split</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_samples_split&#39;</span><span class="p">],</span>
                <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;min_samples_leaf&#39;</span><span class="p">],</span>
                <span class="n">max_features</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;max_features&#39;</span><span class="p">],</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="c1"># Fit and predict</span>
            <span class="n">rf_c</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_clean_c</span><span class="p">,</span> <span class="n">y_train_clean_c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">rf_c</span>
            <span class="n">y_pred_c</span> <span class="o">=</span> <span class="n">rf_c</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_clean_c</span><span class="p">)</span>
            <span class="c1"># Reconstruct predictions for this cluster</span>
            <span class="n">result_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_test_stacked_c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">result_c</span><span class="p">[</span><span class="o">~</span><span class="n">test_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_c</span>
            <span class="n">pred_c_reshaped</span> <span class="o">=</span> <span class="n">result_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
            <span class="c1"># Fill in the predictions array</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_c_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="c1"># result_da = reverse_standardize(result_da, Predictant_no_m, clim_year_start, clim_year_end)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">T_value_1</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="n">T_value_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[M]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
        <span class="c1"># Compute tercile probabilities</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="c1"># ---------- BESTFIT ----------</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># ---------- Nonparametric ----------</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                    <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="WAS_mme_Stacking">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_Stacking</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble for Multi-Model Ensemble (MME) forecasting.</span>

<span class="sd">    Base models (fixed in this implementation):</span>
<span class="sd">        - WAS_mme_hpELM</span>
<span class="sd">        - WAS_mme_MLP</span>
<span class="sd">        - WAS_mme_XGBoosting</span>
<span class="sd">        - WAS_mme_RF</span>

<span class="sd">    Each base model is expected to expose:</span>
<span class="sd">        * compute_hyperparameters(Predictors, Predictand, clim_year_start, clim_year_end)</span>
<span class="sd">            -&gt; (best_params_per_cluster: dict[int, dict], cluster_da: xr.DataArray[Y,X])</span>
<span class="sd">        * compute_model(X_train, y_train, X_test, y_test,</span>
<span class="sd">                        best_params=best_params_per_cluster,</span>
<span class="sd">                        cluster_da=cluster_da)</span>
<span class="sd">            -&gt; xr.DataArray[T,Y,X] deterministic predictions</span>

<span class="sd">    This class:</span>
<span class="sd">        1) Computes/uses hyperparameters for each base &amp; cluster.</span>
<span class="sd">        2) Builds out-of-fold (OOF) predictions per base on training data.</span>
<span class="sd">        3) Trains a meta-learner separately for each cluster.</span>
<span class="sd">        4) For new data (hindcast test or forecast), predicts via:</span>
<span class="sd">              meta( base_1_pred, base_2_pred, base_3_pred, base_4_pred )</span>
<span class="sd">        5) Provides tercile probabilities via compute_prob / forecast.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># Constructor</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">meta_learner_type</span><span class="o">=</span><span class="s1">&#39;ridge&#39;</span><span class="p">,</span>      <span class="c1"># &#39;ridge&#39;, &#39;lasso&#39;, &#39;elasticnet&#39;, &#39;linear&#39;</span>
                 <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">l1_ratio_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>         <span class="c1"># &#39;nonparam&#39; or &#39;bestfit&#39;</span>
                 <span class="n">stacking_cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">meta_search_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>    <span class="c1"># &#39;grid&#39;, &#39;random&#39;, &#39;bayesian&#39;</span>
                 <span class="n">meta_cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">meta_n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">meta_n_trials</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>              <span class="c1"># For Bayesian optimization</span>
                 <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">l1_ratio_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">=</span> <span class="n">meta_learner_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="n">l1_ratio_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_cv</span> <span class="o">=</span> <span class="n">stacking_cv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">=</span> <span class="n">meta_search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span> <span class="o">=</span> <span class="n">meta_cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span> <span class="o">=</span> <span class="n">meta_n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_n_trials</span> <span class="o">=</span> <span class="n">meta_n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>

        <span class="c1"># Instantiate base models with consistent config</span>
        <span class="c1"># Note: You&#39;ll need to import these classes or adjust as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">WAS_mme_hpELM</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                          <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">,</span>
                          <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">),</span>
            <span class="n">WAS_mme_MLP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">,</span>
                        <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">),</span>
            <span class="n">WAS_mme_XGBoosting</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                               <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">,</span>
                               <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">),</span>
            <span class="n">WAS_mme_RF</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                       <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">,</span>
                       <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="c1"># Learned attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># list[dict], one dict per base: {cluster_id -&gt; params}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="kc">None</span>         <span class="c1"># xr.DataArray[Y,X], int cluster labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span> <span class="o">=</span> <span class="p">{}</span>        <span class="c1"># {cluster_id -&gt; fitted meta model}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># For Bayesian optimization</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 1. Hyperparameter computation for base models</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span>
                                <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run each base model&#39;s hyperparameter search.</span>
<span class="sd">        Use clustering from the first base model as the common cluster_da.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">best_params_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            
            <span class="n">bp</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span>
                                                  <span class="n">Predictand</span><span class="p">,</span>
                                                  <span class="n">clim_year_start</span><span class="p">,</span>
                                                  <span class="n">clim_year_end</span><span class="p">)</span>
            <span class="n">best_params_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>

            <span class="c1"># Take cluster_da from the first model; assume others use same clustering scheme</span>
            <span class="k">if</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">cd</span>

        <span class="c1"># Make sure cluster labels are integers where valid</span>
        <span class="k">if</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cluster_vals</span> <span class="o">=</span> <span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cluster_vals</span><span class="p">)</span>
            <span class="n">cluster_vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">cluster_vals</span><span class="p">,</span>
                                      <span class="n">coords</span><span class="o">=</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                                      <span class="n">dims</span><span class="o">=</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span> <span class="o">=</span> <span class="n">best_params_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="n">cluster_da</span>
        <span class="k">return</span> <span class="n">best_params_list</span><span class="p">,</span> <span class="n">cluster_da</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 2. Internal: OOF predictions for stacking</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking._get_oof_predictions">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking._get_oof_predictions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_oof_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                             <span class="n">best_params_list</span><span class="p">,</span>
                             <span class="n">cluster_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute out-of-fold predictions for each base model over the training period.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of xr.DataArray (same shape as y: T,Y,X),</span>
<span class="sd">            OOF predictions for each base model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stacking_cv</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Initialize OOF arrays</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">base_best_params</span> <span class="o">=</span> <span class="n">best_params_list</span><span class="p">[</span><span class="n">m_idx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">kf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_time</span><span class="p">)):</span>
                <span class="n">T_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">train_idx</span><span class="p">]</span>
                <span class="n">T_val</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">val_idx</span><span class="p">]</span>

                <span class="n">X_train_fold</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_train</span><span class="p">)</span>
                <span class="n">y_train_fold</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_train</span><span class="p">)</span>
                <span class="n">X_val_fold</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_val</span><span class="p">)</span>
                <span class="n">y_val_fold</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_val</span><span class="p">)</span>

                <span class="c1"># Base hindcast on this fold</span>
                <span class="n">pred_val</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
                    <span class="n">X_train_fold</span><span class="p">,</span>
                    <span class="n">y_train_fold</span><span class="p">,</span>
                    <span class="n">X_val_fold</span><span class="p">,</span>
                    <span class="n">y_val_fold</span><span class="p">,</span>
                    <span class="n">best_params</span><span class="o">=</span><span class="n">base_best_params</span><span class="p">,</span>
                    <span class="n">cluster_da</span><span class="o">=</span><span class="n">cluster_da</span>
                <span class="p">)</span>

                <span class="c1"># Insert fold predictions into OOF container</span>
                <span class="n">oof_preds</span><span class="p">[</span><span class="n">m_idx</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pred_val</span>

        <span class="k">return</span> <span class="n">oof_preds</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 3. Internal: hyperparameter optimization for meta-learners</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking._objective_bayesian">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking._objective_bayesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective_bayesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">learner_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Bayesian optimization with Optuna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;ridge&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;lasso&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;elasticnet&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">l1_ratio</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;l1_ratio&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">,</span> 
                               <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        
        <span class="c1"># Cross-validation score</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span> 
                                 <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking._fit_meta_learners">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking._fit_meta_learners">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_meta_learners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oof_preds</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cluster_da</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit one meta-learner per cluster using selected optimization method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">T_coord</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">c_val</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_val</span><span class="p">)</span>

            <span class="c1"># Mask (T,Y,X) for this cluster</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T_coord</span><span class="p">)</span>

            <span class="c1"># Build meta-features from OOF predictions</span>
            <span class="n">X_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">oof</span> <span class="ow">in</span> <span class="n">oof_preds</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">oof</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
                <span class="n">X_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">X_cols</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">X_meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols</span><span class="p">)</span>
            <span class="n">y_meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span>
                              <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
                              <span class="o">.</span><span class="n">values</span>
                              <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>

            <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_meta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">X_clean</span> <span class="o">=</span> <span class="n">X_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>
            <span class="n">y_clean</span> <span class="o">=</span> <span class="n">y_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>

            <span class="c1"># Select and fit meta model</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span>
                        <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid meta_learner_type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Choose optimization method</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
                    <span class="c1"># Grid Search</span>
                    <span class="n">search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                        <span class="n">base</span><span class="p">,</span>
                        <span class="n">param_grid</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                        <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span>
                        <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                        <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                    <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>
                    
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">==</span> <span class="s2">&quot;bayesian&quot;</span><span class="p">:</span>
                    <span class="c1"># Bayesian Optimization with Optuna</span>
                    <span class="n">sampler</span> <span class="o">=</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                        <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;maximize&quot;</span><span class="p">,</span>
                        <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span>
                    <span class="p">)</span>
                    
                    <span class="c1"># Create objective function with data</span>
                    <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective_bayesian</span><span class="p">(</span>
                        <span class="n">trial</span><span class="p">,</span> <span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span>
                    <span class="p">)</span>
                    
                    <span class="n">study</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective_with_data</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_trials</span><span class="p">)</span>
                    
                    <span class="c1"># Get best parameters and create model</span>
                    <span class="n">best_params</span> <span class="o">=</span> <span class="n">study</span><span class="o">.</span><span class="n">best_params</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
                        <span class="n">meta</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
                        <span class="n">meta</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
                        <span class="n">meta</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    
                    <span class="n">meta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="n">study</span>  <span class="c1"># Store the study for reference</span>
                    
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Default to random search</span>
                    <span class="c1"># Random Search</span>
                    <span class="n">search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                        <span class="n">base</span><span class="p">,</span>
                        <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                        <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span><span class="p">,</span>
                        <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span>
                        <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_clean</span><span class="p">,</span> <span class="n">y_clean</span><span class="p">)</span>
                    <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 4. Deterministic hindcast on test period</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span>
                      <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span>
                      <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">clim_year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">clim_year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train stacked model on (X_train, y_train) and predict on X_test.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            - If best_params &amp; cluster_da are provided, they are used.</span>
<span class="sd">            - Otherwise, clim_year_start &amp; clim_year_end must be given in</span>
<span class="sd">              order to compute base hyperparameters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            xr.DataArray[T,Y,X] predictions on X_test.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        
        <span class="c1"># Ensure predictand has no member dim &amp; consistent order</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">y_train</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">y_test</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Get / compute hyperparameters + cluster_da</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clim_year_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">clim_year_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;clim_year_start and clim_year_end must be provided if &quot;</span>
                    <span class="s2">&quot;best_params/cluster_da are not supplied.&quot;</span>
                <span class="p">)</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span> <span class="o">=</span> <span class="n">best_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="n">cluster_da</span>

        <span class="c1"># 1) OOF predictions over training</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_oof_predictions</span><span class="p">(</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span>
        <span class="p">)</span>

        <span class="c1"># 2) Fit meta-learners per cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_meta_learners</span><span class="p">(</span><span class="n">oof_preds</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="p">)</span>

        <span class="c1"># 3) Base predictions on X_test</span>
        <span class="n">base_test_preds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span><span class="p">[</span><span class="n">m_idx</span><span class="p">]</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span>
                <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span>
                <span class="n">best_params</span><span class="o">=</span><span class="n">bp</span><span class="p">,</span>
                <span class="n">cluster_da</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span>
            <span class="p">)</span>
            <span class="n">base_test_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

        <span class="c1"># 4) Apply meta-learners to stacked base predictions</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">final_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">c_val</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>

            <span class="c1"># Stack base predictions at cluster locations</span>
            <span class="n">X_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pred_base</span> <span class="ow">in</span> <span class="n">base_test_preds</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">pred_base</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
                <span class="n">X_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

            <span class="n">X_meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols</span><span class="p">)</span>
            <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">X_clean</span> <span class="o">=</span> <span class="n">X_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>
            <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_clean</span><span class="p">)</span>

            <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_meta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
            <span class="n">pred_c</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>

            <span class="n">fill_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">final_preds</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pred_c</span><span class="p">)</span>
            <span class="n">final_preds</span><span class="p">[</span><span class="n">fill_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_c</span><span class="p">[</span><span class="n">fill_mask</span><span class="p">]</span>

        <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">final_preds</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 5. Probabilities for hindcast (same pattern as other classes)</span>
    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># Reuse your existing probability helpers; I keep them here with key fixes.</span>

<div class="viewcode-block" id="WAS_mme_Stacking._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                        <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span>
                        <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">implied</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">implied</span> <span class="o">-</span> <span class="n">observed</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span>
                                                <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Lognormal</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># assume best_guess &gt; 0</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sigma2</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Exponential (approx; mean = best_guess, scale from variance)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span> <span class="o">-</span> <span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span> <span class="o">-</span> <span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">error_variance</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Weibull</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">lam</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Poisson</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Negative Binomial</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># Overdispersed only</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span>
                         <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span><span class="p">,</span>
                         <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span>
                                                      <span class="n">error_samples</span><span class="p">,</span>
                                                      <span class="n">first_tercile</span><span class="p">,</span>
                                                      <span class="n">second_tercile</span><span class="p">):</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_samples</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="n">bg</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bg</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">bg</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_a</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">+</span> <span class="n">p_n</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_b</span><span class="p">,</span> <span class="n">p_n</span><span class="p">,</span> <span class="n">p_a</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">Predictant</span><span class="p">,</span>
                     <span class="n">clim_year_start</span><span class="p">,</span>
                     <span class="n">clim_year_end</span><span class="p">,</span>
                     <span class="n">hindcast_det</span><span class="p">,</span>
                     <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for stacked deterministic hindcasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span>
                   <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, &quot;</span>
                    <span class="s2">&quot;best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>

            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="n">dm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># 6. Forecast: stacked deterministic + tercile probabilities</span>
    <span class="c1"># ------------------------------------------------------------------</span>
<div class="viewcode-block" id="WAS_mme_Stacking.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">Predictant</span><span class="p">,</span>
                 <span class="n">clim_year_start</span><span class="p">,</span>
                 <span class="n">clim_year_end</span><span class="p">,</span>
                 <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span>
                 <span class="n">Predictor_for_year</span><span class="p">,</span>
                 <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cluster_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        One-step forecast for target year using stacking.</span>

<span class="sd">        Mirrors pattern of other WAS_mme_* classes:</span>
<span class="sd">        - uses hindcast_det as training predictors</span>
<span class="sd">        - uses Predictor_for_year as new predictors</span>
<span class="sd">        - reuses per-base hyperparameters &amp; cluster_da</span>
<span class="sd">        - meta-learners trained on standardized hindcast period</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove member dimension if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="c1"># Mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mask_np</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Standardize hindcast_det for training predictors</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span>
                                            <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">std_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span>
                                                 <span class="n">clim_year_start</span><span class="p">,</span>
                                                 <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span>
                                               <span class="n">clim_year_start</span><span class="p">,</span>
                                               <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">hindcast_det_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>

        <span class="c1"># Hyperparameters / clustering</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span><span class="p">,</span> <span class="n">cluster_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span>
                <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span> <span class="o">=</span> <span class="n">best_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">=</span> <span class="n">cluster_da</span>

        <span class="c1"># OOF on standardized hindcast</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_oof_predictions</span><span class="p">(</span>
            <span class="n">hindcast_det_st</span><span class="p">,</span> <span class="n">Predictant_st</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_meta_learners</span><span class="p">(</span><span class="n">oof_preds</span><span class="p">,</span> <span class="n">Predictant_st</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="p">)</span>

        <span class="c1"># Base forecasts (standardized space)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>

        <span class="n">base_forecast_std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_params_list</span><span class="p">[</span><span class="n">m_idx</span><span class="p">]</span>
            <span class="n">pred_std</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
                <span class="n">hindcast_det_st</span><span class="p">,</span>
                <span class="n">Predictant_st</span><span class="p">,</span>
                <span class="n">Predictor_for_year_st</span><span class="p">,</span>
                <span class="n">y_test_dummy</span><span class="p">,</span>
                <span class="n">best_params</span><span class="o">=</span><span class="n">bp</span><span class="p">,</span>
                <span class="n">cluster_da</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span>
            <span class="p">)</span>
            <span class="n">base_forecast_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_std</span><span class="p">)</span>

        <span class="c1"># Meta stacked forecast (standardized)</span>
        <span class="n">preds_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">c_val</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learners</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">mask_3d</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>

            <span class="n">X_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pred_b</span> <span class="ow">in</span> <span class="n">base_forecast_std</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">pred_b</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
                <span class="n">X_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">X_meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols</span><span class="p">)</span>
            <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">X_clean</span> <span class="o">=</span> <span class="n">X_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>
            <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_clean</span><span class="p">)</span>
            <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_meta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">full</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
            <span class="n">pred_c</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>

            <span class="n">fill_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">preds_std</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pred_c</span><span class="p">)</span>
            <span class="n">preds_std</span><span class="p">[</span><span class="n">fill_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_c</span><span class="p">[</span><span class="n">fill_mask</span><span class="p">]</span>

        <span class="c1"># De-standardize to physical space</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">preds_std</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">mask_np</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">result_da</span><span class="p">,</span>
                                        <span class="n">Predictant_no_m</span><span class="p">,</span>
                                        <span class="n">clim_year_start</span><span class="p">,</span>
                                        <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="c1"># Set forecast time stamp consistent with other classes</span>
        <span class="n">year</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[Y]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span><span class="p">)</span>
        <span class="n">first_T</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">first_month</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[M]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">first_month</span><span class="p">)</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>

        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>

        <span class="c1"># --- Probabilities for the forecast ---</span>
        <span class="c1"># Use same climatology window as for other models</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_clim</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>

        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span>
                   <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, &quot;</span>
                    <span class="s2">&quot;best_loc_da, best_scale_da.&quot;</span>
                <span class="p">)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="p">,</span>
                <span class="n">T1</span><span class="p">,</span>
                <span class="n">T2</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">WAS_mme_Stacking</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span>
                <span class="n">error_samples</span><span class="p">,</span>
                <span class="n">T1_emp</span><span class="p">,</span>
                <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="n">dm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask_np</span><span class="p">,</span> <span class="p">(</span><span class="n">forecast_prob</span> <span class="o">*</span> <span class="n">mask_np</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WAS_mme_Stacking_">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_Stacking_</span><span class="p">:</span>   
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacking ensemble for Multi-Model Ensemble (MME) forecasting using provided base models.</span>
<span class="sd">    Stacks hpELM_, MLP_, XGBoosting_, RF_ via a meta-learner (ridge/lasso/elasticnet/linear).</span>
<span class="sd">    Supports deterministic and probabilistic (tercile) outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_mme_Stacking_.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">meta_learner_type</span><span class="o">=</span><span class="s1">&#39;ridge&#39;</span><span class="p">,</span>
                 <span class="n">alpha_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">l1_ratio_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                 <span class="n">dist_method</span><span class="o">=</span><span class="s2">&quot;nonparam&quot;</span><span class="p">,</span>       <span class="c1"># &#39;nonparam&#39; or &#39;bestfit&#39;</span>
                 <span class="n">stacking_cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">meta_search_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>  <span class="c1"># &#39;random&#39;, &#39;grid&#39;, or &#39;bayesian&#39;</span>
                 <span class="n">meta_cv_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">meta_n_iter_search</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">meta_n_trials</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>           <span class="c1"># For Bayesian optimization</span>
        <span class="k">if</span> <span class="n">alpha_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">l1_ratio_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">=</span> <span class="n">meta_learner_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span> <span class="o">=</span> <span class="n">alpha_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span> <span class="o">=</span> <span class="n">l1_ratio_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacking_cv</span> <span class="o">=</span> <span class="n">stacking_cv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">=</span> <span class="n">meta_search_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span> <span class="o">=</span> <span class="n">meta_cv_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span> <span class="o">=</span> <span class="n">meta_n_iter_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_n_trials</span> <span class="o">=</span> <span class="n">meta_n_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For Bayesian optimization</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">WAS_mme_hpELM_</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">),</span>
            <span class="n">WAS_mme_MLP_</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">),</span>
            <span class="n">WAS_mme_XGBoosting_</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">),</span>
            <span class="n">WAS_mme_RF_</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">dist_method</span><span class="o">=</span><span class="n">dist_method</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="c1"># ------------------ Hyperparameter optimization methods ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_._objective_bayesian">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_._objective_bayesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_objective_bayesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">learner_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function for Bayesian optimization with Optuna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;ridge&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;lasso&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">learner_type</span> <span class="o">==</span> <span class="s1">&#39;elasticnet&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">)</span>
            <span class="n">l1_ratio</span> <span class="o">=</span> <span class="n">trial</span><span class="o">.</span><span class="n">suggest_categorical</span><span class="p">(</span><span class="s1">&#39;l1_ratio&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">,</span> 
                               <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        
        <span class="c1"># Cross-validation score</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross_val_score</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span> 
                                 <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking_._fit_meta_learner_with_search">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_._fit_meta_learner_with_search">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_meta_learner_with_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit meta-learner using selected optimization method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">meta</span>
        
        <span class="c1"># Prepare base model and parameter distribution</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid meta_learner_type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Select optimization method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="c1"># Grid Search</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span>
                <span class="n">param_grid</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span>
                <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_search_method</span> <span class="o">==</span> <span class="s2">&quot;bayesian&quot;</span><span class="p">:</span>
            <span class="c1"># Bayesian Optimization with Optuna</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">TPESampler</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">study_</span> <span class="o">=</span> <span class="n">optuna</span><span class="o">.</span><span class="n">create_study</span><span class="p">(</span>
                <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;maximize&quot;</span><span class="p">,</span>
                <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span>
            <span class="p">)</span>
            
            <span class="c1"># Create objective function with data</span>
            <span class="n">objective_with_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">trial</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective_bayesian</span><span class="p">(</span>
                <span class="n">trial</span><span class="p">,</span> <span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span>
            <span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">study_</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">objective_with_data</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_trials</span><span class="p">)</span>
            
            <span class="c1"># Get best parameters and create model</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_</span><span class="o">.</span><span class="n">best_params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="o">**</span><span class="n">best_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
            
            <span class="n">meta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Default to random search</span>
            <span class="c1"># Random Search</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span>
                <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span>
                <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
            <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>

        <span class="k">return</span> <span class="n">meta</span></div>


    <span class="c1"># ------------------ Hyperparameters for base models ----------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_.compute_hyperparameters">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.compute_hyperparameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect per-base best params (no clustering assumed for underscore bases).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictand</span> <span class="o">=</span> <span class="n">Predictand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">best_params_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">Predictors</span><span class="p">,</span> <span class="n">Predictand</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
            <span class="n">best_params_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_params_list</span></div>


    <span class="c1"># ------------------ OOF predictions (stacking features) ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_._get_oof_predictions">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_._get_oof_predictions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_oof_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">best_params_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-fold predictions for each base over training period.</span>
<span class="sd">        Returns list of DataArrays, each (T,Y,X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stacking_cv</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">n_t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">kf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_t</span><span class="p">)):</span>
                <span class="n">X_train_fold</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">train_idx</span><span class="p">)</span>
                <span class="n">y_train_fold</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">train_idx</span><span class="p">)</span>
                <span class="n">X_val_fold</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">val_idx</span><span class="p">)</span>
                <span class="n">y_val_fold</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">val_idx</span><span class="p">)</span>

                <span class="n">pred_val</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
                    <span class="n">X_train_fold</span><span class="p">,</span> <span class="n">y_train_fold</span><span class="p">,</span>
                    <span class="n">X_val_fold</span><span class="p">,</span> <span class="n">y_val_fold</span><span class="p">,</span>
                    <span class="n">best_params</span><span class="o">=</span><span class="n">bp</span>
                <span class="p">)</span>
                <span class="c1"># write fold preds into OOF container</span>
                <span class="n">oof_preds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">X_val_fold</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])]</span> <span class="o">=</span> <span class="n">pred_val</span>
        <span class="k">return</span> <span class="n">oof_preds</span></div>


    <span class="c1"># ------------------ Deterministic hindcast/test ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span>
                      <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit stacking on training (using OOF), then predict on X_test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># handle member dim and order</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">y_train</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">y_test</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">X_test</span>  <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">y_test</span>  <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clim_year_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">clim_year_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need clim_year_start/clim_year_end to compute base hyperparameters.&quot;</span><span class="p">)</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">best_params_list</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="c1"># 1) OOF</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_oof_predictions</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">best_params_list</span><span class="p">)</span>

        <span class="c1"># 2) Build meta design matrix (NaN-safe)</span>
        <span class="n">X_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">oof</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">oof</span> <span class="ow">in</span> <span class="n">oof_preds</span><span class="p">]</span>
        <span class="n">X_meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols</span><span class="p">)</span>
        <span class="n">y_meta</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_meta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">):</span>
            <span class="c1"># Fallback: no clean rows, use simple mean-ensemble at prediction time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_meta_clean</span> <span class="o">=</span> <span class="n">X_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>
            <span class="n">y_meta_clean</span> <span class="o">=</span> <span class="n">y_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>

            <span class="c1"># 3) Fit meta-learner</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">()</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
                    <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid meta_learner_type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">meta_base</span><span class="p">,</span>
                    <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
                    <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span>
                    <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="p">)</span>
                <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="o">=</span> <span class="n">meta</span>

        <span class="c1"># 4) Base predictions on test</span>
        <span class="n">base_test_preds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pred_test</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="n">bp</span><span class="p">)</span>
            <span class="n">base_test_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_test</span><span class="p">)</span>

        <span class="c1"># 5) Stack &amp; predict</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">];</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">];</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">X_cols_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">base_test_preds</span><span class="p">]</span>
        <span class="n">X_meta_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols_test</span><span class="p">)</span>
        <span class="n">nan_mask_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta_test</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># mean of bases (ignoring NaNs) as last resort</span>
            <span class="n">pred_mean</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">base_test_preds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">pred_mean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">):</span>
                <span class="n">X_meta_test_clean</span> <span class="o">=</span> <span class="n">X_meta_test</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">]</span>
                <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_meta_test_clean</span><span class="p">)</span>
                <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_meta_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">full</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
                <span class="n">pred_reshaped</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">pred_reshaped</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>

            <span class="n">predicted_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">predictions</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_da</span></div>


    <span class="c1"># ------------------ Probability helpers ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_._ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_._ppf_terciles_from_code">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map best-fit family code -&gt; tercile thresholds (T1, T2).</span>
<span class="sd">        Codes:</span>
<span class="sd">          1:norm, 2:lognorm, 3:expon, 4:gamma, 5:weibull_min, 6:t, 7:poisson, 8:nbinom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span> <span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span>
                        <span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span> <span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">),</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking_.weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.weibull_shape_solver">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Root for Weibull shape k: (Gamma(1+2/k)/Gamma(1+1/k)^2 - 1) - V/M^2 = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">implied</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">implied</span> <span class="o">-</span> <span class="n">observed</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking_.calculate_tercile_probabilities_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.calculate_tercile_probabilities_bestfit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic tercile probabilities using best-fit family per grid cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

        <span class="c1"># Normal</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Lognormal (ensure positivity)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-12</span>
            <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">error_variance</span> <span class="o">/</span> <span class="p">(</span><span class="n">bg</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sigma2</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Exponential (variance = scale^2, mean = loc + scale)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">best_guess</span> <span class="o">-</span> <span class="n">scale</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Gamma (alpha=k, theta=scale)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-12</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Weibull</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">error_variance</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">WAS_mme_Stacking_</span><span class="o">.</span><span class="n">weibull_shape_solver</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">lam</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Student-t</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_variance</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">dof</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Poisson</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="c1"># Negative Binomial (overdispersed)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">error_variance</span> <span class="o">&gt;</span> <span class="n">best_guess</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">best_guess</span> <span class="o">/</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">error_variance</span> <span class="o">-</span> <span class="n">best_guess</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Unknown code</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WAS_mme_Stacking_.calculate_tercile_probabilities_nonparametric">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.calculate_tercile_probabilities_nonparametric">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_tercile_probabilities_nonparametric</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nonparametric terciles using historical error samples (gridwise, vectorized over T).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">error_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_samples</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
        <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="n">bg</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bg</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">bg</span> <span class="o">+</span> <span class="n">error_samples</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">first_tercile</span><span class="p">)</span>
            <span class="n">p_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">))</span>
            <span class="n">p_above</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">)</span>
            <span class="n">pred_prob</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_below</span><span class="p">,</span> <span class="n">p_between</span><span class="p">,</span> <span class="n">p_above</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pred_prob</span></div>


    <span class="c1"># ------------------ Hindcast probabilities ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                     <span class="n">clim_year_start</span><span class="p">,</span>
                     <span class="n">clim_year_end</span><span class="p">,</span>
                     <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                     <span class="n">best_code_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>
<span class="sd">        Returns (probability=[&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;], T, Y, X).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">terciles_emp</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles_emp</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span><span class="p">)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),(),(),()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">hindcast_det</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">T1_emp</span><span class="p">,</span> <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="n">dm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span><span class="s2">&quot;PN&quot;</span><span class="p">,</span><span class="s2">&quot;PA&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># ------------------ One-step forecast (det + probs) ------------------</span>

<div class="viewcode-block" id="WAS_mme_Stacking_.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Stacking_.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">Predictant</span><span class="p">,</span>
                 <span class="n">clim_year_start</span><span class="p">,</span>
                 <span class="n">clim_year_end</span><span class="p">,</span>
                 <span class="n">hindcast_det</span><span class="p">,</span>
                 <span class="n">hindcast_det_cross</span><span class="p">,</span>
                 <span class="n">Predictor_for_year</span><span class="p">,</span>
                 <span class="n">best_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_code_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_shape_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_loc_da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_scale_da</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        One-step forecast for target period using stacking; returns (deterministic, probabilities).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># strip member dim if present</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant</span>

        <span class="n">Predictant_no_m</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hindcast_det_cross</span> <span class="o">=</span> <span class="n">hindcast_det_cross</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">Predictor_for_year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># mask as DA (keep coords)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># standardize training predictors/targets</span>
        <span class="n">mean_val</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">std_val</span>  <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

        <span class="n">Predictor_for_year_st</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictor_for_year</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>
        <span class="n">hindcast_det_st</span> <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">Predictant_st</span>   <span class="o">=</span> <span class="n">standardize_timeseries</span><span class="p">(</span><span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">y_test_dummy</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Predictant_st</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># base hparams</span>
        <span class="k">if</span> <span class="n">best_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hyperparameters</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">best_params_list</span> <span class="o">=</span> <span class="n">best_params</span>

        <span class="c1"># OOF &amp; meta on standardized hindcast</span>
        <span class="n">oof_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_oof_predictions</span><span class="p">(</span><span class="n">hindcast_det_st</span><span class="p">,</span> <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">best_params_list</span><span class="p">)</span>
        <span class="n">X_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">oof</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">oof</span> <span class="ow">in</span> <span class="n">oof_preds</span><span class="p">]</span>
        <span class="n">X_meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols</span><span class="p">)</span>
        <span class="n">y_meta</span> <span class="o">=</span> <span class="n">Predictant_st</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_meta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_meta_clean</span> <span class="o">=</span> <span class="n">X_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">];</span> <span class="n">y_meta_clean</span> <span class="o">=</span> <span class="n">y_meta</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;ridge&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">();</span> <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;lasso&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">);</span> <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">}</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span> <span class="o">==</span> <span class="s2">&quot;elasticnet&quot;</span><span class="p">:</span>
                    <span class="n">meta_base</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">);</span> <span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_range</span><span class="p">,</span> <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_ratio_range</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid meta_learner_type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_learner_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
                    <span class="n">meta_base</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_n_iter_search</span><span class="p">,</span>
                    <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_cv_folds</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="p">)</span>
                <span class="n">search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_meta_clean</span><span class="p">,</span> <span class="n">y_meta_clean</span><span class="p">)</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">best_estimator_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="o">=</span> <span class="n">meta</span>

        <span class="c1"># base forecasts in standardized space</span>
        <span class="n">base_forecast_std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_models</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">best_params_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pred_base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
                <span class="n">hindcast_det_st</span><span class="p">,</span> <span class="n">Predictant_st</span><span class="p">,</span> <span class="n">Predictor_for_year_st</span><span class="p">,</span> <span class="n">y_test_dummy</span><span class="p">,</span> <span class="n">best_params</span><span class="o">=</span><span class="n">bp</span>
            <span class="p">)</span>
            <span class="n">base_forecast_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_base</span><span class="p">)</span>

        <span class="c1"># meta prediction in standardized space</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">];</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">Predictor_for_year_st</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">preds_std</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">base_forecast_std</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_cols_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">base_forecast_std</span><span class="p">]</span>
            <span class="n">X_meta_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">X_cols_test</span><span class="p">)</span>
            <span class="n">nan_mask_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X_meta_test</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">preds_std_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask_test</span><span class="p">):</span>
                <span class="n">X_meta_test_clean</span> <span class="o">=</span> <span class="n">X_meta_test</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">]</span>
                <span class="n">y_pred_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_learner</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_meta_test_clean</span><span class="p">)</span>
                <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_meta_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">full</span><span class="p">[</span><span class="o">~</span><span class="n">nan_mask_test</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_clean</span>
                <span class="n">preds_std_arr</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">,</span> <span class="n">n_lon</span><span class="p">)</span>

            <span class="n">preds_std</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">preds_std_arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># de-standardize to original space &amp; apply spatial mask</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">reverse_standardize</span><span class="p">(</span><span class="n">preds_std</span><span class="p">,</span> <span class="n">Predictant_no_m</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># fix forecast time coordinate to target year/month</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Predictor_for_year</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[Y]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span>
        <span class="n">first_T</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[M]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_T_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">month_1</span><span class="p">)</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">result_da</span> <span class="o">=</span> <span class="n">result_da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T_value</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">result_da</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_da</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>

        <span class="c1"># ---------- probabilities ----------</span>
        <span class="n">index_start</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
        <span class="n">index_end</span>   <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">rainfall_for_tercile</span> <span class="o">=</span> <span class="n">Predictant_no_m</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_end</span><span class="p">))</span>
        <span class="n">terciles</span> <span class="o">=</span> <span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>
        <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det_cross</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rainfall_for_tercile</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span><span class="p">)</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),(),(),()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_bestfit</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">:</span>
            <span class="c1"># use historical hindcast errors (hindcast_det) with observed Predictant_no_m</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="n">Predictant_no_m</span> <span class="o">-</span> <span class="n">hindcast_det</span>
            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_tercile_probabilities_nonparametric</span><span class="p">,</span>
                <span class="n">result_da</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">T1_emp</span><span class="p">,</span> <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dist_method: </span><span class="si">{</span><span class="n">dm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span><span class="s2">&quot;PN&quot;</span><span class="p">,</span><span class="s2">&quot;PA&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_da</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">forecast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span></div>
</div>





<div class="viewcode-block" id="_ensemble_crps">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._ensemble_crps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_ensemble_crps</span><span class="p">(</span><span class="n">ens</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">fair</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Continuous Ranked Probability Score (CRPS) for an ensemble.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ens : array-like</span>
<span class="sd">        Ensemble forecast members</span>
<span class="sd">    obs : float</span>
<span class="sd">        Observation value</span>
<span class="sd">    fair : bool, default=True</span>
<span class="sd">        Apply fair CRPS correction (m/(m-1)) for finite ensemble sizes</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    crps : float</span>
<span class="sd">        CRPS value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ens</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">ens</span><span class="o">.</span><span class="n">size</span>
    
    <span class="c1"># Handle edge cases</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">obs</span><span class="p">)</span>
    
    <span class="c1"># Traditional CRPS formula for ensemble</span>
    <span class="n">term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ens</span> <span class="o">-</span> <span class="n">obs</span><span class="p">))</span>
    
    <span class="c1"># Efficient computation of pairwise differences</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">:</span>  <span class="c1"># Use matrix for small ensembles</span>
        <span class="c1"># This computes all pairwise absolute differences</span>
        <span class="c1"># Using broadcasting: ens[:, None] - ens[None, :] creates m x m matrix</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ens</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">ens</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="c1"># Use sorted method for O(m log m) complexity (Gneiting et al. 2005)</span>
        <span class="n">sorted_ens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ens</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Formula: (1/m^2) *  (2k - m - 1) * x_(k)</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sorted_ens</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">crps</span> <span class="o">=</span> <span class="n">term1</span> <span class="o">-</span> <span class="n">term2</span>
    
    <span class="c1"># Fair CRPS correction for finite ensemble size (Ferro et al. 2005)</span>
    <span class="k">if</span> <span class="n">fair</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">crps</span> <span class="o">*=</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">crps</span></div>



<div class="viewcode-block" id="_gauss_crps">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._gauss_crps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_gauss_crps</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the CRPS for a Gaussian distribution.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obs : float or array-like</span>
<span class="sd">        Observation value(s)</span>
<span class="sd">    mu : float or array-like</span>
<span class="sd">        Mean of the Gaussian distribution</span>
<span class="sd">    sig : float or array-like</span>
<span class="sd">        Standard deviation of the Gaussian distribution</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    crps : float or array-like</span>
<span class="sd">        CRPS value(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure inputs are numpy arrays</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    
    <span class="c1"># Enhanced numerical stability</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">obs</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
    <span class="n">pdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cdf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pdf</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span></div>



<div class="viewcode-block" id="WAS_mme_NGR">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_NGR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operational WAS_mme_NGR calibration for ensemble post-processing.</span>
<span class="sd">    </span>
<span class="sd">    Implements Non-homogeneous Gaussian Regression (NGR) with two variants:</span>
<span class="sd">    - &quot;NGR&quot;: Minimize Gaussian CRPS (parametric)</span>
<span class="sd">    - &quot;ensNGR&quot;: Minimize ensemble CRPS (non-parametric)</span>
<span class="sd">    </span>
<span class="sd">    The calibration model: </span>
<span class="sd">     = a + b * ensemble_mean</span>
<span class="sd">     = sqrt(c + d * ensemble_variance)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    type : {&#39;NGR&#39;, &#39;ensNGR&#39;}, default=&#39;NGR&#39;</span>
<span class="sd">        CRPS minimization method</span>
<span class="sd">    apply_to : {&#39;all&#39;, &#39;sig&#39;, &#39;pos&#39;, &#39;neg&#39;}, default=&#39;all&#39;</span>
<span class="sd">        When to apply calibration:</span>
<span class="sd">        - &#39;all&#39;: Always apply calibration</span>
<span class="sd">        - &#39;sig&#39;: Only apply if regression is statistically significant</span>
<span class="sd">        - &#39;pos&#39;: Only apply if positive correlation is significant</span>
<span class="sd">        - &#39;neg&#39;: Only apply if negative correlation is significant</span>
<span class="sd">    alpha : float, default=0.1</span>
<span class="sd">        Significance level for statistical tests (0 &lt; alpha &lt; 1)</span>
<span class="sd">    test_direction : {&#39;two-sided&#39;, &#39;greater&#39;, &#39;less&#39;}, default=&#39;two-sided&#39;</span>
<span class="sd">        Direction of statistical test for regression significance</span>
<span class="sd">    param_bounds : dict or None, default=None</span>
<span class="sd">        Custom bounds for parameters [a, b, c, d]</span>
<span class="sd">        Example: {&#39;a&#39;: (-10, 10), &#39;b&#39;: (0, 5), &#39;c&#39;: (0, 5), &#39;d&#39;: (0, 5)}</span>
<span class="sd">        </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    params : xarray.DataArray or numpy.ndarray</span>
<span class="sd">        Calibration parameters [a, b, c, d]</span>
<span class="sd">    clim_terciles : xarray.DataArray or numpy.ndarray</span>
<span class="sd">        Climate terciles computed from observations</span>
<span class="sd">    fitted : bool</span>
<span class="sd">        Whether the model has been fitted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Default parameter bounds ensuring physical plausibility</span>
    <span class="n">DEFAULT_BOUNDS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>  <span class="c1"># Intercept can be any value</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>      <span class="c1"># Regression coefficient should be non-negative</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>      <span class="c1"># Spread adjustment should be non-negative</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>      <span class="c1"># Spread scaling should be non-negative</span>
    <span class="p">}</span>
    
<div class="viewcode-block" id="WAS_mme_NGR.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;NGR&quot;</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                 <span class="n">test_direction</span><span class="o">=</span><span class="s2">&quot;two-sided&quot;</span><span class="p">,</span> <span class="n">param_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Validate inputs</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;NGR&quot;</span><span class="p">,</span> <span class="s2">&quot;ensNGR&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type must be &#39;NGR&#39; or &#39;ensNGR&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;sig&quot;</span><span class="p">,</span> <span class="s2">&quot;pos&quot;</span><span class="p">,</span> <span class="s2">&quot;neg&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;apply_to must be &#39;all&#39;, &#39;sig&#39;, &#39;pos&#39;, or &#39;neg&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha must be between 0 and 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;two-sided&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test_direction must be &#39;two-sided&#39;, &#39;greater&#39;, or &#39;less&#39;&quot;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span> <span class="o">=</span> <span class="n">apply_to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_direction</span> <span class="o">=</span> <span class="n">test_direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_gaussian</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;NGR&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_ensemble</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;ensNGR&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set parameter bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_BOUNDS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">param_bounds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">param_bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
        
        <span class="c1"># Initialize state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xarray</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Dimension names (configurable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_dim</span> <span class="o">=</span> <span class="s1">&#39;parameter&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="s1">&#39;T&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_member_dim</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span> <span class="o">=</span> <span class="kc">None</span></div>

        
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;fitted&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="k">else</span> <span class="s2">&quot;unfitted&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WAS_mme_NGR(type=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39;, apply_to=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;alpha=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="WAS_mme_NGR._create_objective_function">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR._create_objective_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmn</span><span class="p">,</span> <span class="n">fsd</span><span class="p">,</span> <span class="n">fanom</span><span class="p">,</span> <span class="n">o_train</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create objective function for parameter optimization.&quot;&quot;&quot;</span>
        <span class="n">n_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_train</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ensemble</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">obj</span><span class="p">(</span><span class="n">pars</span><span class="p">):</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pars</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">fmn</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fsd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                
                <span class="c1"># Vectorized ensemble CRPS calculation</span>
                <span class="n">cal_ens</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">sigma</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">fanom</span>
                
                <span class="c1"># Compute CRPS for all time steps at once</span>
                <span class="n">crps_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_times</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_times</span><span class="p">):</span>
                    <span class="n">crps_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ensemble_crps</span><span class="p">(</span><span class="n">cal_ens</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="n">o_train</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fair</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crps_vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">obj</span><span class="p">(</span><span class="n">pars</span><span class="p">):</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pars</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">fmn</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fsd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_gauss_crps</span><span class="p">(</span><span class="n">o_train</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">obj</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR._test_regression_significance">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR._test_regression_significance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_test_regression_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">test_direction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if regression correlation is statistically significant.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
            
        <span class="c1"># Handle perfect correlation</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1e-12</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
            
        <span class="c1"># Compute t-statistic</span>
        <span class="n">t_stat</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">))</span>
        
        <span class="c1"># Compute p-value based on test direction</span>
        <span class="k">if</span> <span class="n">test_direction</span> <span class="o">==</span> <span class="s2">&quot;two-sided&quot;</span><span class="p">:</span>
            <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tdist</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t_stat</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">test_direction</span> <span class="o">==</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span>
            <span class="n">p_value</span> <span class="o">=</span> <span class="n">tdist</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">t_stat</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;less&quot;</span>
            <span class="n">p_value</span> <span class="o">=</span> <span class="n">tdist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t_stat</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR._apply_calibration_decision">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR._apply_calibration_decision">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_calibration_decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lm</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decide whether to apply calibration based on statistical test.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;sig&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_regression_significance</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">rvalue</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_direction</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;pos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">rvalue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">_test_regression_significance</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">rvalue</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;neg&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">rvalue</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">_test_regression_significance</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">rvalue</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hcst_grid</span><span class="p">,</span> <span class="n">obs_grid</span><span class="p">,</span> <span class="n">clim_terciles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">member_dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit calibration parameters using hindcast data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hcst_grid : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Hindcast ensemble data with dimensions (member, time, lat, lon)</span>
<span class="sd">        obs_grid : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Observations with dimensions (time, lat, lon)</span>
<span class="sd">        clim_terciles : bool, default=False</span>
<span class="sd">            Compute climate terciles from observations</span>
<span class="sd">        member_dim, time_dim, lat_dim, lon_dim : str</span>
<span class="sd">            Dimension names</span>
<span class="sd">        show_progress : bool, default=True</span>
<span class="sd">            Show progress bar during fitting</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : WAS_mme_NGR</span>
<span class="sd">            Fitted model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if xarray is available and inputs are DataArrays</span>
        <span class="n">use_xarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> 
                     <span class="nb">isinstance</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="ow">and</span> 
                     <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">use_xarray</span><span class="p">:</span>
            <span class="c1"># Ensure correct dimension order and extract values</span>
            <span class="n">hcst</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">obs_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            
            <span class="c1"># Store metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span> <span class="o">=</span> <span class="n">lat_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span> <span class="o">=</span> <span class="n">lon_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="n">time_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_member_dim</span> <span class="o">=</span> <span class="n">member_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xarray</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert to numpy arrays</span>
            <span class="n">hcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="c1"># Store dimension names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span> <span class="o">=</span> <span class="n">lat_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span> <span class="o">=</span> <span class="n">lon_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="n">time_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_member_dim</span> <span class="o">=</span> <span class="n">member_dim</span>
        
        <span class="c1"># Get dimensions</span>
        <span class="n">nmemb</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span> <span class="o">=</span> <span class="n">hcst</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># Validate shapes</span>
        <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;obs_grid must have shape (time, lat, lon) = (</span><span class="si">{</span><span class="n">ntimes</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">nlat</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">nlon</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize parameter array and optimization statistics</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">opt_stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="s1">&#39;iterations&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;crps_reduction&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s1">&#39;final_crps&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="c1"># Compute climate terciles if requested</span>
        <span class="k">if</span> <span class="n">clim_terciles</span><span class="p">:</span>
            <span class="c1"># Compute terciles along time dimension</span>
            <span class="n">terc_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="p">[</span><span class="mi">100</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">200</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_xarray</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">terc_np</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;tercile&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s1">&#39;tercile&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">terc_np</span>
        
        <span class="c1"># Prepare bounds for optimization</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
        <span class="p">]</span>
        
        <span class="c1"># Fit parameters for each grid point</span>
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitting WAS_mme_NGR parameters (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid: </span><span class="si">{</span><span class="n">nlat</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">nlon</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">nlat</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nlon</span><span class="si">}</span><span class="s2"> points)&quot;</span><span class="p">)</span>
            <span class="n">lat_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nlat</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Latitude&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lat_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlat</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ilat</span> <span class="ow">in</span> <span class="n">lat_iter</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ilon</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlon</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Extract data for this grid point</span>
                    <span class="n">o_gp</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">h_gp</span> <span class="o">=</span> <span class="n">hcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1"># Find valid (non-NaN) time steps</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">o_gp</span><span class="p">)</span>
                    <span class="n">n_valid</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    
                    <span class="c1"># Need at least 3 valid points for regression</span>
                    <span class="k">if</span> <span class="n">n_valid</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">params</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>  <span class="c1"># No calibration</span>
                        <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Extract valid data</span>
                    <span class="n">o_train</span> <span class="o">=</span> <span class="n">o_gp</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
                    <span class="n">h_gp_valid</span> <span class="o">=</span> <span class="n">h_gp</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>
                    
                    <span class="c1"># Compute ensemble statistics for valid time steps</span>
                    <span class="n">ens_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">h_gp_valid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">sigma_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">h_gp_valid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
                    <span class="c1"># Standardize ensemble anomalies with numerical stability</span>
                    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mi">100</span>
                    <span class="n">sigma_e_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sigma_e</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                    <span class="n">anom</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_gp_valid</span> <span class="o">-</span> <span class="n">ens_mean</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">sigma_e_safe</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                    
                    <span class="c1"># Extract training data</span>
                    <span class="n">fmn</span> <span class="o">=</span> <span class="n">ens_mean</span>
                    <span class="n">fsd</span> <span class="o">=</span> <span class="n">sigma_e</span>
                    <span class="n">fanom</span> <span class="o">=</span> <span class="n">anom</span>
                    
                    <span class="c1"># Initial guess from linear regression</span>
                    <span class="n">mask_lm</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fmn</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mask_lm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">params</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                        <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">continue</span>
                    
                    <span class="n">lm</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">fmn</span><span class="p">[</span><span class="n">mask_lm</span><span class="p">],</span> <span class="n">o_train</span><span class="p">[</span><span class="n">mask_lm</span><span class="p">])</span>
                    <span class="n">initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lm</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">lm</span><span class="o">.</span><span class="n">slope</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
                    
                    <span class="c1"># Ensure initial b parameter is non-negative</span>
                    <span class="n">initial</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">initial</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
                    
                    <span class="c1"># Decide whether to apply calibration</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_calibration_decision</span><span class="p">(</span><span class="n">lm</span><span class="p">,</span> <span class="n">mask_lm</span><span class="o">.</span><span class="n">sum</span><span class="p">()):</span>
                        <span class="n">params</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                        <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Considered successful (no calibration needed)</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Create objective function</span>
                    <span class="n">obj_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_objective_function</span><span class="p">(</span><span class="n">fmn</span><span class="p">,</span> <span class="n">fsd</span><span class="p">,</span> <span class="n">fanom</span><span class="p">,</span> <span class="n">o_train</span><span class="p">)</span>
                    
                    <span class="c1"># Compute initial CRPS (no calibration)</span>
                    <span class="n">initial_crps</span> <span class="o">=</span> <span class="n">obj_func</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
                    
                    <span class="c1"># Optimize parameters</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                        <span class="n">obj_func</span><span class="p">,</span> 
                        <span class="n">initial</span><span class="p">,</span> 
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span>  <span class="c1"># Supports bounds</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                        <span class="n">options</span><span class="o">=</span><span class="p">{</span>
                            <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> 
                            <span class="s2">&quot;ftol&quot;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span>
                            <span class="s2">&quot;gtol&quot;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
                            <span class="s2">&quot;disp&quot;</span><span class="p">:</span> <span class="kc">False</span>
                        <span class="p">}</span>
                    <span class="p">)</span>
                    
                    <span class="c1"># Store results</span>
                    <span class="n">params</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span>
                    <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">nit</span>
                    <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;final_crps&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span> <span class="k">else</span> <span class="n">initial_crps</span>
                    
                    <span class="c1"># Compute CRPS reduction</span>
                    <span class="k">if</span> <span class="n">initial_crps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">crps_reduction</span> <span class="o">=</span> <span class="p">(</span><span class="n">initial_crps</span> <span class="o">-</span> <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;final_crps&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">])</span> <span class="o">/</span> <span class="n">initial_crps</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">crps_reduction</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;crps_reduction&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">crps_reduction</span>
                    
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># Fallback to no calibration</span>
                    <span class="n">params</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                    <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">][</span><span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1"># Store parameters</span>
        <span class="k">if</span> <span class="n">use_xarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_param_dim</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                <span class="p">},</span>
                <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        
        <span class="c1"># Store optimization statistics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span> <span class="o">=</span> <span class="n">opt_stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># Print summary statistics</span>
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">success_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">success_mask</span> <span class="o">=</span> <span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">success_mask</span><span class="p">):</span>
                <span class="n">avg_crps_reduction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;crps_reduction&#39;</span><span class="p">][</span><span class="n">success_mask</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="n">avg_iterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">opt_stats</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">][</span><span class="n">success_mask</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fit complete: Success rate = </span><span class="si">{</span><span class="n">success_rate</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%, &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;Average CRPS reduction = </span><span class="si">{</span><span class="n">avg_crps_reduction</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%, &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;Avg iterations = </span><span class="si">{</span><span class="n">avg_iterations</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fit complete: Success rate = </span><span class="si">{</span><span class="n">success_rate</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR.transform">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcst_grid</span><span class="p">,</span> <span class="n">member_dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply calibration to forecast data (returns calibrated ensemble only).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fcst_grid : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Forecast ensemble data</span>
<span class="sd">        member_dim, time_dim, lat_dim, lon_dim : str</span>
<span class="sd">            Dimension names</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cal_ens : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Calibrated ensemble</span>
<span class="sd">        mu : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Calibrated mean</span>
<span class="sd">        sigma : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Calibrated standard deviation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">fcst_grid</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">parametric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">member_dim</span><span class="o">=</span><span class="n">member_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;calibrated_ensemble&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;calibrated_mean&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;calibrated_std&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR.predict">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcst_grid</span><span class="p">,</span> <span class="n">quantiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clim_terciles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">parametric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">member_dim</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> 
                <span class="n">lat_dim</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply calibration and compute requested outputs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fcst_grid : xarray.DataArray or numpy.ndarray</span>
<span class="sd">            Forecast ensemble data</span>
<span class="sd">        quantiles : list of float or None, default=None</span>
<span class="sd">            Quantile levels to compute (e.g., [0.05, 0.5, 0.95])</span>
<span class="sd">        clim_terciles : bool, default=False</span>
<span class="sd">            Compute tercile probabilities</span>
<span class="sd">        parametric : bool or None, default=None</span>
<span class="sd">            Use parametric (Gaussian) method for quantiles/terciles</span>
<span class="sd">            If None, uses the model type (NGR=parametric, ensNGR=non-parametric)</span>
<span class="sd">        member_dim, time_dim, lat_dim, lon_dim : str</span>
<span class="sd">            Dimension names</span>
<span class="sd">        show_progress : bool, default=True</span>
<span class="sd">            Show progress bar</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : xarray.Dataset or tuple</span>
<span class="sd">            Calibrated products</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Model must be fitted before prediction. Call fit() first.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Determine whether to use parametric method</span>
        <span class="k">if</span> <span class="n">parametric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parametric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_gaussian</span>
        
        <span class="c1"># Check what outputs are needed</span>
        <span class="n">need_ensemble</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">quantiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">parametric</span><span class="p">:</span>
            <span class="n">need_ensemble</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">clim_terciles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">parametric</span><span class="p">:</span>
            <span class="n">need_ensemble</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">need_ensemble</span><span class="p">,</span> <span class="n">quantiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">clim_terciles</span><span class="p">]):</span>
            <span class="n">need_ensemble</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># At least return the calibrated ensemble</span>
        
        <span class="c1"># Handle xarray or numpy input</span>
        <span class="n">use_xarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fcst_grid</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">use_xarray</span><span class="p">:</span>
            <span class="n">fcst_trans</span> <span class="o">=</span> <span class="n">fcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">fcst_trans</span><span class="o">.</span><span class="n">values</span>
            <span class="n">time_coords</span> <span class="o">=</span> <span class="n">fcst_trans</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span>
            <span class="n">member_coords</span> <span class="o">=</span> <span class="n">fcst_trans</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">member_dim</span><span class="p">]</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">fcst_grid</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">fcst_grid</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;forecast&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fcst_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="n">nmemb</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># Validate parameter dimensions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter dimensions </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2"> don&#39;t match forecast dimensions </span><span class="si">{</span><span class="n">nlat</span><span class="p">,</span><span class="w"> </span><span class="n">nlon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize output arrays</span>
        <span class="n">cal_ens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">fcst</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">if</span> <span class="n">need_ensemble</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="c1"># Extract parameters for fast access</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">):</span>
            <span class="n">param_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        
        <span class="c1"># Apply calibration to each grid point</span>
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying calibration to forecast...&quot;</span><span class="p">)</span>
            <span class="n">lat_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nlat</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Latitude&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lat_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlat</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ilat</span> <span class="ow">in</span> <span class="n">lat_iter</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ilon</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlon</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">f_gp</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1"># Skip if all data is NaN</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">f_gp</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Compute ensemble statistics</span>
                    <span class="n">ens_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">f_gp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">sigma_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">f_gp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
                    <span class="c1"># Handle cases where std is zero</span>
                    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mi">100</span>
                    <span class="n">sigma_e_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sigma_e</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                    
                    <span class="c1"># Standardize anomalies</span>
                    <span class="n">anom</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_gp</span> <span class="o">-</span> <span class="n">ens_mean</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">sigma_e_safe</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                    
                    <span class="c1"># Get parameters for this grid point</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">param_np</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span>
                    
                    <span class="c1"># Check for NaN parameters (no calibration applied)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                        <span class="n">mu</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">ens_mean</span>
                        <span class="n">sigma</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_e</span>
                        <span class="k">if</span> <span class="n">need_ensemble</span><span class="p">:</span>
                            <span class="n">cal_ens</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_gp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Apply calibration</span>
                        <span class="n">mu</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">ens_mean</span>
                        <span class="n">sigma</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma_e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">need_ensemble</span><span class="p">:</span>
                            <span class="n">cal_ens</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> 
                                                         <span class="n">sigma</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">anom</span><span class="p">)</span>
                            
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Fallback to raw forecast</span>
                    <span class="n">mu</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">sigma</span><span class="p">[:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">need_ensemble</span><span class="p">:</span>
                        <span class="n">cal_ens</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span>
        
        <span class="c1"># Package results</span>
        <span class="k">if</span> <span class="n">use_xarray</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">need_ensemble</span><span class="p">:</span>
                <span class="n">ens_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">cal_ens</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="n">member_dim</span><span class="p">:</span> <span class="n">member_coords</span><span class="p">,</span>
                        <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_coords</span><span class="p">,</span>
                        <span class="n">lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                        <span class="n">lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                    <span class="p">},</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;calibrated_ensemble&#39;</span>
                <span class="p">)</span>
                <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;calibrated_ensemble&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ens_da</span>
            
            <span class="c1"># Add mean and std</span>
            <span class="n">mu_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">mu</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                    <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_coords</span><span class="p">,</span>
                    <span class="n">lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                    <span class="n">lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                <span class="p">},</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;calibrated_mean&#39;</span>
            <span class="p">)</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;calibrated_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu_da</span>
            
            <span class="n">sigma_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">sigma</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="n">mu_da</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;calibrated_std&#39;</span>
            <span class="p">)</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;calibrated_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_da</span>
            
            <span class="c1"># Compute quantiles if requested</span>
            <span class="k">if</span> <span class="n">quantiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parametric</span><span class="p">:</span>
                    <span class="c1"># Parametric quantiles from Gaussian distribution</span>
                    <span class="n">quant_np</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q_levels</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">+</span> <span class="n">mu</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Empirical quantiles from calibrated ensemble</span>
                    <span class="n">quant_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">cal_ens</span><span class="p">,</span> <span class="n">q_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                
                <span class="n">quant_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">quant_np</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;quantile&#39;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s1">&#39;quantile&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">q_levels</span><span class="p">),</span>
                        <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_coords</span><span class="p">,</span>
                        <span class="n">lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                        <span class="n">lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                    <span class="p">},</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;calibrated_quantiles&#39;</span>
                <span class="p">)</span>
                <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;calibrated_quantiles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant_da</span>
            
            <span class="c1"># Compute tercile probabilities if requested</span>
            <span class="k">if</span> <span class="n">clim_terciles</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;clim_terciles=True in fit() required for tercile probabilities&quot;</span><span class="p">)</span>
                
                <span class="c1"># Extract climate terciles</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span> <span class="s1">&#39;isel&#39;</span><span class="p">):</span>
                    <span class="n">lower_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">tercile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">upper_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">tercile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lower_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">upper_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">parametric</span><span class="p">:</span>
                    <span class="c1"># Parametric probabilities from Gaussian distribution</span>
                    <span class="n">p_below</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lower_np</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="n">p_above</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">upper_np</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="n">p_near</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_below</span> <span class="o">-</span> <span class="n">p_above</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Empirical probabilities from calibrated ensemble</span>
                    <span class="n">lower_b</span> <span class="o">=</span> <span class="n">lower_np</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="n">upper_b</span> <span class="o">=</span> <span class="n">upper_np</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">cal_ens</span> <span class="o">&lt;</span> <span class="n">lower_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">p_above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">cal_ens</span> <span class="o">&gt;</span> <span class="n">upper_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">p_near</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_below</span> <span class="o">-</span> <span class="n">p_above</span>
                
                <span class="c1"># Package probabilities</span>
                <span class="n">cat_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">p_below</span><span class="p">,</span> <span class="n">p_near</span><span class="p">,</span> <span class="n">p_above</span><span class="p">])</span>
                <span class="n">cat_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">cat_np</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span> <span class="s1">&#39;PN&#39;</span><span class="p">,</span> <span class="s1">&#39;PA&#39;</span><span class="p">],</span>
                        <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_coords</span><span class="p">,</span>
                        <span class="n">lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                        <span class="n">lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                    <span class="p">},</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tercile_probability&#39;</span>
                <span class="p">)</span>
                <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;tercile_probability&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_da</span>
            
            <span class="k">return</span> <span class="n">ds</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return numpy arrays</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">if</span> <span class="n">need_ensemble</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cal_ens</span><span class="p">)</span>
            
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">quantiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parametric</span><span class="p">:</span>
                    <span class="n">quant_np</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q_levels</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">+</span> <span class="n">mu</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">quant_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">cal_ens</span><span class="p">,</span> <span class="n">q_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quant_np</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">clim_terciles</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;clim_terciles=True in fit() required&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span> <span class="s1">&#39;isel&#39;</span><span class="p">):</span>
                    <span class="n">lower_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">tercile</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">upper_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">tercile</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lower_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">upper_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">parametric</span><span class="p">:</span>
                    <span class="n">p_below</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lower_np</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="n">p_above</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">upper_np</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="n">p_near</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_below</span> <span class="o">-</span> <span class="n">p_above</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lower_b</span> <span class="o">=</span> <span class="n">lower_np</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="n">upper_b</span> <span class="o">=</span> <span class="n">upper_np</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="n">p_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">cal_ens</span> <span class="o">&lt;</span> <span class="n">lower_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">p_above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">cal_ens</span> <span class="o">&gt;</span> <span class="n">upper_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">p_near</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_below</span> <span class="o">-</span> <span class="n">p_above</span>
                
                <span class="n">cat_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">p_below</span><span class="p">,</span> <span class="n">p_near</span><span class="p">,</span> <span class="n">p_above</span><span class="p">])</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cat_np</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR.get_optimization_stats">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.get_optimization_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_optimization_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get optimization statistics from fitting.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stats : dict or None</span>
<span class="sd">            Dictionary containing optimization statistics if model is fitted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Model not fitted yet. Call fit() first.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Convert to xarray if using xarray</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                        <span class="n">value</span><span class="p">,</span>
                        <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">),</span>
                        <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_lat_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat_coords</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_lon_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon_coords</span>
                        <span class="p">},</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">key</span>
                    <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">stats</span></div>

    
<div class="viewcode-block" id="WAS_mme_NGR.summary">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_NGR.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print summary of the fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model not fitted.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WAS_mme_NGR Model Summary&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;========================&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Apply to: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_to</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Alpha: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test direction: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">test_direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="p">:</span>
            <span class="n">success_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">valid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">):</span>
                <span class="n">avg_crps_reduction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="p">[</span><span class="s1">&#39;crps_reduction&#39;</span><span class="p">][</span><span class="n">valid_mask</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="n">avg_iterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimization_stats</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">][</span><span class="n">valid_mask</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization Statistics:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Success rate: </span><span class="si">{</span><span class="n">success_rate</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Avg CRPS reduction: </span><span class="si">{</span><span class="n">avg_crps_reduction</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Avg iterations: </span><span class="si">{</span><span class="n">avg_iterations</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No successful optimizations.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parameter Statistics:&quot;</span><span class="p">)</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">):</span>
                    <span class="n">param_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">valid_params</span> <span class="o">=</span> <span class="n">param_data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">param_data</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: mean=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;std=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;range=(</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span></div>
</div>



<span class="c1"># Optional: Add parallel processing support for large grids</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nb</span>
    
<div class="viewcode-block" id="_apply_calibration_numba">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._apply_calibration_numba">[docs]</a>
    <span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_calibration_numba</span><span class="p">(</span><span class="n">fcst</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cal_ens</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Numba-accelerated calibration application.&quot;&quot;&quot;</span>
        <span class="n">nmemb</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="k">for</span> <span class="n">ilat</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">nlat</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ilon</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlon</span><span class="p">):</span>
                <span class="c1"># Get parameters for this grid point</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">itime</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntimes</span><span class="p">):</span>
                    <span class="c1"># Extract ensemble members for this time and grid point</span>
                    <span class="n">members</span> <span class="o">=</span> <span class="n">fcst</span><span class="p">[:,</span> <span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span>
                    
                    <span class="c1"># Check for NaN values</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
                    <span class="n">n_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">n_valid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mu</span><span class="p">[</span><span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">sigma</span><span class="p">[</span><span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="k">if</span> <span class="n">cal_ens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">imemb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmemb</span><span class="p">):</span>
                                <span class="n">cal_ens</span><span class="p">[</span><span class="n">imemb</span><span class="p">,</span> <span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Compute mean and std of valid members</span>
                    <span class="n">valid_members</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
                    <span class="n">ens_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_members</span><span class="p">)</span>
                    <span class="n">ens_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">valid_members</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
                    <span class="c1"># Avoid division by zero</span>
                    <span class="k">if</span> <span class="n">ens_std</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span>
                        <span class="n">ens_std</span> <span class="o">=</span> <span class="mf">1.0</span>
                    
                    <span class="c1"># Compute calibrated mean and std</span>
                    <span class="n">mu_val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">ens_mean</span>
                    <span class="n">sigma_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ens_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    
                    <span class="n">mu</span><span class="p">[</span><span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu_val</span>
                    <span class="n">sigma</span><span class="p">[</span><span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_val</span>
                    
                    <span class="c1"># Generate calibrated ensemble if needed</span>
                    <span class="k">if</span> <span class="n">cal_ens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Standardize anomalies</span>
                        <span class="n">anom</span> <span class="o">=</span> <span class="p">(</span><span class="n">valid_members</span> <span class="o">-</span> <span class="n">ens_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">ens_std</span>
                        <span class="n">cal_members</span> <span class="o">=</span> <span class="n">mu_val</span> <span class="o">+</span> <span class="n">sigma_val</span> <span class="o">*</span> <span class="n">anom</span>
                        
                        <span class="c1"># Fill calibrated members back</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">imemb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmemb</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">valid</span><span class="p">[</span><span class="n">imemb</span><span class="p">]:</span>
                                <span class="n">cal_ens</span><span class="p">[</span><span class="n">imemb</span><span class="p">,</span> <span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_members</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">cal_ens</span><span class="p">[</span><span class="n">imemb</span><span class="p">,</span> <span class="n">itime</span><span class="p">,</span> <span class="n">ilat</span><span class="p">,</span> <span class="n">ilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">return</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cal_ens</span></div>

    
<div class="viewcode-block" id="predict_fast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.predict_fast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcst_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Accelerated prediction using Numba (if available).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Model must be fitted before prediction.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Fall back to regular predict if Numba not available or inputs are xarray</span>
        <span class="k">if</span> <span class="n">xr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fcst_grid</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fcst_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># Extract arrays</span>
        <span class="n">fcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fcst_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        
        <span class="n">nmemb</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># Validate parameter dimensions</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter dimensions </span><span class="si">{</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2"> don&#39;t match forecast dimensions </span><span class="si">{</span><span class="n">nlat</span><span class="p">,</span><span class="w"> </span><span class="n">nlon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize output arrays</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ntimes</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">cal_ens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">fcst</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="c1"># Apply calibration using Numba</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cal_ens</span> <span class="o">=</span> <span class="n">_apply_calibration_numba</span><span class="p">(</span><span class="n">fcst</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">cal_ens</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cal_ens</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span></div>

    
    <span class="c1"># Add the method to the class</span>
    <span class="n">WAS_mme_NGR</span><span class="o">.</span><span class="n">predict_fast</span> <span class="o">=</span> <span class="n">predict_fast</span>
    
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Numba not available, use regular implementation</span>
    <span class="k">pass</span>

<span class="c1">######################################################################################################################################################################################################################################################################################</span>

<span class="c1">#################################################################################################################################################### MVA ############################################################</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span>

<span class="c1"># Optional SciPy (required for bestfit path)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">weibull_min</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">nbinom</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">fsolve</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_function</span>
    <span class="n">_HAS_SCIPY</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">_HAS_SCIPY</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># -----------------------------</span>
<span class="c1"># Per-cell helpers for ufuncs</span>
<span class="c1"># -----------------------------</span>
<div class="viewcode-block" id="_train_cell_mva">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._train_cell_mva">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_train_cell_mva</span><span class="p">(</span><span class="n">fc_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># (M, T)</span>
                    <span class="n">ob_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>   <span class="c1"># (T,)</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute MVA parameters for one (Y,X) cell over training period.</span>
<span class="sd">    Returns [clim_obs, clim_fcst, sigma_e, sigma_ref]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clim_obs</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ob_train</span><span class="p">)</span>
    <span class="n">clim_fcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fc_train</span><span class="p">)</span>                  <span class="c1"># over all memberstimes</span>
    <span class="n">sigma_e</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fc_train</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># over all memberstimes</span>
    <span class="n">sigma_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ob_train</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># over time</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">clim_obs</span><span class="p">,</span> <span class="n">clim_fcst</span><span class="p">,</span> <span class="n">sigma_e</span><span class="p">,</span> <span class="n">sigma_ref</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>



<div class="viewcode-block" id="_apply_cell_mva">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._apply_cell_mva">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_apply_cell_mva</span><span class="p">(</span><span class="n">fc_new</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>      <span class="c1"># (M, Tnew) or (M,)</span>
                    <span class="n">clim_obs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">clim_fcst</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">sigma_e</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">sigma_ref</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply MVA to forecast members (Y,X cell). Vectorized over time.</span>
<span class="sd">    Fallback (ill-conditioned): climatology-only shift: (F - clim_fcst) + clim_obs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fc_new</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fc_new</span> <span class="o">=</span> <span class="n">fc_new</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma_e</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma_e</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma_ref</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma_ref</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">fc_new</span> <span class="o">-</span> <span class="n">clim_fcst</span> <span class="o">+</span> <span class="n">clim_obs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fc_new</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">sigma_ref</span> <span class="o">/</span> <span class="n">sigma_e</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">fc_new</span> <span class="o">-</span> <span class="n">clim_fcst</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">clim_obs</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fc_new</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="_loocv_cell_mva">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._loocv_cell_mva">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_loocv_cell_mva</span><span class="p">(</span><span class="n">fc_cell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># (M, T)</span>
                    <span class="n">ob_cell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>   <span class="c1"># (T,)</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LOOCV over T for one (Y,X) cell.</span>
<span class="sd">    For each held-out t, train on T\\{t} and apply to column t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">fc_cell</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fc_cell</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">);</span> <span class="n">mask</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fc_tr</span> <span class="o">=</span> <span class="n">fc_cell</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
        <span class="n">ob_tr</span> <span class="o">=</span> <span class="n">ob_cell</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="n">clim_obs</span><span class="p">,</span> <span class="n">clim_fcst</span><span class="p">,</span> <span class="n">sigma_e</span><span class="p">,</span> <span class="n">sigma_ref</span> <span class="o">=</span> <span class="n">_train_cell_mva</span><span class="p">(</span><span class="n">fc_tr</span><span class="p">,</span> <span class="n">ob_tr</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">fc_cell</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>  <span class="c1"># (M,)</span>
        <span class="n">out</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">_apply_cell_mva</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">clim_obs</span><span class="p">,</span> <span class="n">clim_fcst</span><span class="p">,</span> <span class="n">sigma_e</span><span class="p">,</span> <span class="n">sigma_ref</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span></div>



<span class="c1"># -----------------------------</span>
<span class="c1"># Probability helpers (shared)</span>
<span class="c1"># -----------------------------</span>
<div class="viewcode-block" id="_ppf_terciles_from_code">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._ppf_terciles_from_code">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_ppf_terciles_from_code</span><span class="p">(</span><span class="n">dist_code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return terciles (T1, T2) from best-fit distribution parameters.</span>
<span class="sd">    Codes:</span>
<span class="sd">        1: norm, 2: lognorm, 3: expon, 4: gamma, 5: weibull_min,</span>
<span class="sd">        6: t,    7: poisson, 8: nbinom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">_HAS_SCIPY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">expon</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">gamma</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">weibull_min</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">nbinom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)))</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>



<div class="viewcode-block" id="_weibull_shape_solver">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._weibull_shape_solver">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_weibull_shape_solver</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Root of Weibull shape &#39;k&#39; so that Var/Mean^2 matches V/M^2.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>
        <span class="n">implied</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">g1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">observed</span> <span class="o">-</span> <span class="n">implied</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>



<div class="viewcode-block" id="_calc_tercile_probs_bestfit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._calc_tercile_probs_bestfit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_calc_tercile_probs_bestfit</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predictive tercile probabilities using the best-fit family per grid cell.</span>

<span class="sd">    Inputs per cell:</span>
<span class="sd">      best_guess : 1D array over T</span>
<span class="sd">      error_variance : scalar</span>
<span class="sd">      T1, T2 : scalars</span>
<span class="sd">      dist_code : int in {1..8}</span>
<span class="sd">      dof : degrees of freedom for t</span>
<span class="sd">    Output: (3, T) array: [PB, PN, PA]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_HAS_SCIPY</span><span class="p">:</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">error_variance</span><span class="p">)</span>
    <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_guess</span><span class="p">))</span>
        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ev</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">code</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist_code</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Normal</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ev</span><span class="p">))</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Lognormal</span>
        <span class="n">mu_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">var_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mf">1e-24</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">var_x</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu_x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Exponential</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ev</span><span class="p">))</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span> <span class="o">-</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># Gamma</span>
        <span class="n">mu_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">var_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mf">1e-24</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">mu_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">var_x</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">var_x</span> <span class="o">/</span> <span class="n">mu_x</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># Weibull</span>
        <span class="n">var_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="n">M</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">best_guess</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">var_x</span>
            <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fsolve</span><span class="p">(</span><span class="n">_weibull_shape_solver</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">lam</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">gamma_function</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">k</span><span class="p">))</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">weibull_min</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># Student-t</span>
        <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ev</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>  <span class="c1"># Poisson</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>  <span class="c1"># Negative Binomial (overdispersed)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">V</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">V</span> <span class="o">&gt;</span> <span class="n">mu</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="p">(</span><span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">mu</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">V</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c2</span>

    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="_calc_tercile_probs_nonparam">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._calc_tercile_probs_nonparam">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_calc_tercile_probs_nonparam</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">first_tercile</span><span class="p">,</span> <span class="n">second_tercile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Non-parametric method using historical error samples.&quot;&quot;&quot;</span>
    <span class="n">best_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">best_guess</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>   <span class="c1"># (T,)</span>
    <span class="n">dist_err</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_samples</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>  <span class="c1"># (T,)</span>
    <span class="n">n_time</span> <span class="o">=</span> <span class="n">best_guess</span><span class="o">.</span><span class="n">size</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">best_guess</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dist_err</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">p_below</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span>  <span class="n">first_tercile</span><span class="p">))</span>
        <span class="n">p_between</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">first_tercile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">second_tercile</span><span class="p">)))</span>
        <span class="n">p_above</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p_below</span> <span class="o">+</span> <span class="n">p_between</span><span class="p">))</span>
        <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_below</span>
        <span class="n">pred</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_between</span>
        <span class="n">pred</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_above</span>
    <span class="k">return</span> <span class="n">pred</span></div>



<span class="c1"># -----------------------------</span>
<span class="c1"># Public API (M, T, Y, X)</span>
<span class="c1"># -----------------------------</span>
<div class="viewcode-block" id="WAS_mme_MVA">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_MVA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method 1 of Torralba et al. (2017) (MVA): rescales ensemble to match obs mean &amp; std.</span>
<span class="sd">    Assumes both reference and predicted distributions are approximately Gaussian.</span>

<span class="sd">    Expected dims:</span>
<span class="sd">      hindcast: (M, T, Y, X)</span>
<span class="sd">      obs     : (T, Y, X)</span>
<span class="sd">      forecast: (M, T, Y, X)</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    - fit(hindcast, obs)</span>
<span class="sd">    - transform(forecast)</span>
<span class="sd">    - fit_transform_loocv(hindcast, obs)</span>
<span class="sd">    - compute_prob(Predictant, clim_year_start, clim_year_end, hindcast_det, ...)</span>
<span class="sd">    - forecast(Predictant, clim_year_start, clim_year_end, hindcast_det, forecast_det, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_mme_MVA.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;bestfit&quot;</span><span class="p">,</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nonparam&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span> <span class="o">=</span> <span class="n">dist_method</span></div>


    <span class="c1"># -------- fit --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hindcast</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WAS_mme_MVA&quot;</span><span class="p">:</span>
        <span class="c1"># Coerce order</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">((</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">hindcast</span> <span class="o">=</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span> <span class="s2">&quot;hindcast must include (M,T,...)&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span> <span class="s2">&quot;obs must include T&quot;</span>

        <span class="n">hc</span><span class="p">,</span> <span class="n">ob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">hindcast</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>

        <span class="n">packed</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_train_cell_mva</span><span class="p">,</span>
            <span class="n">hc</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;param&quot;</span><span class="p">]],</span>
            <span class="n">output_sizes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>              <span class="c1"># [clim_obs, clim_fcst, sigma_e, sigma_ref]</span>
            <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">packed</span> <span class="o">=</span> <span class="n">packed</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;clim_obs&quot;</span><span class="p">,</span><span class="s2">&quot;clim_fcst&quot;</span><span class="p">,</span><span class="s2">&quot;sigma_e&quot;</span><span class="p">,</span><span class="s2">&quot;sigma_ref&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params_</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;clim_obs&quot;</span><span class="p">:</span>  <span class="n">packed</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="s2">&quot;clim_obs&quot;</span><span class="p">),</span>
            <span class="s2">&quot;clim_fcst&quot;</span><span class="p">:</span> <span class="n">packed</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="s2">&quot;clim_fcst&quot;</span><span class="p">),</span>
            <span class="s2">&quot;sigma_e&quot;</span><span class="p">:</span>   <span class="n">packed</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="s2">&quot;sigma_e&quot;</span><span class="p">),</span>
            <span class="s2">&quot;sigma_ref&quot;</span><span class="p">:</span> <span class="n">packed</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="s2">&quot;sigma_ref&quot;</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="c1"># -------- transform --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.transform">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecast</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call fit() before transform().&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure (M, T, ...) order; promote deterministic to M=1</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">((</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">forecast</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">forecast</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">forecast</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;forecast must include T&quot;</span>
            <span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># broadcast params to spatial template</span>
        <span class="n">tpl_yx</span> <span class="o">=</span> <span class="n">forecast</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">clim_obs</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_</span><span class="p">[</span><span class="s2">&quot;clim_obs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="n">tpl_yx</span><span class="p">)</span>
        <span class="n">clim_fcst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_</span><span class="p">[</span><span class="s2">&quot;clim_fcst&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="n">tpl_yx</span><span class="p">)</span>
        <span class="n">sigma_e</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_</span><span class="p">[</span><span class="s2">&quot;sigma_e&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="n">tpl_yx</span><span class="p">)</span>
        <span class="n">sigma_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_</span><span class="p">[</span><span class="s2">&quot;sigma_ref&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="n">tpl_yx</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_apply_cell_mva</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">co</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">))</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_apply</span><span class="p">,</span>
            <span class="n">forecast</span><span class="p">,</span> <span class="n">clim_obs</span><span class="p">,</span> <span class="n">clim_fcst</span><span class="p">,</span> <span class="n">sigma_e</span><span class="p">,</span> <span class="n">sigma_ref</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">]],</span>
            <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">forecast</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">forecast</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;calibrated_mva&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># -------- LOOCV on hindcast (crossval=TRUE) --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.fit_transform_loocv">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.fit_transform_loocv">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_transform_loocv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hindcast</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">((</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">hindcast</span> <span class="o">=</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">hindcast</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span> <span class="s2">&quot;hindcast must include (M,T,...)&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span> <span class="s2">&quot;obs must include T&quot;</span>

        <span class="n">hc</span><span class="p">,</span> <span class="n">ob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">hindcast</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_loocv_cell_mva</span><span class="p">,</span>
            <span class="n">hc</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">]],</span>
            <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">hindcast</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">hindcast</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;hindcast&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_mva_loocv&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># -------- Calibrated ensemble mean --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.predict_mean">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.predict_mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecast</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calibrate members then return ensemble mean over M: (T,Y,X).&quot;&quot;&quot;</span>
        <span class="n">cal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">forecast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cal</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="c1"># -------- Hindcast probabilities --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.compute_prob">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.compute_prob">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># obs (T,Y,X) or (T,M,Y,X) -&gt; squeezed to (T,Y,X)</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_cross</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> 
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute tercile probabilities for deterministic hindcasts.</span>

<span class="sd">        If dist_method == &#39;bestfit&#39;:</span>
<span class="sd">          - derive climatological terciles analytically from (best_code/shape/loc/scale)</span>
<span class="sd">            and compute predictive probabilities with the same family.</span>
<span class="sd">        Else (&#39;nonparam&#39;):</span>
<span class="sd">          - use empirical terciles and historical error samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># squeeze potential member dim in obs; enforce order</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Predictant</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>


        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># climatology slice</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough years in climatology period for terciles.&quot;</span><span class="p">)</span>

        <span class="c1"># error variance (per grid) and dof</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_cross</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">clim</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span><span class="p">)</span>

            <span class="c1"># T1,T2 from best-fit family</span>
            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),(),(),()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_calc_tercile_probs_bestfit</span><span class="p">,</span>
                <span class="n">hindcast_cross</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">),</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;nonparam&#39;</span>
            <span class="c1"># empirical terciles on clim</span>
            <span class="n">terc</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terc</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terc</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_det</span><span class="p">)</span>

            <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_calc_tercile_probs_nonparam</span><span class="p">,</span>
                <span class="n">hindcast_cross</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">),</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">T1_emp</span><span class="p">,</span> <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="n">hindcast_prob</span> <span class="o">=</span> <span class="n">hindcast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span><span class="s2">&quot;PN&quot;</span><span class="p">,</span><span class="s2">&quot;PA&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hindcast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># -------- Forecast (deterministic mean + probabilities) --------</span>
<div class="viewcode-block" id="WAS_mme_MVA.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_MVA.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>    <span class="c1"># obs (T,Y,X) or (T,M,Y,X) -&gt; squeezed to (T,Y,X)</span>
        <span class="n">clim_year_start</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>  
        <span class="n">hindcast_cross</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>  <span class="c1"># deterministic hindcast (T,Y,X)</span>
        <span class="n">forecast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>  <span class="c1"># (M,T,Y,X) or (T,Y,X)</span>
        <span class="n">best_code_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_shape_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_loc_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">best_scale_da</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calibrate forecast and return (calibrated_deterministic_mean, tercile_probs).&quot;&quot;&quot;</span>
        <span class="c1"># Prepare obs/hindcast</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">Predictant</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Predictant</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">hindcast_det</span> <span class="o">=</span> <span class="n">hindcast_det</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Fit MVA on hindcast/obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hindcast_det</span><span class="p">,</span> <span class="n">Predictant</span><span class="p">)</span>

        <span class="c1"># Calibrated deterministic forecast mean</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">in</span> <span class="n">forecast_det</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">fc_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_mean</span><span class="p">(</span><span class="n">forecast_det</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fc_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">forecast_det</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="c1"># Stamp one T (use forecast year + obs first-month)</span>
        <span class="n">t_fc0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">fc_mean</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Y&quot;</span><span class="p">)</span>
        <span class="n">year</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_fc0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1970</span><span class="p">)</span>
        <span class="n">t_obs0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">Predictant</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span>
        <span class="n">month</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_obs0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_T</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">:</span><span class="s2">04d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>
        <span class="n">fc_mean</span> <span class="o">=</span> <span class="n">fc_mean</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">new_T</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Probabilities</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_method</span>
        <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s2">&quot;bestfit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dist_method=&#39;bestfit&#39; requires best_code_da, best_shape_da, best_loc_da, best_scale_da.&quot;</span><span class="p">)</span>

            <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_ppf_terciles_from_code</span><span class="p">,</span>
                <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(),(),(),()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(),()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">error_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_cross</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Predictant</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_calc_tercile_probs_bestfit</span><span class="p">,</span>
                <span class="n">fc_mean</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dof&quot;</span><span class="p">:</span> <span class="n">dof</span><span class="p">},</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;nonparam&#39;</span>
            <span class="c1"># empirical terciles on climatology period</span>
            <span class="n">idx_start</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">))</span><span class="o">.</span><span class="n">start</span>
            <span class="n">idx_end</span>   <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">))</span><span class="o">.</span><span class="n">stop</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">))</span>
            <span class="n">terc</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">T1_emp</span> <span class="o">=</span> <span class="n">terc</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">T2_emp</span> <span class="o">=</span> <span class="n">terc</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">error_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">Predictant</span> <span class="o">-</span> <span class="n">hindcast_cross</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;M&quot;</span><span class="p">))</span>

            <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_calc_tercile_probs_nonparam</span><span class="p">,</span>
                <span class="n">fc_mean</span><span class="p">,</span> <span class="n">error_samples</span><span class="p">,</span> <span class="n">T1_emp</span><span class="p">,</span> <span class="n">T2_emp</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">)],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s2">&quot;allow_rechunk&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="n">forecast_prob</span> <span class="o">=</span> <span class="n">forecast_prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span><span class="s2">&quot;PN&quot;</span><span class="p">,</span><span class="s2">&quot;PA&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">fc_mean</span> <span class="o">*</span> <span class="n">mask</span><span class="p">),</span> <span class="p">(</span><span class="n">forecast_prob</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">)</span></div>
</div>


    
<span class="c1"># ==========================================================</span>
<span class="c1"># Roebber (2015) procedural EP/GA implementation</span>
<span class="c1">#   - Sexual selection</span>
<span class="c1">#   - Paternal coefficients retained in crossover</span>
<span class="c1">#   - Mutation + transposition (copy error)</span>
<span class="c1">#   - Survivors define predictive distribution</span>
<span class="c1"># ==========================================================</span>

<span class="n">CONST1</span> <span class="o">=</span> <span class="s2">&quot;__CONST1__&quot;</span>


<div class="viewcode-block" id="_safe_float">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._safe_float">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_safe_float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="_norm01">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._norm01">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_norm01</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalize to [0,1] using min/max; return (norm, min, max).&quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mx</span><span class="p">))</span> <span class="ow">or</span> <span class="n">mx</span> <span class="o">==</span> <span class="n">mn</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mn</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">mn</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span></div>



<div class="viewcode-block" id="_inv_norm01">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._inv_norm01">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_inv_norm01</span><span class="p">(</span><span class="n">a01</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mn</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mx</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">a01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a01</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mx</span><span class="p">))</span> <span class="ow">or</span> <span class="n">mx</span> <span class="o">==</span> <span class="n">mn</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a01</span> <span class="o">*</span> <span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span> <span class="o">+</span> <span class="n">mn</span></div>



<span class="c1"># ==========================================================</span>
<span class="c1"># EP Gene (faithful roles):</span>
<span class="c1">#   Gate uses (V1, OR, V2)</span>
<span class="c1">#   Expression uses (C1*V3 O1 C2*V4) O2 C3*V5</span>
<span class="c1">#   Variables may be predictors or CONST1</span>
<span class="c1"># ==========================================================</span>
<div class="viewcode-block" id="EP_Gene">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EP_Gene</span><span class="p">:</span>
    <span class="n">OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;ADD&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
        <span class="s2">&quot;MULTIPLY&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">REL_OPS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
        <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="EP_Gene.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">rng</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predictor_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;predictor_names must be non-empty&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="c1"># gate vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OR</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">REL_OPS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># expression vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v3</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v4</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>

        <span class="c1"># coefficients in [-1,1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c3</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">O1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">O2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>


<div class="viewcode-block" id="EP_Gene.copy">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EP_Gene&quot;</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">EP_Gene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">v2</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">OR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OR</span>
        <span class="n">g</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v5</span>
        <span class="n">g</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">c3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c3</span>
        <span class="n">g</span><span class="o">.</span><span class="n">O1</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">O2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">O1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O2</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="EP_Gene._get_val">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene._get_val">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">CONST1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">_safe_float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span></div>


<div class="viewcode-block" id="EP_Gene.evaluate">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v2</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># gate: v1 OR v2 (relational comparison)</span>
        <span class="c1"># Example: if OR is &quot;&lt;=&quot;, then check if v1 &lt;= v2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gate_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">REL_OPS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">OR</span><span class="p">](</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">gate_result</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gate_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">v3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3</span><span class="p">)</span>
        <span class="n">v4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v4</span><span class="p">)</span>
        <span class="n">v5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v5</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v5</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">*</span> <span class="n">v3</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">*</span> <span class="n">v4</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c3</span> <span class="o">*</span> <span class="n">v5</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># First operation</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">O1</span><span class="p">](</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
            <span class="c1"># Second operation</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">O2</span><span class="p">](</span><span class="n">res</span><span class="p">,</span> <span class="n">t3</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>


    <span class="c1"># ---- Roebber (2015) crossover rule helper</span>
<div class="viewcode-block" id="EP_Gene.replace_structure_from_maternal_keep_paternal_coeffs">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene.replace_structure_from_maternal_keep_paternal_coeffs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace_structure_from_maternal_keep_paternal_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maternal</span><span class="p">:</span> <span class="s2">&quot;EP_Gene&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># keep c1,c2,c3; replace variables + operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OR</span> <span class="o">=</span> <span class="n">maternal</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="n">maternal</span><span class="o">.</span><span class="n">v2</span><span class="p">,</span> <span class="n">maternal</span><span class="o">.</span><span class="n">OR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="n">maternal</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="n">maternal</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="n">maternal</span><span class="o">.</span><span class="n">v5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">O1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O2</span> <span class="o">=</span> <span class="n">maternal</span><span class="o">.</span><span class="n">O1</span><span class="p">,</span> <span class="n">maternal</span><span class="o">.</span><span class="n">O2</span></div>


    <span class="c1"># ---- Roebber (2015) mutation (at most one gene; element-wise weights)</span>
<div class="viewcode-block" id="EP_Gene.mutate_element">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Gene.mutate_element">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutate_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements the mutation menu and approximate weights from Roebber (2015):</span>
<span class="sd">          overall mutation is handled by the caller (50%).</span>
<span class="sd">          then select ONE element type to mutate in this gene.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># weights (relative)  we use exact probabilities as weights</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;V1&quot;</span><span class="p">,</span> <span class="mf">0.03125</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;OR&quot;</span><span class="p">,</span> <span class="mf">0.03125</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;O1&quot;</span><span class="p">,</span> <span class="mf">0.03125</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;O2&quot;</span><span class="p">,</span> <span class="mf">0.03125</span><span class="p">),</span>

            <span class="p">(</span><span class="s2">&quot;V2&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V3&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V4&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V5&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>

            <span class="p">(</span><span class="s2">&quot;V2_TO_CONST1&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V3_TO_CONST1&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V4_TO_CONST1&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;V5_TO_CONST1&quot;</span><span class="p">,</span> <span class="mf">0.015625</span><span class="p">),</span>

            <span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span> <span class="mf">0.0833</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;C2&quot;</span><span class="p">,</span> <span class="mf">0.0833</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;C3&quot;</span><span class="p">,</span> <span class="mf">0.0833</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V2&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V3&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v3</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V4&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v4</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V5&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V2_TO_CONST1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">CONST1</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V3_TO_CONST1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v3</span> <span class="o">=</span> <span class="n">CONST1</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V4_TO_CONST1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v4</span> <span class="o">=</span> <span class="n">CONST1</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;V5_TO_CONST1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="n">CONST1</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;OR&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OR</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">REL_OPS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;O1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">O1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;O2&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">O2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OPERATORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;C1&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;C2&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pick</span> <span class="o">==</span> <span class="s2">&quot;C3&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c3</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>
</div>



<span class="c1"># ==========================================================</span>
<span class="c1"># Individual (algorithm) = sum of EP-genes</span>
<span class="c1"># ==========================================================</span>
<div class="viewcode-block" id="EP_Individual">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EP_Individual</span><span class="p">:</span>
<div class="viewcode-block" id="EP_Individual.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">num_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rng</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">,</span> <span class="n">sex</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sex</span> <span class="o">=</span> <span class="n">sex</span>  <span class="c1"># &quot;M&quot; or &quot;F&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EP_Gene</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">EP_Gene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_genes</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mse</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EP_Individual.copy">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EP_Individual&quot;</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">EP_Individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_names</span><span class="p">,</span> <span class="n">num_genes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">sex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sex</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">]</span>
        <span class="n">c</span><span class="o">.</span><span class="n">mse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mse</span>
        <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="EP_Individual.predict_row">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.predict_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total</span><span class="p">)</span></div>


<div class="viewcode-block" id="EP_Individual.compute_mse">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.compute_mse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_mse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">y_norm</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mse</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">predict_row</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># work in normalized [0,1] space</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">y_norm</span> <span class="o">-</span> <span class="n">preds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mse</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">err</span> <span class="o">*</span> <span class="n">err</span><span class="p">))</span></div>


    <span class="c1"># ---- Roebber (2015) crossover</span>
<div class="viewcode-block" id="EP_Individual.crossover">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.crossover">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">crossover</span><span class="p">(</span><span class="n">paternal</span><span class="p">:</span> <span class="s2">&quot;EP_Individual&quot;</span><span class="p">,</span> <span class="n">maternal</span><span class="p">:</span> <span class="s2">&quot;EP_Individual&quot;</span><span class="p">,</span> <span class="n">rng</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EP_Individual&quot;</span><span class="p">:</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">paternal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># seed with paternal EP-genes</span>
        <span class="c1"># per gene: 50% replace structure with maternal gene but keep paternal coefficients</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">replace_structure_from_maternal_keep_paternal_coeffs</span><span class="p">(</span><span class="n">maternal</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">child</span></div>


    <span class="c1"># ---- Roebber (2015) transposition (copy error)</span>
<div class="viewcode-block" id="EP_Individual.transposition">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.EP_Individual.transposition">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transposition</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="s2">&quot;EP_Individual&quot;</span><span class="p">,</span> <span class="n">rng</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy one EP-gene segment from one line to another.</span>
<span class="sd">        Segment set (as in Roebber 2015 text):</span>
<span class="sd">          A: (V1, OR, V2)</span>
<span class="sd">          B: (C1, V3, O1)</span>
<span class="sd">          C: (C2, V4, O2)</span>
<span class="sd">          D: (C3, V5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">))</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">))</span>

        <span class="n">seg</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">])</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>
        <span class="n">gd</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">seg</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
            <span class="n">gd</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">v2</span>
        <span class="k">elif</span> <span class="n">seg</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
            <span class="n">gd</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">O1</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">v3</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">O1</span>
        <span class="k">elif</span> <span class="n">seg</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
            <span class="n">gd</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">O2</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">v4</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">O2</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;D&quot;</span>
            <span class="n">gd</span><span class="o">.</span><span class="n">c3</span><span class="p">,</span> <span class="n">gd</span><span class="o">.</span><span class="n">v5</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">c3</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">v5</span></div>
</div>



<span class="c1"># ==========================================================</span>
<span class="c1"># Main Driver Class (Roebber 2015 faithful evolution)</span>
<span class="c1"># ==========================================================</span>
<div class="viewcode-block" id="Roebber2015Config">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.Roebber2015Config">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Roebber2015Config</span><span class="p">:</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">num_genes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="n">max_mates_per_male</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># top male can mate up to 10 females (and similarly for next males)</span>
    <span class="n">qualify_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.50</span>  <span class="c1"># starting point for an MSE threshold (tightened each generation)</span>
    <span class="n">tighten_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.97</span>    <span class="c1"># decreases threshold each generation (stricter)</span>
    <span class="n">relax_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.10</span>      <span class="c1"># if qualifying pop &lt; min_qualify, relax threshold upward by 10%</span>
    <span class="n">min_qualify</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>           <span class="c1"># &quot;critical number&quot; mentioned in Roebber 2015</span>

    <span class="n">p_mutation</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.50</span>        <span class="c1"># overall mutation probability</span>
    <span class="n">p_transposition</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.50</span>   <span class="c1"># overall transposition probability</span>

    <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span></div>



<div class="viewcode-block" id="WAS_mme_Roebber2015">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_mme_Roebber2015</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Procedurally faithful Roebber (2015) EP / GA trainer for gridded xarray inputs.</span>

<span class="sd">      - sexual selection mating system</span>
<span class="sd">      - paternal coefficients retained in crossover</span>
<span class="sd">      - mutation + transposition rules</span>
<span class="sd">      - probabilistic output uses surviving population predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_mme_Roebber2015.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Roebber2015Config</span> <span class="o">=</span> <span class="n">Roebber2015Config</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">random_state</span><span class="p">))</span>

        <span class="c1"># Stored normalization for later prediction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_minmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pred_minmax</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># survivors after training at a gridpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_survivors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">EP_Individual</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_threshold_final</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="c1"># -------------------------</span>
    <span class="c1"># data prep per grid-point</span>
    <span class="c1"># -------------------------</span>
<div class="viewcode-block" id="WAS_mme_Roebber2015._prep_rows">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015._prep_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_prep_rows</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X_train_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># (n, M)</span>
        <span class="n">y_train_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># (n,)</span>
        <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># normalize y to [0,1]</span>
        <span class="n">y_norm</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">_norm01</span><span class="p">(</span><span class="n">y_train_1d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_minmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

        <span class="c1"># normalize each predictor to [0,1]</span>
        <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pred_minmax</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">X_train_1d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">X_train_1d</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">coln</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">_norm01</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pred_minmax</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">)</span>
            <span class="n">Xn</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coln</span>

        <span class="c1"># build rows; drop samples with any NaN predictor or y</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_norm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Xn</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xn</span> <span class="o">=</span> <span class="n">Xn</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">y_norm</span> <span class="o">=</span> <span class="n">y_norm</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Xn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">{</span><span class="n">predictor_names</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Xn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">y_norm</span></div>


<div class="viewcode-block" id="WAS_mme_Roebber2015._norm_test_rows">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015._norm_test_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_norm_test_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_test_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">Xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">X_test_1d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">):</span>
            <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred_minmax</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">X_test_1d</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mx</span><span class="p">))</span> <span class="ow">or</span> <span class="n">mx</span> <span class="o">==</span> <span class="n">mn</span><span class="p">:</span>
                <span class="n">Xn</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">normed</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span>
                    <span class="n">Xn</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">normed</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Xn</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[{</span><span class="n">predictor_names</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Xn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span> 
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_valid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_valid</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">valid</span></div>


    <span class="c1"># -------------------------</span>
    <span class="c1"># Evolution: sexual selection + replacement + thresholds</span>
    <span class="c1"># -------------------------</span>
<div class="viewcode-block" id="WAS_mme_Roebber2015._init_population">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015._init_population">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_init_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">EP_Individual</span><span class="p">]:</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span><span class="p">)):</span>
            <span class="n">sex</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="s2">&quot;F&quot;</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EP_Individual</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">,</span> <span class="n">num_genes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">num_genes</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">,</span> <span class="n">sex</span><span class="o">=</span><span class="n">sex</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pop</span></div>


<div class="viewcode-block" id="WAS_mme_Roebber2015._compute_threshold">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015._compute_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mses</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">prev_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">mses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mses</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">mses</span> <span class="o">=</span> <span class="n">mses</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mses</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">mses</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        
        <span class="n">base</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">mses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">qualify_quantile</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">prev_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">prev_threshold</span><span class="p">):</span>
            <span class="n">thr</span> <span class="o">=</span> <span class="n">base</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># tighten by factor (stricter = smaller MSE allowed)</span>
            <span class="n">thr</span> <span class="o">=</span> <span class="n">prev_threshold</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">tighten_factor</span><span class="p">)</span>
        
        <span class="c1"># Never let threshold go below base quantile</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">thr</span></div>


<div class="viewcode-block" id="WAS_mme_Roebber2015._evolve">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015._evolve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_evolve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">y_norm</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">predictor_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">EP_Individual</span><span class="p">]:</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_population</span><span class="p">(</span><span class="n">predictor_names</span><span class="p">)</span>
        <span class="n">thr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">max_iter</span><span class="p">)):</span>
            <span class="c1"># evaluate MSE</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">:</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">compute_mse</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">y_norm</span><span class="p">)</span>
            
            <span class="n">mses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">thr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_threshold</span><span class="p">(</span><span class="n">mses</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
            
            <span class="c1"># Count qualifying individuals</span>
            <span class="n">qualify</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="o">&lt;=</span> <span class="n">thr</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">qcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qualify</span><span class="p">))</span>
            
            <span class="c1"># Relax threshold if too few qualify</span>
            <span class="n">relax_loops</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">qcount</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">min_qualify</span><span class="p">)</span> <span class="ow">and</span> <span class="n">relax_loops</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">thr</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">relax_factor</span><span class="p">)</span>  <span class="c1"># +10% relaxation</span>
                <span class="n">qualify</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="o">&lt;=</span> <span class="n">thr</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">qcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qualify</span><span class="p">))</span>
                <span class="n">relax_loops</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># If still not enough qualifiers, use all individuals</span>
            <span class="k">if</span> <span class="n">qcount</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">min_qualify</span><span class="p">):</span>
                <span class="c1"># Keep all individuals for this generation</span>
                <span class="k">pass</span>
            
            <span class="c1"># partition qualifying males/females</span>
            <span class="n">males</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">))</span> <span class="k">if</span> <span class="n">qualify</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">]</span>
            <span class="n">females</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">))</span> <span class="k">if</span> <span class="n">qualify</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">]</span>
            
            <span class="c1"># rank males by MSE (lower is better)</span>
            <span class="n">males</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">mse</span><span class="p">)</span>
            
            <span class="n">offspring</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EP_Individual</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># cloning of top-ranked male (if available)</span>
            <span class="k">if</span> <span class="n">males</span><span class="p">:</span>
                <span class="n">offspring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">males</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            
            <span class="c1"># mating loop</span>
            <span class="n">remaining_females</span> <span class="o">=</span> <span class="n">females</span><span class="p">[:]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">males</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_females</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">n_mates</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">max_mates_per_male</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_females</span><span class="p">))</span>
                <span class="n">mates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">remaining_females</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n_mates</span><span class="p">)</span>
                <span class="c1"># remove females after mating</span>
                <span class="n">remaining_females</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">remaining_females</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mates</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mates</span><span class="p">:</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="n">EP_Individual</span><span class="o">.</span><span class="n">crossover</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">sex</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="s2">&quot;F&quot;</span>
                    
                    <span class="c1"># mutation (50% overall; at most one gene)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">p_mutation</span><span class="p">):</span>
                        <span class="n">gidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">))</span>
                        <span class="n">child</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">gidx</span><span class="p">]</span><span class="o">.</span><span class="n">mutate_element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>
                    
                    <span class="c1"># transposition (50% overall; independent)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">p_transposition</span><span class="p">):</span>
                        <span class="n">EP_Individual</span><span class="o">.</span><span class="n">transposition</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>
                    
                    <span class="n">offspring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            
            <span class="c1"># Create new population with qualifying individuals</span>
            <span class="n">new_pop</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">qualified_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qualify</span><span class="p">)</span> <span class="k">if</span> <span class="n">ok</span><span class="p">]</span>
            <span class="n">non_qualified_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qualify</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">]</span>
            
            <span class="c1"># Keep all qualified individuals</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">qualified_indices</span><span class="p">:</span>
                <span class="n">new_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            
            <span class="c1"># Replace non-qualified with offspring (up to available offspring)</span>
            <span class="n">offspring_to_use</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offspring</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_qualified_indices</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">offspring_to_use</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_qualified_indices</span><span class="p">):</span>
                    <span class="n">new_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offspring</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            
            <span class="c1"># If more offspring than non-qualified slots, add to population (capped at population_size)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offspring_to_use</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">offspring</span><span class="p">[</span><span class="n">offspring_to_use</span><span class="p">:]</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">extra</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span><span class="p">:</span>
                        <span class="n">new_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            
            <span class="c1"># Fill remaining slots with random individuals from old population if needed</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span><span class="p">:</span>
                <span class="n">needed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span>
                <span class="n">available</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">))</span> <span class="k">if</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_pop</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">available</span><span class="p">:</span>
                    <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">needed</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">available</span><span class="p">)))</span>
                    <span class="n">new_pop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>
            
            <span class="c1"># Trim to population size if needed</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span><span class="p">:</span>
                <span class="c1"># Sort by MSE and keep best</span>
                <span class="n">new_pop</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">mse</span><span class="p">)</span>
                <span class="n">new_pop</span> <span class="o">=</span> <span class="n">new_pop</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span><span class="p">]</span>
            
            <span class="n">pop</span> <span class="o">=</span> <span class="n">new_pop</span>
        
        <span class="c1"># Final evaluation</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">:</span>
            <span class="n">ind</span><span class="o">.</span><span class="n">compute_mse</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">y_norm</span><span class="p">)</span>
        <span class="n">mses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="c1"># Final threshold with relaxation safeguard</span>
        <span class="n">valid_mses</span> <span class="o">=</span> <span class="n">mses</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mses</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_mses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">thr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">valid_mses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">qualify_quantile</span><span class="p">))</span>
            <span class="n">qualify</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="o">&lt;=</span> <span class="n">thr</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">qcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qualify</span><span class="p">))</span>
            
            <span class="c1"># Relax if needed</span>
            <span class="n">relax_loops</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">qcount</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">min_qualify</span><span class="p">)</span> <span class="ow">and</span> <span class="n">relax_loops</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">thr</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">relax_factor</span><span class="p">)</span>
                <span class="n">qualify</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">mse</span> <span class="o">&lt;=</span> <span class="n">thr</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">qcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qualify</span><span class="p">))</span>
                <span class="n">relax_loops</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">survivors</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">))</span> <span class="k">if</span> <span class="n">qualify</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">survivors</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">survivors</span><span class="p">:</span>
            <span class="c1"># Fallback: keep best individuals</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">mse</span><span class="p">)</span>
            <span class="n">survivors</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">population_size</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">)))]</span>  <span class="c1"># Keep top 20%</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_threshold_final</span> <span class="o">=</span> <span class="n">thr</span> <span class="k">if</span> <span class="s1">&#39;thr&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">survivors</span></div>


    <span class="c1"># -------------------------</span>
    <span class="c1"># Core API: compute_model</span>
    <span class="c1"># -------------------------</span>
<div class="viewcode-block" id="WAS_mme_Roebber2015.compute_model">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015.compute_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X_train</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># (T,M,Y,X) preferred</span>
        <span class="n">y_train</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># (T,Y,X)</span>
        <span class="n">X_test</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>    <span class="c1"># (T,M,Y,X) or (T=1,M,Y,X)</span>
        <span class="n">return_ensemble</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_members</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">          y_mean: (T,Y,X) mean of survivors&#39; predictions</span>
<span class="sd">          y_ens:  (member,T,Y,X) survivors&#39; predictions (optional)</span>

<span class="sd">        Note: This is *probabilistic* by construction (survivors define predictive distribution).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;M&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">X_train</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;X_train must have dimension &#39;M&#39; (predictor/member)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">dims</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_train must have dims including (T,Y,X)&quot;</span><span class="p">)</span>

        <span class="c1"># enforce ordering</span>
        <span class="n">Xtr</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">Ytr</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>
        <span class="n">Xte</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

        <span class="n">predictor_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Xtr</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span> <span class="o">=</span> <span class="n">predictor_names</span>

        <span class="c1"># stack samples for training and testing</span>
        <span class="n">Xtr2</span> <span class="o">=</span> <span class="n">Xtr</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">Ytr1</span> <span class="o">=</span> <span class="n">Ytr</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>

        <span class="n">Xte2</span> <span class="o">=</span> <span class="n">Xte</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># drop NaNs in training</span>
        <span class="n">train_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Ytr1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Xtr2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xtr2</span> <span class="o">=</span> <span class="n">Xtr2</span><span class="p">[</span><span class="n">train_valid</span><span class="p">]</span>
        <span class="n">Ytr1</span> <span class="o">=</span> <span class="n">Ytr1</span><span class="p">[</span><span class="n">train_valid</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">Xtr2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="c1"># too few samples</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Xte</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">y_ens</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ensemble</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">y_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;member&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]},</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;member&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">y_ens</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">y_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prep_rows</span><span class="p">(</span><span class="n">Xtr2</span><span class="p">,</span> <span class="n">Ytr1</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">)</span>

        <span class="c1"># evolve survivors</span>
        <span class="n">survivors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evolve</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">y_norm</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_survivors</span> <span class="o">=</span> <span class="n">survivors</span>

        <span class="c1"># predict on test</span>
        <span class="n">test_rows</span><span class="p">,</span> <span class="n">test_valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_test_rows</span><span class="p">(</span><span class="n">Xte2</span><span class="p">,</span> <span class="n">predictor_names</span><span class="p">)</span>
        <span class="c1"># map back into the full sample layout</span>
        <span class="n">n_full</span> <span class="o">=</span> <span class="n">Xte2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">preds_members</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">survivors_use</span> <span class="o">=</span> <span class="n">survivors</span>
        <span class="k">if</span> <span class="n">max_members</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">survivors_use</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_members</span><span class="p">):</span>
            <span class="c1"># keep best max_members by training MSE</span>
            <span class="n">survivors_use</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">survivors_use</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">mse</span><span class="p">)[:</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_members</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">survivors_use</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_full</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># predict only valid rows</span>
            <span class="k">if</span> <span class="n">test_rows</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">ind</span><span class="o">.</span><span class="n">predict_row</span><span class="p">(</span><span class="n">test_rows</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_rows</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">test_rows</span><span class="p">))</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="c1"># place back</span>
                <span class="n">p</span><span class="p">[</span><span class="n">test_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="n">preds_members</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">preds_members</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">preds_members</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># (member, sample)</span>
        <span class="c1"># inverse normalize y</span>
        <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_minmax</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_minmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">preds_members_phys</span> <span class="o">=</span> <span class="n">_inv_norm01</span><span class="p">(</span><span class="n">preds_members</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

        <span class="c1"># reshape to (member,T,Y,X)</span>
        <span class="n">Tn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">,</span> <span class="n">Xn</span> <span class="o">=</span> <span class="n">Xte</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="n">Xte</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="n">Xte</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">preds_members_phys</span> <span class="o">=</span> <span class="n">preds_members_phys</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">preds_members_phys</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">,</span> <span class="n">Xn</span><span class="p">)</span>

        <span class="n">y_ens</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">return_ensemble</span><span class="p">:</span>
            <span class="n">y_ens</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">preds_members_phys</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;member&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">preds_members_phys</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]},</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;member&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;roebber2015_ens&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">y_mean</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">preds_members_phys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">],</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">Xte</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;roebber2015_mean&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">y_ens</span></div>


    <span class="c1"># -------------------------</span>
    <span class="c1"># Probabilities from evolved predictive distribution (terciles)</span>
    <span class="c1"># -------------------------</span>
<div class="viewcode-block" id="WAS_mme_Roebber2015.tercile_thresholds_from_obs">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015.tercile_thresholds_from_obs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tercile_thresholds_from_obs</span><span class="p">(</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Predictant</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clim_year_start</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">clim_year_end</span><span class="p">)))</span>
        <span class="n">q33</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">q66</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q33</span><span class="p">,</span> <span class="n">q66</span></div>


<div class="viewcode-block" id="WAS_mme_Roebber2015.tercile_probs_from_ensemble">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015.tercile_probs_from_ensemble">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tercile_probs_from_ensemble</span><span class="p">(</span>
        <span class="n">ens</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># (member,T,Y,X)</span>
        <span class="n">q33</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># (Y,X)</span>
        <span class="n">q66</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>   <span class="c1"># (Y,X)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="c1"># Broadcast thresholds</span>
        <span class="n">below</span> <span class="o">=</span> <span class="p">(</span><span class="n">ens</span> <span class="o">&lt;</span> <span class="n">q33</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;member&quot;</span><span class="p">)</span>
        <span class="n">above</span> <span class="o">=</span> <span class="p">(</span><span class="n">ens</span> <span class="o">&gt;</span> <span class="n">q66</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;member&quot;</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">below</span> <span class="o">-</span> <span class="n">above</span>

        <span class="n">below</span> <span class="o">=</span> <span class="n">below</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">above</span> <span class="o">=</span> <span class="n">above</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        
        <span class="n">prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">below</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">above</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">prob</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span></div>


    <span class="c1"># -------------------------</span>
    <span class="c1"># Forecast wrapper </span>
    <span class="c1"># -------------------------</span>
<div class="viewcode-block" id="WAS_mme_Roebber2015.forecast">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_mme_Roebber2015.forecast">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Predictant</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">clim_year_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">clim_year_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">hindcast_det</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>        <span class="c1"># (T,M,Y,X)</span>
        <span class="n">hindcast_det_cross</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>  <span class="c1"># kept for API compatibility </span>
        <span class="n">Predictor_for_year</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>  <span class="c1"># (T,M,Y,X) typically T=1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]:</span>
        <span class="c1"># deterministic + ensemble</span>
        <span class="n">y_mean</span><span class="p">,</span> <span class="n">y_ens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span>
            <span class="n">X_train</span><span class="o">=</span><span class="n">hindcast_det</span><span class="p">,</span>
            <span class="n">y_train</span><span class="o">=</span><span class="n">Predictant</span><span class="p">,</span>
            <span class="n">X_test</span><span class="o">=</span><span class="n">Predictor_for_year</span><span class="p">,</span>
            <span class="n">return_ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">y_ens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_mean</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">prob</span>

        <span class="c1"># enforce your forecast time logic</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">Predictor_for_year</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Predictor_for_year</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[Y]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1970</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="mi">1970</span>
        <span class="n">month_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Predictant</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[M]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">month_1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-01&quot;</span><span class="p">)</span>

        <span class="n">y_mean</span> <span class="o">=</span> <span class="n">y_mean</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="n">new_T</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))</span>
        <span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>

        <span class="n">y_ens</span> <span class="o">=</span> <span class="n">y_ens</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">y_mean</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>

        <span class="c1"># tercile thresholds and probabilities from evolved predictive distribution</span>
        <span class="n">q33</span><span class="p">,</span> <span class="n">q66</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tercile_thresholds_from_obs</span><span class="p">(</span><span class="n">Predictant</span><span class="p">,</span> <span class="n">clim_year_start</span><span class="p">,</span> <span class="n">clim_year_end</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tercile_probs_from_ensemble</span><span class="p">(</span><span class="n">y_ens</span><span class="p">,</span> <span class="n">q33</span><span class="p">,</span> <span class="n">q66</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">prob</span></div>
</div>


<span class="c1"># ============================================================</span>
<span class="c1"># BMA Shared utilities</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="_require_dims">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._require_dims">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_require_dims</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is missing required dims: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. Found dims=</span><span class="si">{</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="_normalize_weights">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._normalize_weights">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_normalize_weights</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span> <span class="o">/</span> <span class="n">s</span></div>



<div class="viewcode-block" id="compute_gridpoint_terciles_from_obs">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.compute_gridpoint_terciles_from_obs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
    <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
    <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">),</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute gridpoint tercile thresholds from observations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        dims (&#39;tercile&#39;, Y, X) with tercile labels [&#39;lower&#39;,&#39;upper&#39;] (by default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_require_dims</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="p">[</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;obs_for_terciles&quot;</span><span class="p">)</span>
    <span class="n">thr</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># dim name &#39;quantile&#39;</span>
    <span class="k">if</span> <span class="s2">&quot;quantile&quot;</span> <span class="ow">in</span> <span class="n">thr</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="s2">&quot;tercile&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thr</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="s2">&quot;tercile&quot;</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">thr</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">tercile</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">thr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span></div>



<div class="viewcode-block" id="_invert_cdf">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._invert_cdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_invert_cdf</span><span class="p">(</span><span class="n">cdf_fn</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">cdf_fn</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span></div>



<div class="viewcode-block" id="_fit_linear_bias_memberwise">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._fit_linear_bias_memberwise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_fit_linear_bias_memberwise</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Memberwise OLS: y = a_k + b_k x_{k}</span>
<span class="sd">    x: (M,N), y: (N,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">_N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">Xk</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">Xk</span><span class="p">),</span> <span class="n">Xk</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">beta</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="_fit_linear_bias_exchangeable">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._fit_linear_bias_exchangeable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_fit_linear_bias_exchangeable</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exchangeable pooled OLS: treat members as replicates.</span>
<span class="sd">    x: (M,N), y: (N,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">beta</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="_apply_bias">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._apply_bias">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_apply_bias</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span></div>



<div class="viewcode-block" id="_resolve_terciles_for_prediction">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._resolve_terciles_for_prediction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_terciles_for_prediction</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
    <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
    <span class="n">stored_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
    <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Priority:</span>
<span class="sd">      1) obs_for_terciles -&gt; compute</span>
<span class="sd">      2) clim_terciles -&gt; use</span>
<span class="sd">      3) stored_terciles -&gt; use</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">terc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">obs_for_terciles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obs_sel</span> <span class="o">=</span> <span class="n">obs_for_terciles</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">terc</span> <span class="o">=</span> <span class="n">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
            <span class="n">obs_sel</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">tercile_q</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">clim_terciles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Accept either (&#39;tercile&#39;,Y,X) or (&#39;quantile&#39;,Y,X)</span>
        <span class="k">if</span> <span class="s2">&quot;tercile&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clim_terciles</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="s2">&quot;quantile&quot;</span> <span class="ow">in</span> <span class="n">clim_terciles</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">clim_terciles</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="s2">&quot;tercile&quot;</span><span class="p">})</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">clim_terciles</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;clim_terciles&quot;</span><span class="p">)</span>
        <span class="n">terc</span> <span class="o">=</span> <span class="n">clim_terciles</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">stored_terciles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">terc</span> <span class="o">=</span> <span class="n">stored_terciles</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">terc</span></div>



<div class="viewcode-block" id="_tercile_probs_from_cdf">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme._tercile_probs_from_cdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_fn</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">pb</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cdf_fn</span><span class="p">(</span><span class="n">low</span><span class="p">))</span>
    <span class="n">pu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cdf_fn</span><span class="p">(</span><span class="n">up</span><span class="p">))</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pu</span> <span class="o">-</span> <span class="n">pb</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pu</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="n">pb</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pb</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="c1"># Renormalize lightly in case of numerical issues</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">+</span> <span class="n">pn</span> <span class="o">+</span> <span class="n">pa</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pb</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">/</span> <span class="n">s</span><span class="p">,</span> <span class="n">pn</span> <span class="o">/</span> <span class="n">s</span><span class="p">,</span> <span class="n">pa</span> <span class="o">/</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">pa</span></div>



<span class="c1"># ============================================================</span>
<span class="c1"># 1) Baseline mixture BMA-like class (SLSQP fit), with terciles</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="WAS_EnsembleBMA">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_EnsembleBMA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_EnsembleBMA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Baseline mixture postprocessor, with optional terciles.</span>

<span class="sd">    model_type:</span>
<span class="sd">      - &#39;normal&#39; : Gaussian mixture around each member forecast (shared sigma per gridpoint)</span>
<span class="sd">      - &#39;gamma&#39;  : Gamma mixture; component mean = member forecast; shape is fitted per gridpoint</span>
<span class="sd">      - &#39;gamma0&#39; : Zero-adjusted gamma (precip): POP via logistic + Gamma mixture for positive part</span>

<span class="sd">    fit() can store gridpoint terciles from obs.</span>

<span class="sd">    predict_probabilistic() returns:</span>
<span class="sd">      - predictive_mean (T,Y,X)</span>
<span class="sd">      - predictive_quantiles (&#39;quantile&#39;,T,Y,X)</span>
<span class="sd">      - tercile_thresholds (&#39;tercile&#39;,Y,X)  [if available]</span>
<span class="sd">      - tercile_probability (&#39;category&#39;,T,Y,X) with [&#39;PB&#39;,&#39;PN&#39;,&#39;PA&#39;] [if available]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_EnsembleBMA.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_EnsembleBMA.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">compute_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma0&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model type &#39;</span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s2">&#39; not supported.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_terciles</span> <span class="o">=</span> <span class="n">compute_terciles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (M,Y,X)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (Y,X) if normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (Y,X) if gamma/gamma0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logistic_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (param,Y,X) if gamma0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (&#39;tercile&#39;,Y,X)</span></div>


<div class="viewcode-block" id="WAS_EnsembleBMA.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_EnsembleBMA.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hcst_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">obs_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;hcst_grid&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;obs_grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_terciles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
                <span class="n">obs_grid</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">tercile_q</span>
            <span class="p">)</span>

        <span class="n">hcst</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">hcst</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">weights_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p1_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>         <span class="c1"># sigma or shape</span>
        <span class="n">p2_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>      <span class="c1"># logistic params for gamma0</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="si">}</span><span class="s2"> baseline mixture...&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Training&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">f_raw</span> <span class="o">=</span> <span class="n">hcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">o_raw</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">o_raw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f_raw</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">f</span> <span class="o">=</span> <span class="n">f_raw</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">o_raw</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">nll</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">ws</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">sigma</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">w_last</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">w_last</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma</span><span class="p">)):</span>
                            <span class="k">return</span> <span class="mf">1e12</span>
                        <span class="n">w_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">w_last</span><span class="p">)</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
                        <span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_all</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)))</span>

                    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[(</span><span class="mf">1e-3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">nll</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">weights_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">p1_map</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;gamma0&quot;</span><span class="p">:</span>
                        <span class="c1"># POP: logistic on cube-root ensemble mean</span>
                        <span class="n">y_bin</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                        <span class="n">ens_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">x_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ens_mean</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

                        <span class="k">def</span><span class="w"> </span><span class="nf">nll_logit</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_pred</span><span class="p">)</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">)</span>
                            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_bin</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_bin</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

                        <span class="n">res_log</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">nll_logit</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BFGS&quot;</span><span class="p">)</span>
                        <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">res_log</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">res_log</span><span class="o">.</span><span class="n">success</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]))</span>
                        <span class="n">p2_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">]</span>

                        <span class="n">mask_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">mask_pos</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">o_g</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">mask_pos</span><span class="p">]</span>
                        <span class="n">f_g</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span> <span class="n">mask_pos</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mask_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">mask_pos</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">o_g</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">mask_pos</span><span class="p">]</span>
                        <span class="n">f_g</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span> <span class="n">mask_pos</span><span class="p">]</span>

                    <span class="n">f_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">f_g</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">nll_gamma</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">ws</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">shape_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">w_last</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">w_last</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shape_val</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">shape_val</span><span class="p">)):</span>
                            <span class="k">return</span> <span class="mf">1e12</span>
                        <span class="n">w_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">w_last</span><span class="p">)</span>
                        <span class="n">scales</span> <span class="o">=</span> <span class="n">f_g</span> <span class="o">/</span> <span class="n">shape_val</span>
                        <span class="n">pdfs</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">o_g</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">a</span><span class="o">=</span><span class="n">shape_val</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">)</span>
                        <span class="n">mix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_all</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">)</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mix</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)))</span>

                    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">)</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">)]</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">nll_gamma</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">weights_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">p1_map</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">coords_m</span> <span class="o">=</span> <span class="p">{</span><span class="n">member_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">member_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">weights_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">p1_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">p1_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]})</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;gamma0&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logistic_params</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">p2_map</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;b0&quot;</span><span class="p">,</span> <span class="s2">&quot;b1&quot;</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">coords_m</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="WAS_EnsembleBMA.predict_probabilistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_EnsembleBMA.predict_probabilistic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_probabilistic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="c1"># terciles:</span>
        <span class="n">return_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fit model first.&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">new_forecasts</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;new_forecasts&quot;</span><span class="p">)</span>

        <span class="n">w_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="n">p1_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">p2_ds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p1_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">p2_ds</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logistic_params</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;gamma0&quot;</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

        <span class="n">terc_ds</span> <span class="o">=</span> <span class="n">_resolve_terciles_for_prediction</span><span class="p">(</span>
            <span class="n">new_forecasts</span><span class="o">=</span><span class="n">new_forecasts</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">obs_for_terciles</span><span class="o">=</span><span class="n">obs_for_terciles</span><span class="p">,</span>
            <span class="n">stored_terciles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">tercile_q</span><span class="o">=</span><span class="n">tercile_q</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">new_forecasts</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">w_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">p2_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="n">out_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">out_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">do_terc</span> <span class="o">=</span> <span class="n">return_terciles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">terc_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terc_np</span> <span class="o">=</span> <span class="n">terc_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Predict&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">par</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">par</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">wk</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">wv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>

                <span class="n">low_th</span> <span class="o">=</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
                    <span class="n">low_th</span><span class="p">,</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">terc_np</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;gamma0&quot;</span><span class="p">:</span>
                    <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">b1</span><span class="p">)):</span>
                        <span class="k">continue</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">x_m</span> <span class="o">=</span> <span class="n">fc</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">x_m</span><span class="p">))</span>
                        <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>

                        <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">x_m</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">par</span><span class="p">)))</span>

                        <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">par</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">par</span>
                        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">),</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                            <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
                        <span class="n">x_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>
                        <span class="n">scales</span> <span class="o">=</span> <span class="n">x_safe</span> <span class="o">/</span> <span class="n">par</span>
                        <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">x_m</span><span class="p">))</span>

                        <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">par</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">)))</span>

                        <span class="n">top</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_safe</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span> <span class="o">+</span> <span class="mf">10.0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">),</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                            <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># gamma0</span>
                        <span class="n">x_mean_cbrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_m</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">))</span>
                        <span class="n">pop</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">expit</span><span class="p">(</span><span class="n">b0</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">x_mean_cbrt</span><span class="p">))</span>  <span class="c1"># P(Y&gt;0)</span>
                        <span class="n">x_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>
                        <span class="n">scales</span> <span class="o">=</span> <span class="n">x_safe</span> <span class="o">/</span> <span class="n">par</span>

                        <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">x_m</span><span class="p">))</span>

                        <span class="k">def</span><span class="w"> </span><span class="nf">cdf_pos</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">par</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">)))</span>

                        <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pop</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pop</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop</span> <span class="o">*</span> <span class="n">cdf_pos</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

                        <span class="n">top</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_safe</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span> <span class="o">+</span> <span class="mf">10.0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">qv</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">qv</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pop</span><span class="p">):</span>
                                    <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">qv</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pop</span><span class="p">))</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
                                    <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_pos</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                            <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">time_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">out_mean</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_quantiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">out_q</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_thresholds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terc_ds</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">out_probs</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>



<span class="c1"># ============================================================</span>
<span class="c1"># 2) Gaussian BMA with bias correction + EM, with terciles</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="WAS_GaussianBMA_EM">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianBMA_EM">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_GaussianBMA_EM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gaussian BMA (Raftery/Wilks-style) with optional terciles.</span>

<span class="sd">    Bias correction (Eq. 8.34):</span>
<span class="sd">        m_{t,k} = a_k + b_k x_{t,k}</span>

<span class="sd">    Predictive CDF:</span>
<span class="sd">        F(q) = sum_k w_k Phi((q - m_{t,k}) / sigma_k)</span>

<span class="sd">    EM estimates weights and sigma_k (optionally constrained equal).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">min_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">bias_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memberwise&quot;</span>     <span class="c1"># &quot;memberwise&quot; | &quot;exchangeable&quot;</span>
    <span class="n">equal_sigma</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">equal_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">compute_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tercile_q_fit</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># fitted grids</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (M,Y,X)</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (M,Y,X) expanded even if equal_sigma</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># (M,Y,X)</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># (M,Y,X)</span>
    <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (&#39;tercile&#39;,Y,X)</span>

    <span class="n">fitted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="WAS_GaussianBMA_EM._fit_point">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianBMA_EM._fit_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">_N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># bias correction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_mode</span> <span class="o">==</span> <span class="s2">&quot;exchangeable&quot;</span><span class="p">:</span>
            <span class="n">a0</span><span class="p">,</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">_fit_linear_bias_exchangeable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_fit_linear_bias_memberwise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">_apply_bias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="c1"># init</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_weights</span><span class="p">:</span>
            <span class="n">w</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span>

        <span class="n">resid</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">m</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">resid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_sigma</span><span class="p">:</span>
            <span class="n">sig</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">ll</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mf">1e-12</span><span class="p">))</span> <span class="o">+</span> <span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="n">ll_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ll</span> <span class="o">-</span> <span class="n">ll_max</span><span class="p">)</span>
            <span class="n">r_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">r_sum</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>

            <span class="n">w_new</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_weights</span><span class="p">:</span>
                <span class="n">w_new</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">w_new</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">w_new</span> <span class="o">/=</span> <span class="n">w_new</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">sig_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">sig_new</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">))</span>
            <span class="n">sig_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">sig_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_sigma</span><span class="p">:</span>
                <span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="mf">1e-12</span><span class="p">))</span>
                <span class="n">common</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma</span><span class="p">))</span>
                <span class="n">sig_new</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">common</span>

            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_new</span> <span class="o">-</span> <span class="n">w</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sig_new</span> <span class="o">-</span> <span class="n">sig</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">w_new</span><span class="p">,</span> <span class="n">sig_new</span>
                <span class="k">break</span>

            <span class="n">w</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">w_new</span><span class="p">,</span> <span class="n">sig_new</span>

        <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>


<div class="viewcode-block" id="WAS_GaussianBMA_EM.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianBMA_EM.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hcst_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">obs_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;hcst_grid&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;obs_grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_terciles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
                <span class="n">obs_grid</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tercile_q_fit</span>
            <span class="p">)</span>

        <span class="n">hcst</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">_T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">hcst</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">w_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">s_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">a_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting Gaussian BMA (EM + bias correction)...&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Training&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">x_raw</span> <span class="o">=</span> <span class="n">hcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">y_raw</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_raw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_raw</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">w</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_point</span><span class="p">(</span><span class="n">x_raw</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">],</span> <span class="n">y_raw</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
                <span class="n">w_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
                <span class="n">s_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
                <span class="n">a_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">b_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>

        <span class="n">coords_m</span> <span class="o">=</span> <span class="p">{</span><span class="n">member_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">member_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">w_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">s_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">a_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">b_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="WAS_GaussianBMA_EM.predict_probabilistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianBMA_EM.predict_probabilistic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_probabilistic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="c1"># terciles:</span>
        <span class="n">return_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fit model first.&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">new_forecasts</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;new_forecasts&quot;</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

        <span class="n">terc_ds</span> <span class="o">=</span> <span class="n">_resolve_terciles_for_prediction</span><span class="p">(</span>
            <span class="n">new_forecasts</span><span class="o">=</span><span class="n">new_forecasts</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">obs_for_terciles</span><span class="o">=</span><span class="n">obs_for_terciles</span><span class="p">,</span>
            <span class="n">stored_terciles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">tercile_q</span><span class="o">=</span><span class="n">tercile_q</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">new_forecasts</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">av</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="n">out_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">out_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">do_terc</span> <span class="o">=</span> <span class="n">return_terciles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">terc_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terc_np</span> <span class="o">=</span> <span class="n">terc_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Predict&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">wk</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">wv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">sigk</span> <span class="o">=</span> <span class="n">sv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigk</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">continue</span>

                <span class="n">low_th</span> <span class="o">=</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
                    <span class="n">low_th</span><span class="p">,</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">terc_np</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">x_m</span> <span class="o">=</span> <span class="n">fc</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="n">mtk</span> <span class="o">=</span> <span class="n">av</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="n">bv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_m</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mtk</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="n">mtk</span><span class="p">))</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mtk</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigk</span><span class="p">)))</span>

                    <span class="n">lo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mtk</span> <span class="o">-</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">sigk</span><span class="p">))</span>
                    <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mtk</span> <span class="o">+</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">sigk</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">),</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                        <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">time_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">out_mean</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_quantiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">out_q</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_thresholds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terc_ds</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">out_probs</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>



<span class="c1"># ============================================================</span>
<span class="c1"># 3) Wang &amp; Bishop (2005) Gaussian dressing, with terciles</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="WAS_GaussianDressing_WangBishop">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianDressing_WangBishop">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_GaussianDressing_WangBishop</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gaussian dressing (Wang &amp; Bishop 2005), with optional terciles.</span>

<span class="sd">    Uses bias-corrected members m_{t,k} and equal weights 1/M and a common dressing sD.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span>
    <span class="n">clip_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">bias_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exchangeable&quot;</span>  <span class="c1"># typical in MOS</span>

    <span class="n">compute_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tercile_q_fit</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># fitted</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># (M,Y,X)</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># (M,Y,X)</span>
    <span class="n">sD</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (Y,X)</span>
    <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">fitted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="WAS_GaussianDressing_WangBishop.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianDressing_WangBishop.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hcst_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">obs_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;hcst_grid&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;obs_grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_terciles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
                <span class="n">obs_grid</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tercile_q_fit</span>
            <span class="p">)</span>

        <span class="n">hcst</span> <span class="o">=</span> <span class="n">hcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">_T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">hcst</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">a_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">sD_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting Wang &amp; Bishop Gaussian dressing...&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Training&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">x_raw</span> <span class="o">=</span> <span class="n">hcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">y_raw</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_raw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_raw</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">x_raw</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_raw</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_mode</span> <span class="o">==</span> <span class="s2">&quot;exchangeable&quot;</span><span class="p">:</span>
                    <span class="n">a0</span><span class="p">,</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">_fit_linear_bias_exchangeable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_fit_linear_bias_memberwise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">_apply_bias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># (M,N)</span>
                <span class="n">mbar</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">mbar</span> <span class="o">-</span> <span class="n">y</span>

                <span class="n">var_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">var_ens_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">mean_var_ens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">var_ens_t</span><span class="p">)</span>

                <span class="n">sD2</span> <span class="o">=</span> <span class="n">var_err</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">)</span> <span class="o">*</span> <span class="n">mean_var_ens</span>
                <span class="k">if</span> <span class="n">sD2</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_negative</span><span class="p">:</span>
                    <span class="n">sD2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="k">if</span> <span class="n">sD2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="n">b_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
                    <span class="n">sD_map</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sD2</span><span class="p">))</span>

        <span class="n">coords_m</span> <span class="o">=</span> <span class="p">{</span><span class="n">member_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">member_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">a_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">b_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sD</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">sD_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="WAS_GaussianDressing_WangBishop.predict_probabilistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_GaussianDressing_WangBishop.predict_probabilistic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_probabilistic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="c1"># terciles:</span>
        <span class="n">return_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fit model first.&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">new_forecasts</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;new_forecasts&quot;</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">sD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sD</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

        <span class="n">terc_ds</span> <span class="o">=</span> <span class="n">_resolve_terciles_for_prediction</span><span class="p">(</span>
            <span class="n">new_forecasts</span><span class="o">=</span><span class="n">new_forecasts</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">obs_for_terciles</span><span class="o">=</span><span class="n">obs_for_terciles</span><span class="p">,</span>
            <span class="n">stored_terciles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">tercile_q</span><span class="o">=</span><span class="n">tercile_q</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">new_forecasts</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">av</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">sD</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="n">out_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">out_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">do_terc</span> <span class="o">=</span> <span class="n">return_terciles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">terc_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terc_np</span> <span class="o">=</span> <span class="n">terc_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Predict&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">low_th</span> <span class="o">=</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
                    <span class="n">low_th</span><span class="p">,</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">terc_np</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">x_m</span> <span class="o">=</span> <span class="n">fc</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="n">mtk</span> <span class="o">=</span> <span class="n">av</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="n">bv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_m</span>
                    <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mtk</span><span class="p">))</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mtk</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="p">)))</span>

                    <span class="n">lo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mtk</span> <span class="o">-</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">))</span>
                    <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mtk</span> <span class="o">+</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">),</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                        <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">time_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">out_mean</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_quantiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">out_q</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_thresholds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terc_ds</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">out_probs</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>



<span class="c1"># ============================================================</span>
<span class="c1"># 4) Precipitation BMA (Sloughter et al. 2007 style), with terciles</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="WAS_PrecipBMA_Sloughter2007">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_PrecipBMA_Sloughter2007">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_PrecipBMA_Sloughter2007</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Precipitation BMA with mixed discrete-continuous components.</span>

<span class="sd">    - Logistic regression for P(Y=0) per member:</span>
<span class="sd">        p0_{t,k} = logistic(a0_k + a1_k * x_{t,k}^{1/3} + a2_k * I(x_{t,k}=0))</span>

<span class="sd">    - Gamma distribution on cube-root transformed positive amounts z=y^(1/3):</span>
<span class="sd">        z ~ Gamma(shape_k, scale_k)</span>

<span class="sd">    Predictive CDF for q&gt;=0:</span>
<span class="sd">        F(q) = sum_k w_k [ p0_{t,k} + (1 - p0_{t,k}) * F_gamma(z_q) ]</span>
<span class="sd">      where z_q = q^(1/3)</span>

<span class="sd">    Tercile probabilities computed directly from this predictive CDF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span>

    <span class="n">compute_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tercile_q_fit</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (M,Y,X)</span>
    <span class="n">logit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># (param,M,Y,X) param=[&#39;a0&#39;,&#39;a1&#39;,&#39;a2&#39;]</span>
    <span class="n">g_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (M,Y,X)</span>
    <span class="n">g_scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (M,Y,X)</span>

    <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">fitted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="WAS_PrecipBMA_Sloughter2007.fit">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_PrecipBMA_Sloughter2007.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hcst_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">obs_grid</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">hcst_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;hcst_grid&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">obs_grid</span><span class="p">,</span> <span class="p">[</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;obs_grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_terciles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span> <span class="o">=</span> <span class="n">compute_gridpoint_terciles_from_obs</span><span class="p">(</span>
                <span class="n">obs_grid</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tercile_q_fit</span>
            <span class="p">)</span>

        <span class="n">hcst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hcst_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">obs_grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">hcst</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">w_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">log_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">sh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">sc_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting precipitation BMA (Sloughter 2007-like)...&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Training&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">x_raw</span> <span class="o">=</span> <span class="n">hcst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">y_raw</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_raw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_raw</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">x_raw</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_raw</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="c1"># weights: keep equal by default (can be extended to MLE if desired)</span>
                <span class="n">w_map</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">M</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">xk_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">ind0</span> <span class="o">=</span> <span class="p">(</span><span class="n">xk</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">ybin</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">nll_logit</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">xk_c</span> <span class="o">+</span> <span class="n">beta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ind0</span><span class="p">)</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">)</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ybin</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ybin</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">))</span>

                    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">nll_logit</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BFGS&quot;</span><span class="p">)</span>
                    <span class="n">log_map</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

                    <span class="n">pos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="n">zk</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">zk</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="n">m1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">zk</span><span class="p">))</span>
                        <span class="n">v1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">zk</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">m1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v1</span><span class="p">):</span>
                            <span class="n">sh_map</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>
                            <span class="n">sc_map</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">m1</span>

        <span class="n">coords_m</span> <span class="o">=</span> <span class="p">{</span><span class="n">member_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">member_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">hcst_grid</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">w_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logit</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">log_map</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;a0&quot;</span><span class="p">,</span> <span class="s2">&quot;a1&quot;</span><span class="p">,</span> <span class="s2">&quot;a2&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">coords_m</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_shape</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">sh_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_scale</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">sc_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords_m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="WAS_PrecipBMA_Sloughter2007.predict_probabilistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_PrecipBMA_Sloughter2007.predict_probabilistic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_probabilistic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="c1"># terciles:</span>
        <span class="n">return_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fit model first.&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">new_forecasts</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;new_forecasts&quot;</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">logit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logit</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_shape</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_scale</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

        <span class="n">terc_ds</span> <span class="o">=</span> <span class="n">_resolve_terciles_for_prediction</span><span class="p">(</span>
            <span class="n">new_forecasts</span><span class="o">=</span><span class="n">new_forecasts</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">obs_for_terciles</span><span class="o">=</span><span class="n">obs_for_terciles</span><span class="p">,</span>
            <span class="n">stored_terciles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">tercile_q</span><span class="o">=</span><span class="n">tercile_q</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">new_forecasts</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">wv</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">logit</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">shv</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">scv</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="n">out_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">out_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">do_terc</span> <span class="o">=</span> <span class="n">return_terciles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">terc_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terc_np</span> <span class="o">=</span> <span class="n">terc_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Predict&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">wk</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">wv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">lv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">lv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">shape_k</span> <span class="o">=</span> <span class="n">shv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">scale_k</span> <span class="o">=</span> <span class="n">scv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">scale_k</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                    <span class="k">continue</span>

                <span class="n">low_th</span> <span class="o">=</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
                    <span class="n">low_th</span><span class="p">,</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">terc_np</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">x_m</span> <span class="o">=</span> <span class="n">fc</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="n">x_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span>
                    <span class="n">ind0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_m</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">x_c</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">ind0</span><span class="p">)</span>   <span class="c1"># P(Y=0)</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">)</span>

                    <span class="c1"># pragmatic mean proxy (consistent with many operational pipelines):</span>
                    <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_m</span><span class="p">))</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                        <span class="n">q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
                        <span class="n">zq</span> <span class="o">=</span> <span class="n">q</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
                        <span class="n">cdfz</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">zq</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape_k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale_k</span><span class="p">)</span>
                        <span class="n">cdfz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">cdfz</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span> <span class="o">*</span> <span class="n">cdfz</span><span class="p">)))</span>

                    <span class="c1"># quantiles by inversion on y-scale</span>
                    <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">+</span> <span class="mf">50.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                        <span class="n">qv</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># mass at zero: F(0) = sum w_k p0_k</span>
                            <span class="n">p_at_0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="n">p0</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">qv</span> <span class="o">&lt;=</span> <span class="n">p_at_0</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="n">qv</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                        <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">time_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">out_mean</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_quantiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">out_q</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_thresholds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terc_ds</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">out_probs</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>



<span class="c1"># ============================================================</span>
<span class="c1"># 5) Schmeits &amp; Kok (2010) precip variant, with terciles</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="WAS_PrecipBMA_SchmeitsKok2010">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_PrecipBMA_SchmeitsKok2010">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_PrecipBMA_SchmeitsKok2010</span><span class="p">(</span><span class="n">WAS_PrecipBMA_Sloughter2007</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Variant where P(Y=0) uses a shared logistic based on ensemble-mean cube-root:</span>
<span class="sd">        p0_t = logistic(a0 + a1 * mean_k x_{t,k}^{1/3})</span>
<span class="sd">    applied to all members.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_PrecipBMA_SchmeitsKok2010.predict_probabilistic">
<a class="viewcode-back" href="../../api.html#wass2s.was_mme.WAS_PrecipBMA_SchmeitsKok2010.predict_probabilistic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_probabilistic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_forecasts</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span>
        <span class="n">member_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span>
        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">lat_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
        <span class="n">lon_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="c1"># terciles:</span>
        <span class="n">return_terciles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clim_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs_for_terciles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tercile_q</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fit model first.&quot;</span><span class="p">)</span>
        <span class="n">_require_dims</span><span class="p">(</span><span class="n">new_forecasts</span><span class="p">,</span> <span class="p">[</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">],</span> <span class="s2">&quot;new_forecasts&quot;</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">logit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logit</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_shape</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_scale</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

        <span class="n">terc_ds</span> <span class="o">=</span> <span class="n">_resolve_terciles_for_prediction</span><span class="p">(</span>
            <span class="n">new_forecasts</span><span class="o">=</span><span class="n">new_forecasts</span><span class="p">,</span>
            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_dim</span><span class="p">,</span>
            <span class="n">lon_dim</span><span class="o">=</span><span class="n">lon_dim</span><span class="p">,</span>
            <span class="n">time_dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span>
            <span class="n">clim_terciles</span><span class="o">=</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">obs_for_terciles</span><span class="o">=</span><span class="n">obs_for_terciles</span><span class="p">,</span>
            <span class="n">stored_terciles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clim_terciles</span><span class="p">,</span>
            <span class="n">tercile_q</span><span class="o">=</span><span class="n">tercile_q</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">new_forecasts</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">logit</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">shv</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">scv</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">member_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="n">out_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">out_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">do_terc</span> <span class="o">=</span> <span class="n">return_terciles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">terc_ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terc_np</span> <span class="o">=</span> <span class="n">terc_ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;tercile&quot;</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">do_terc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Predict&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">wk</span> <span class="o">=</span> <span class="n">_normalize_weights</span><span class="p">(</span><span class="n">wv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>

                <span class="c1"># use first member&#39;s (a0,a1) as shared (you may also refit shared parameters explicitly)</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>

                <span class="n">shape_k</span> <span class="o">=</span> <span class="n">shv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">scale_k</span> <span class="o">=</span> <span class="n">scv</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">scale_k</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                    <span class="k">continue</span>

                <span class="n">low_th</span> <span class="o">=</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
                    <span class="n">low_th</span><span class="p">,</span> <span class="n">up_th</span> <span class="o">=</span> <span class="n">terc_np</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="n">x_m</span> <span class="o">=</span> <span class="n">fc</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">continue</span>

                    <span class="n">x_c_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">x_m</span><span class="p">)))</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">expit</span><span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">x_c_mean</span><span class="p">))</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">))</span>

                    <span class="n">out_mean</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="n">x_m</span><span class="p">))</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">cdf_mix</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                        <span class="n">q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
                        <span class="n">zq</span> <span class="o">=</span> <span class="n">q</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
                        <span class="n">cdfz</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">zq</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">shape_k</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale_k</span><span class="p">)</span>
                        <span class="n">cdfz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">cdfz</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wk</span> <span class="o">*</span> <span class="n">cdfz</span><span class="p">))</span>

                    <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">+</span> <span class="mf">50.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">qv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
                        <span class="n">qv</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">qv</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">qv</span> <span class="o">&lt;=</span> <span class="n">p0</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">out_q</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_invert_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="n">qv</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="k">if</span> <span class="n">do_terc</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">low_th</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">up_th</span><span class="p">):</span>
                        <span class="n">out_probs</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tercile_probs_from_cdf</span><span class="p">(</span><span class="n">cdf_mix</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">low_th</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">up_th</span><span class="p">))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">time_dim</span><span class="p">],</span> <span class="n">lat_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">],</span> <span class="n">lon_dim</span><span class="p">:</span> <span class="n">new_forecasts</span><span class="p">[</span><span class="n">lon_dim</span><span class="p">]}</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">out_mean</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;predictive_quantiles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">out_q</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">do_terc</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_thresholds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terc_ds</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;tercile_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">out_probs</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">lat_dim</span><span class="p">,</span> <span class="n">lon_dim</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;PB&quot;</span><span class="p">,</span> <span class="s2">&quot;PN&quot;</span><span class="p">,</span> <span class="s2">&quot;PA&quot;</span><span class="p">]},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>