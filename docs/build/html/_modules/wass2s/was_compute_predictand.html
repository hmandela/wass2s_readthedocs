

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_compute_predictand &mdash; wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel. 0.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1e28cc32"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_compute_predictand</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_compute_predictand</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">dask.distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>


<div class="viewcode-block" id="WAS_compute_onset">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_compute_onset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that encapsulates methods for transforming precipitation data</span>
<span class="sd">    from different formats (CPT, CDT) and computing onset dates based on</span>
<span class="sd">    rainfall criteria.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class-level criteria dictionary</span>
    <span class="n">default_criteria</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel100_0mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;06-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;08-30&quot;</span><span class="p">},</span>       
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel200_100mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;05-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;08-15&quot;</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel400_200mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;05-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel600_400mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">},</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soudan&quot;</span><span class="p">,</span>         <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Golfe_Of_Guinea&quot;</span><span class="p">,</span><span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;02-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;06-15&quot;</span><span class="p">},</span>
    <span class="p">}</span>

<div class="viewcode-block" id="WAS_compute_onset.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the WAS_compute_onset class with user-defined or default criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_criteria : dict, optional</span>
<span class="sd">            A dictionary containing zone-specific criteria. If not provided,</span>
<span class="sd">            the class will use the default criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">user_criteria</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">user_criteria</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">default_criteria</span></div>


<div class="viewcode-block" id="WAS_compute_onset.adjust_duplicates">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.adjust_duplicates">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_duplicates</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any values in the Series repeat, nudge them by a tiny increment</span>
<span class="sd">        so that all are unique (to avoid indexing collisions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">):</span>
                <span class="n">series</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">series</span></div>


 
<div class="viewcode-block" id="WAS_compute_onset.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame with:</span>
<span class="sd">          - Row 0 = LON</span>
<span class="sd">          - Row 1 = LAT</span>
<span class="sd">          - Row 2 = ELEV</span>
<span class="sd">          - Rows 3+ = daily data (or any date) with &#39;ID&#39; column containing dates.</span>

<span class="sd">        Returns an xarray DataArray with coords = (T, Y, X), variable = &#39;Observation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- 1) Extract metadata (first 3 rows) ---</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">])</span>

        <span class="c1"># --- 2) Extract actual data, rename ID -&gt; DATE ---</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long form</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>

        <span class="c1"># Merge metadata back into the melted data</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure DATE is treated as a proper datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create a complete date range from the first day of the first year to the last day of the last year in the data</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># Create a DataFrame with all combinations of dates and stations</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge the complete date-station combinations with the final_df to ensure all dates are present</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing values in the VALUE column with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Remove invalid rainfall values before computing the mean</span>
        <span class="c1"># Calculate the annual rainfall by summing the values for each year and station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Calculate the mean annual rainfall for each station</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="c1"># Merge back into final_df</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the zonename column based on the conditions for each station</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>



<div class="viewcode-block" id="WAS_compute_onset.day_of_year">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.day_of_year">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dem_rech1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a year &#39;i&#39; and a month-day string &#39;dem_rech1&#39; (e.g., &#39;07-23&#39;),</span>
<span class="sd">        return the day of the year (1-based).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">full_date_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">dem_rech1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">current_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">full_date_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="n">origin_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">day_of_year_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_date</span> <span class="o">-</span> <span class="n">origin_date</span><span class="p">)</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">day_of_year_value</span></div>


<div class="viewcode-block" id="WAS_compute_onset.rainf_zone">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.rainf_zone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rainf_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">):</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="s2">&quot;YE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mask_5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
        <span class="n">mask_4</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> 
            <span class="o">&amp;</span>
            <span class="p">((</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">600</span><span class="p">)),</span>  
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
        <span class="n">mask_3</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_0</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">75</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_5</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_4</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_3</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_2</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_0</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="WAS_compute_onset.onset_function">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.onset_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">onset_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">nbsec</span><span class="p">,</span> <span class="n">jour_pluvieux</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the onset date of a season based on cumulative rainfall criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall or similar values.</span>
<span class="sd">        idebut : int</span>
<span class="sd">            Start index to begin searching for the onset.</span>
<span class="sd">        cumul : float</span>
<span class="sd">            Cumulative rainfall threshold to trigger onset.</span>
<span class="sd">        nbsec : int</span>
<span class="sd">            Maximum number of dry days allowed in the sequence.</span>
<span class="sd">        jour_pluvieux : float</span>
<span class="sd">            Minimum rainfall to consider a day as rainy.</span>
<span class="sd">        irch_fin : int</span>
<span class="sd">            Maximum index limit for the onset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or float</span>
<span class="sd">            Index of the onset date or NaN if onset not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">idebut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span>
            <span class="n">nbsec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span>
            <span class="n">irch_fin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span>

            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idate</span> <span class="o">=</span> <span class="n">idebut</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">idate</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ipreced</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">isuiv</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Check for missing data or out-of-bounds</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ipreced</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">idate</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">isuiv</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">])):</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">break</span>

                <span class="c1"># Check for end search of date</span>
                <span class="k">if</span> <span class="n">idate</span> <span class="o">&gt;</span> <span class="n">irch_fin</span><span class="p">:</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="c1"># Calculate cumulative rainfall over 1, 2, and 3 days</span>
                <span class="n">cumul3jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]</span>
                <span class="n">cumul2jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span>
                <span class="n">cumul1jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span>

                <span class="c1"># Check if any cumulative rainfall meets the threshold</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cumul1jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> 
                    <span class="n">cumul2jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> 
                    <span class="n">cumul3jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span><span class="p">):</span>
                    <span class="n">troisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]])</span>
                    <span class="n">itroisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ipreced</span><span class="p">,</span> <span class="n">idate</span><span class="p">,</span> <span class="n">isuiv</span><span class="p">])</span>
                    <span class="n">maxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">troisp</span><span class="p">)</span>
                    <span class="n">imaxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">troisp</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ideb</span> <span class="o">=</span> <span class="n">itroisp</span><span class="p">[</span><span class="n">imaxp</span><span class="p">]</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">ideb</span>
                    <span class="n">trouv</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># Check for sequences of dry days within the next 30 days</span>
                    <span class="n">finp</span> <span class="o">=</span> <span class="n">ideb</span> <span class="o">+</span> <span class="mi">30</span>
                    <span class="n">pluie30jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:</span><span class="n">finp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">finp</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:]</span>
                    <span class="n">isec</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">isec</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">isecf</span> <span class="o">=</span> <span class="n">isec</span> <span class="o">+</span> <span class="n">nbsec</span>
                        <span class="k">if</span> <span class="n">isecf</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pluie30jr</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">donneeverif</span> <span class="o">=</span> <span class="n">pluie30jr</span><span class="p">[</span><span class="n">isec</span><span class="p">:</span><span class="n">isecf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># Count days with rainfall below jour_pluvieux</span>
                        <span class="n">test1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">donneeverif</span> <span class="o">&lt;</span> <span class="n">jour_pluvieux</span><span class="p">)</span>

                        <span class="c1"># If a dry sequence is found, reset trouv to 0</span>
                        <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="c1"># Break if a dry sequence is found or we&#39;ve reached the end of the window</span>
                        <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isec</span> <span class="o">==</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">nbsec</span><span class="p">):</span>
                            <span class="k">break</span>

                <span class="c1"># Break if onset is found</span>
                <span class="k">if</span> <span class="n">trouv</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">deb_saison</span></div>


    
<div class="viewcode-block" id="WAS_compute_onset.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_df</span><span class="p">,):</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="n">unique_stations</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">unique_years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">unique_stations</span><span class="p">:</span>
                <span class="c1"># Filter data for the current station and year</span>
                <span class="n">station_data</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">station</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span><span class="p">)]</span>
                <span class="c1"># Replace missing values with NaN</span>
                <span class="n">station_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="c1"># Extract unique zonenames</span>
                <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="c1"># Extract the onset criteria for the current zonename</span>
                <span class="n">idebut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;start_search&quot;</span><span class="p">])</span>
                <span class="n">irch_fin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end_search&quot;</span><span class="p">])</span>
                <span class="n">cumul</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">]</span>
                <span class="n">nbsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">]</span>
                <span class="n">jour_pluvieux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">]</span>
                <span class="c1"># Compute the onset date</span>
                <span class="n">onset_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">onset_function</span><span class="p">(</span><span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">nbsec</span><span class="p">,</span> <span class="n">jour_pluvieux</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                    <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;onset&quot;</span><span class="p">:</span> <span class="n">onset_date</span>
                <span class="p">})</span>
        <span class="c1"># Convert results to a DataFrame</span>
        <span class="n">onset_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">onset_df</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;onset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>

        <span class="c1"># transform the onset_df to the CPT format</span>
        <span class="c1"># Extract unique stations and their corresponding lat/lon</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">onset_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Pivot df_yyy to match the wide format (years as rows, stations as columns)</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">onset_df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;onset&quot;</span><span class="p">)</span>

        <span class="c1"># Extract latitude and longitude values based on station order in pivoted DataFrame</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Reset index to ensure correct structure</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Rename the &quot;year&quot; column to &quot;STATION&quot; to match the required format</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Concatenate latitude, longitude, and pivoted onset values to form the final structure</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>



<div class="viewcode-block" id="WAS_compute_onset.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">,</span> <span class="n">nb_cores</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute onset dates for each pixel in a given daily rainfall DataArray</span>
<span class="sd">        using different criteria based on isohyet zones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Array with onset dates computed per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Load zone file &amp; slice it</span>
        <span class="c1"># mask_char = xr.open_dataset(&#39;./utilities/Isohyet_zones.nc&#39;)</span>
        <span class="c1"># mask_char = mask_char.sel(X=slice(extent[1], extent[3]),</span>
        <span class="c1">#                           Y=slice(extent[0], extent[2]))</span>
        <span class="c1"># mask_char = mask_char.isel(Y=slice(None, None, -1)).to_array().drop_vars(&#39;variable&#39;).squeeze()</span>

        <span class="c1"># daily_data = daily_data.sel(</span>
        <span class="c1">#     X=mask_char.coords[&#39;X&#39;],</span>
        <span class="c1">#     Y=mask_char.coords[&#39;Y&#39;])</span>

        <span class="c1"># mask_ = xr.where(daily_data.resample(T=&quot;YE&quot;).sum(skipna=True).mean(dim=&#39;T&#39;) &lt; 75, np.nan, 1)</span>
        
        <span class="n">mask_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rainf_zone</span><span class="p">(</span><span class="n">daily_data</span><span class="p">)</span>
        <span class="c1"># Get unique zone IDs</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask_char</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">unique_zone</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">)]</span>

        <span class="c1"># Compute year range and partial T dimension (start_search)</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Choose a date to store results</span>
        <span class="k">if</span> <span class="n">unique_zone</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid zones found in the mask.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use zone in low latitude</span>
            <span class="n">zone_id_to_use</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">))</span>
        
        <span class="n">T_from_here</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">zone_id_to_use</span><span class="p">][</span><span class="s1">&#39;start_search&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">])</span>

        <span class="c1"># Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Initialize placeholders</span>
        <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">mask_char</span>

        <span class="n">store_onset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">unique_zone</span><span class="p">:</span>
                <span class="c1"># Replace zone values with numeric parameters</span>
                <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_start_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;start_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_start_search</span>
                <span class="p">)</span>
                <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_cumulative</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_cumulative</span>
                <span class="p">)</span>
                <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_number_dry_days</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_number_dry_days</span>
                <span class="p">)</span>
                <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_thrd_rain_day</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_thrd_rain_day</span>
                <span class="p">)</span>
                <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_end_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;end_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_end_search</span>
                <span class="p">)</span>

            <span class="c1"># Select data for this particular year</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="c1"># Set up parallel processing</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onset_function</span><span class="p">,</span>  <span class="c1"># &lt;-- Now calling via self</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_start_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_cumulative</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_number_dry_days</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_thrd_rain_day</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_end_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_onset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># Concatenate final result</span>
        <span class="n">store_onset</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_onset</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_onset</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_from_here</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">store_onset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Onset&quot;</span>

        <span class="k">return</span> <span class="n">store_onset</span><span class="c1">#.to_array().drop_vars(&#39;variable&#39;).squeeze(&#39;variable&#39;)</span></div>
</div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_compute_onset_dry_spell</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for computing the longest dry spell length </span>
<span class="sd">    after the onset of a rainy season, based on user-defined criteria.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class-level criteria dictionary</span>
    <span class="n">default_criteria</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel100_0mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;06-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;08-30&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">40</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel200_100mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;05-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;08-15&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">40</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel400_200mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;05-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">40</span><span class="p">},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel600_400mm&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">45</span><span class="p">},</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soudan&quot;</span><span class="p">,</span>         <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">50</span><span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Golfe_Of_Guinea&quot;</span><span class="p">,</span><span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;02-01&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;06-15&quot;</span><span class="p">,</span> <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span><span class="mi">50</span><span class="p">},</span>
    <span class="p">}</span>

    
<div class="viewcode-block" id="WAS_compute_onset_dry_spell.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the WAS_compute_dry_spell class with user-defined or default criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_criteria : dict, optional</span>
<span class="sd">            A dictionary containing zone-specific criteria. If not provided,</span>
<span class="sd">            the class will use the default criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">user_criteria</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">user_criteria</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">WAS_compute_onset_dry_spell</span><span class="o">.</span><span class="n">default_criteria</span></div>



<div class="viewcode-block" id="WAS_compute_onset_dry_spell.adjust_duplicates">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.adjust_duplicates">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_duplicates</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any values in the Series repeat, nudge them by a tiny increment</span>
<span class="sd">        so that all are unique (to avoid indexing collisions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">):</span>
                <span class="n">series</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">series</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame with:</span>
<span class="sd">          - Row 0 = LON</span>
<span class="sd">          - Row 1 = LAT</span>
<span class="sd">          - Row 2 = ELEV</span>
<span class="sd">          - Rows 3+ = daily data (or any date) with &#39;ID&#39; column containing dates.</span>

<span class="sd">        Returns an xarray DataArray with coords = (T, Y, X), variable = &#39;Observation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- 1) Extract metadata (first 3 rows) ---</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">])</span>

        <span class="c1"># --- 2) Extract actual data, rename ID -&gt; DATE ---</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long form</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>

        <span class="c1"># Merge metadata back into the melted data</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure DATE is treated as a proper datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create a complete date range from the first day of the first year to the last day of the last year in the data</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># Create a DataFrame with all combinations of dates and stations</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge the complete date-station combinations with the final_df to ensure all dates are present</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing values in the VALUE column with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Remove invalid rainfall values before computing the mean</span>
        <span class="c1"># Calculate the annual rainfall by summing the values for each year and station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Calculate the mean annual rainfall for each station</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="c1"># Merge back into final_df</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the zonename column based on the conditions for each station</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.rainf_zone">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.rainf_zone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rainf_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">):</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="s2">&quot;YE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mask_5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
        <span class="n">mask_4</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> 
            <span class="o">&amp;</span>
            <span class="p">((</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">600</span><span class="p">)),</span>  
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
        <span class="n">mask_3</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_0</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">75</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="c1"># Fill NaN values with the next available value</span>
        <span class="k">return</span> <span class="n">mask_5</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_4</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_3</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_2</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_0</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.dry_spell_onset_function">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.dry_spell_onset_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dry_spell_onset_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">nbsec</span><span class="p">,</span> <span class="n">jour_pluvieux</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">,</span> <span class="n">nbjour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the onset date of a season based on cumulative rainfall criteria, and</span>
<span class="sd">        determine the longest dry spell sequence within a specified period after the onset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># &lt;-- Always defined</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbjour</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">idebut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span>
            <span class="n">nbsec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span>
            <span class="n">irch_fin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span>
            <span class="n">nbjour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbjour</span><span class="p">)</span>
            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idate</span> <span class="o">=</span> <span class="n">idebut</span>
            <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># &lt;--- Initialize here too</span>
    
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">idate</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ipreced</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">isuiv</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">+</span> <span class="mi">1</span>
    
                <span class="k">if</span> <span class="p">(</span><span class="n">ipreced</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">idate</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isuiv</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">])</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">])</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">])):</span>
                    <span class="k">break</span>
    
                <span class="k">if</span> <span class="n">idate</span> <span class="o">&gt;</span> <span class="n">irch_fin</span><span class="p">:</span>
                    <span class="c1"># deb_saison = random.randint(max(idebut, irch_fin - 5), irch_fin)</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span>
                    <span class="k">break</span>
    
                <span class="n">cumul3jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]</span>
                <span class="n">cumul2jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span>
                <span class="n">cumul1jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span>
    
                <span class="k">if</span> <span class="p">(</span><span class="n">cumul1jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> <span class="n">cumul2jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> <span class="n">cumul3jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span><span class="p">):</span>
                    <span class="n">troisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]])</span>
                    <span class="n">itroisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ipreced</span><span class="p">,</span> <span class="n">idate</span><span class="p">,</span> <span class="n">isuiv</span><span class="p">])</span>
                    <span class="n">maxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">troisp</span><span class="p">)</span>
                    <span class="n">imaxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">troisp</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ideb</span> <span class="o">=</span> <span class="n">itroisp</span><span class="p">[</span><span class="n">imaxp</span><span class="p">]</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">ideb</span>
                    <span class="n">trouv</span> <span class="o">=</span> <span class="mi">1</span>
    
                    <span class="n">finp</span> <span class="o">=</span> <span class="n">ideb</span> <span class="o">+</span> <span class="mi">30</span>
                    <span class="n">pluie30jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:</span><span class="n">finp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">finp</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:]</span>
                    <span class="n">isec</span> <span class="o">=</span> <span class="mi">0</span>
    
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">isec</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">isecf</span> <span class="o">=</span> <span class="n">isec</span> <span class="o">+</span> <span class="n">nbsec</span>
                        <span class="k">if</span> <span class="n">isecf</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pluie30jr</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">donneeverif</span> <span class="o">=</span> <span class="n">pluie30jr</span><span class="p">[</span><span class="n">isec</span><span class="p">:</span><span class="n">isecf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">test1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">donneeverif</span> <span class="o">&lt;</span> <span class="n">jour_pluvieux</span><span class="p">)</span>
    
                        <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">break</span>
    
                        <span class="k">if</span> <span class="n">isec</span> <span class="o">==</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">nbsec</span><span class="p">):</span>
                            <span class="k">break</span>
    
                <span class="k">if</span> <span class="n">trouv</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
    
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">):</span>
                <span class="n">pluie_nbjour</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">):</span><span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">)</span> <span class="o">+</span> <span class="n">nbjour</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
                <span class="n">rainy_days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pluie_nbjour</span> <span class="o">&gt;</span> <span class="n">jour_pluvieux</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">))</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pluie_nbjour</span><span class="p">)])</span>
                <span class="n">seq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d2</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
        <span class="k">return</span> <span class="n">seq_max</span></div>

    
    
<div class="viewcode-block" id="WAS_compute_onset_dry_spell.dry_spell_onset_function_">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.dry_spell_onset_function_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dry_spell_onset_function_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">nbsec</span><span class="p">,</span> <span class="n">jour_pluvieux</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">,</span> <span class="n">nbjour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the onset date of a season based on cumulative rainfall criteria, and</span>
<span class="sd">        determine the longest dry spell sequence within a specified period after the onset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall or similar values.</span>
<span class="sd">        idebut : int</span>
<span class="sd">            Start index to begin searching for the onset.</span>
<span class="sd">        cumul : float</span>
<span class="sd">            Cumulative rainfall threshold to trigger onset.</span>
<span class="sd">        nbsec : int</span>
<span class="sd">            Maximum number of dry days allowed in the sequence.</span>
<span class="sd">        jour_pluvieux : float</span>
<span class="sd">            Minimum rainfall to consider a day as rainy.</span>
<span class="sd">        irch_fin : int</span>
<span class="sd">            Maximum index limit for the onset.</span>
<span class="sd">        nbjour : int</span>
<span class="sd">            Number of days to check for the longest dry spell after onset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Length of the longest dry spell sequence after onset or NaN if onset not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure all input values are valid</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbjour</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">idebut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span>
            <span class="n">nbsec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span>
            <span class="n">irch_fin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span>
            <span class="n">nbjour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbjour</span><span class="p">)</span>
            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idate</span> <span class="o">=</span> <span class="n">idebut</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">idate</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ipreced</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">isuiv</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Check for missing data or out-of-bounds</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ipreced</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">idate</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">isuiv</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">])):</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">break</span>

                <span class="c1"># Check for end search of date</span>
                <span class="k">if</span> <span class="n">idate</span> <span class="o">&gt;</span> <span class="n">irch_fin</span><span class="p">:</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="c1"># Calculate cumulative rainfall over 1, 2, and 3 days</span>
                <span class="n">cumul3jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]</span>
                <span class="n">cumul2jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span>
                <span class="n">cumul1jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span>

                <span class="c1"># Check if any cumulative rainfall meets the threshold</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cumul1jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> 
                    <span class="n">cumul2jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> 
                    <span class="n">cumul3jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span><span class="p">):</span>
                    <span class="n">troisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]])</span>
                    <span class="n">itroisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ipreced</span><span class="p">,</span> <span class="n">idate</span><span class="p">,</span> <span class="n">isuiv</span><span class="p">])</span>
                    <span class="n">maxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">troisp</span><span class="p">)</span>
                    <span class="n">imaxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">troisp</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ideb</span> <span class="o">=</span> <span class="n">itroisp</span><span class="p">[</span><span class="n">imaxp</span><span class="p">]</span>
                    <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">ideb</span>
                    <span class="n">trouv</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># Check for sequences of dry days within the next 30 days</span>
                    <span class="n">finp</span> <span class="o">=</span> <span class="n">ideb</span> <span class="o">+</span> <span class="mi">30</span>
                    <span class="n">pluie30jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:</span><span class="n">finp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">finp</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:]</span>
                    <span class="n">isec</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">isec</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">isecf</span> <span class="o">=</span> <span class="n">isec</span> <span class="o">+</span> <span class="n">nbsec</span>
                        <span class="k">if</span> <span class="n">isecf</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pluie30jr</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">donneeverif</span> <span class="o">=</span> <span class="n">pluie30jr</span><span class="p">[</span><span class="n">isec</span><span class="p">:</span><span class="n">isecf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># Count days with rainfall below jour_pluvieux</span>
                        <span class="n">test1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">donneeverif</span> <span class="o">&lt;</span> <span class="n">jour_pluvieux</span><span class="p">)</span>

                        <span class="c1"># If a dry sequence is found, reset trouv to 0</span>
                        <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="c1"># Break if a dry sequence is found or we&#39;ve reached the end of the window</span>
                        <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isec</span> <span class="o">==</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">nbsec</span><span class="p">):</span>
                            <span class="k">break</span>

                <span class="c1"># Break if onset is found</span>
                <span class="k">if</span> <span class="n">trouv</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># Compute the longest dry spell within `nbjour` days after the onset</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">):</span>
                <span class="n">pluie_nbjour</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">)</span> <span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">)</span> <span class="o">+</span> <span class="n">nbjour</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
                <span class="n">rainy_days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pluie_nbjour</span> <span class="o">&gt;</span> <span class="n">jour_pluvieux</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Build two arrays to measure intervals between rainy days</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">))</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pluie_nbjour</span><span class="p">)])</span>
                <span class="n">seq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d2</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># -1 so that the difference is the gap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">seq_max</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.day_of_year">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.day_of_year">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dem_rech1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a year &#39;i&#39; and a month-day string &#39;dem_rech1&#39; (e.g., &#39;07-23&#39;),</span>
<span class="sd">        return the 1-based day of the year.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">full_date_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">dem_rech1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">current_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">full_date_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="n">origin_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">day_of_year_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_date</span> <span class="o">-</span> <span class="n">origin_date</span><span class="p">)</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">day_of_year_value</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_df</span><span class="p">,):</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="n">unique_stations</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">unique_years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">unique_stations</span><span class="p">:</span>
                <span class="c1"># Filter data for the current station and year</span>
                <span class="n">station_data</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">station</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span><span class="p">)]</span>
                <span class="c1"># Replace missing values with NaN</span>
                <span class="n">station_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="c1"># Extract unique zonenames</span>
                <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="c1"># x, idebut, cumul, nbsec, jour_pluvieux, irch_fin, nbjour</span>
                <span class="c1"># Extract the onset criteria for the current zonename</span>
                <span class="n">idebut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;start_search&quot;</span><span class="p">])</span>
                <span class="n">irch_fin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end_search&quot;</span><span class="p">])</span>
                <span class="n">cumul</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">]</span>
                <span class="n">nbsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">]</span>
                <span class="n">jour_pluvieux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">]</span>
                <span class="n">nbjour</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;nbjour&quot;</span><span class="p">]</span>
                <span class="c1"># Compute the onset date</span>
                <span class="n">onset_dryspell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dry_spell_onset_function</span><span class="p">(</span><span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">nbsec</span><span class="p">,</span> <span class="n">jour_pluvieux</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">,</span> <span class="n">nbjour</span><span class="p">)</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                    <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;onsetdryspell&quot;</span><span class="p">:</span> <span class="n">onset_dryspell</span>
                <span class="p">})</span>
        <span class="c1"># Convert results to a DataFrame</span>
        <span class="n">onset_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">onset_df</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;onsetdryspell&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;onsetdryspell&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>
 
        <span class="c1"># transform the onset_df to the CPT format</span>
        <span class="c1"># Extract unique stations and their corresponding lat/lon</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">onset_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Pivot df_yyy to match the wide format (years as rows, stations as columns)</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">onset_df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;onsetdryspell&quot;</span><span class="p">)</span>

        <span class="c1"># Extract latitude and longitude values based on station order in pivoted DataFrame</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Reset index to ensure correct structure</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Rename the &quot;year&quot; column to &quot;STATION&quot; to match the required format</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Concatenate latitude, longitude, and pivoted onset values to form the final structure</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>


<div class="viewcode-block" id="WAS_compute_onset_dry_spell.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_onset_dry_spell.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">,</span> <span class="n">nb_cores</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the longest dry spell length after the onset for each pixel in a</span>
<span class="sd">        given daily rainfall DataArray, using different criteria based on isohyet zones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Array with the longest dry spell length per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Load zone file &amp; slice it to the area of interest</span>
        <span class="c1"># mask_char = xr.open_dataset(&#39;./utilities/Isohyet_zones.nc&#39;)</span>
        <span class="c1"># mask_char = mask_char.sel(X=slice(extent[1], extent[3]),</span>
        <span class="c1">#                           Y=slice(extent[0], extent[2]))</span>
        
        <span class="c1"># # Flip Y if needed</span>
        <span class="c1"># mask_char = mask_char.isel(Y=slice(None, None, -1)).to_array().drop_vars(&#39;variable&#39;).squeeze()</span>
        
        <span class="c1"># daily_data = daily_data.sel(</span>
        <span class="c1">#     X=mask_char.coords[&#39;X&#39;],</span>
        <span class="c1">#     Y=mask_char.coords[&#39;Y&#39;])</span>

        <span class="n">mask_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rainf_zone</span><span class="p">(</span><span class="n">daily_data</span><span class="p">)</span>

        <span class="c1"># Get unique zone IDs</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask_char</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">unique_zone</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">)]</span>

        <span class="c1"># Compute year range</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Create T dimension for the earliest (or any) zone&#39;s start date as reference</span>
        <span class="n">zone_id_to_use</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">))</span>  <span class="c1"># or some logic of your choosing</span>
        <span class="n">T_from_here</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">zone_id_to_use</span><span class="p">][</span><span class="s1">&#39;start_search&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">])</span>

        <span class="c1"># Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># Initialize placeholders</span>
        <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">mask_char_nbjour</span> <span class="o">=</span> <span class="n">mask_char</span>

        <span class="n">store_dry_spell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">unique_zone</span><span class="p">:</span>
                <span class="c1"># Replace zone values with numeric parameters</span>
                <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_start_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;start_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_start_search</span>
                <span class="p">)</span>
                <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_cumulative</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_cumulative</span>
                <span class="p">)</span>
                <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_number_dry_days</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_number_dry_days</span>
                <span class="p">)</span>
                <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_thrd_rain_day</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_thrd_rain_day</span>
                <span class="p">)</span>
                <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_end_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;end_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_end_search</span>
                <span class="p">)</span>
                <span class="n">mask_char_nbjour</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_nbjour</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;nbjour&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_nbjour</span>
                <span class="p">)</span>
            <span class="c1"># Select data for this particular year</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="c1"># Parallel processing</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dry_spell_onset_function</span><span class="p">,</span>  <span class="c1"># &lt;-- Call our instance method</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_start_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_cumulative</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_number_dry_days</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_thrd_rain_day</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_end_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_nbjour</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_dry_spell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># Concatenate final result</span>
        <span class="n">store_dry_spell</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_dry_spell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_dry_spell</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_from_here</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">store_dry_spell</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Onset_dryspell&quot;</span>

        <span class="k">return</span> <span class="n">store_dry_spell</span><span class="c1">#.to_array().drop_vars(&#39;variable&#39;).squeeze(&#39;variable&#39;)</span></div>
</div>


<div class="viewcode-block" id="WAS_compute_cessation">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_compute_cessation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute cessation dates based on soil moisture balance for different</span>
<span class="sd">    regions and criteria, leveraging parallel computation for efficiency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class-level criteria dictionary</span>
    <span class="n">default_criteria</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel100_0mm&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;09-30&quot;</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel200_100mm&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;10-05&quot;</span><span class="p">,</span> <span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel400_200mm&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;11-10&quot;</span><span class="p">},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel600_400mm&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;09-15&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;11-15&quot;</span><span class="p">},</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soudan&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;10-01&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">4.5</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;11-30&quot;</span><span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Golfe_Of_Guinea&quot;</span><span class="p">,</span> <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span><span class="s2">&quot;01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;start_search&quot;</span><span class="p">:</span> <span class="s2">&quot;10-15&quot;</span><span class="p">,</span> <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="s2">&quot;end_search&quot;</span><span class="p">:</span> <span class="s2">&quot;12-01&quot;</span><span class="p">},</span>
    <span class="p">}</span>

<div class="viewcode-block" id="WAS_compute_cessation.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the WAS_compute_cessation class with user-defined or default criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_criteria : dict, optional</span>
<span class="sd">            A dictionary containing zone-specific criteria. If not provided,</span>
<span class="sd">            the class will use the default criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">user_criteria</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">user_criteria</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">WAS_compute_cessation</span><span class="o">.</span><span class="n">default_criteria</span></div>


<div class="viewcode-block" id="WAS_compute_cessation.adjust_duplicates">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.adjust_duplicates">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_duplicates</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any values in the Series repeat, nudge them by a tiny increment</span>
<span class="sd">        so that all are unique (to avoid indexing collisions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">):</span>
                <span class="n">series</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">series</span></div>

    
<div class="viewcode-block" id="WAS_compute_cessation.day_of_year">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.day_of_year">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dem_rech1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a year &#39;i&#39; and a month-day string &#39;dem_rech1&#39; (e.g., &#39;07-23&#39;),</span>
<span class="sd">        return the 1-based day of the year.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">full_date_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">dem_rech1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">current_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">full_date_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="n">origin_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">day_of_year_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_date</span> <span class="o">-</span> <span class="n">origin_date</span><span class="p">)</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">day_of_year_value</span></div>


<div class="viewcode-block" id="WAS_compute_cessation.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame with:</span>
<span class="sd">          - Row 0 = LON</span>
<span class="sd">          - Row 1 = LAT</span>
<span class="sd">          - Row 2 = ELEV</span>
<span class="sd">          - Rows 3+ = daily data (or any date) with &#39;ID&#39; column containing dates.</span>

<span class="sd">        Returns an xarray DataArray with coords = (T, Y, X), variable = &#39;Observation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- 1) Extract metadata (first 3 rows) ---</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_onset</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">])</span>

        <span class="c1"># --- 2) Extract actual data, rename ID -&gt; DATE ---</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long form</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>

        <span class="c1"># Merge metadata back into the melted data</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure DATE is treated as a proper datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create a complete date range from the first day of the first year to the last day of the last year in the data</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># Create a DataFrame with all combinations of dates and stations</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge the complete date-station combinations with the final_df to ensure all dates are present</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing values in the VALUE column with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Remove invalid rainfall values before computing the mean</span>
        <span class="c1"># Calculate the annual rainfall by summing the values for each year and station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Calculate the mean annual rainfall for each station</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="c1"># Merge back into final_df</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the zonename column based on the conditions for each station</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>           
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>



<div class="viewcode-block" id="WAS_compute_cessation.cessation_function">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.cessation_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cessation_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ijour_dem_cal</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">ETP</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cessation date using soil moisture balance criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ETP</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Cap_ret_maxi</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">idebut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut</span><span class="p">)</span>
        <span class="n">ijour_dem_cal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">)</span>
        <span class="n">irch_fin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin</span><span class="p">)</span>
        <span class="n">ru</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">,</span> <span class="n">idebut</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">ru</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">ETP</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">))</span>

        <span class="n">ifin_saison</span> <span class="o">=</span> <span class="n">idebut</span>
        <span class="k">while</span> <span class="n">ifin_saison</span> <span class="o">&lt;</span> <span class="n">irch_fin</span><span class="p">:</span>
            <span class="n">ifin_saison</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ifin_saison</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">ru</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">ifin_saison</span><span class="p">]</span> <span class="o">-</span> <span class="n">ETP</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ru</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">ifin_saison</span> <span class="k">if</span> <span class="n">ifin_saison</span> <span class="o">&lt;=</span> <span class="n">irch_fin</span> <span class="k">else</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span></div>



<div class="viewcode-block" id="WAS_compute_cessation.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_df</span><span class="p">):</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="n">unique_stations</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">unique_years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">unique_stations</span><span class="p">:</span>
                <span class="c1"># Filter data for the current station and year</span>
                <span class="n">station_data</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">station</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span><span class="p">)]</span>
                <span class="c1"># Replace missing values with NaN</span>
                <span class="n">station_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="c1"># Extract unique zonenames</span>
                <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="c1"># Extract the onset criteria for the current zonename</span>
                <span class="n">ijour_dem_cal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;date_dry_soil&quot;</span><span class="p">])</span>
                <span class="n">idebut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;start_search&quot;</span><span class="p">])</span>
                <span class="n">irch_fin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end_search&quot;</span><span class="p">])</span>
                <span class="n">ETP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;ETP&quot;</span><span class="p">]</span>
                <span class="n">Cap_ret_maxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">]</span>
                
                <span class="c1"># Compute the onset date</span>
                <span class="n">cessation_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cessation_function</span><span class="p">(</span><span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ijour_dem_cal</span><span class="p">,</span> <span class="n">idebut</span><span class="p">,</span> <span class="n">ETP</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">,</span> <span class="n">irch_fin</span><span class="p">)</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                    <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;cessation&quot;</span><span class="p">:</span> <span class="n">cessation_date</span>
                <span class="p">})</span>
        <span class="c1"># Convert results to a DataFrame</span>
        <span class="n">cessation_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">cessation_df</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;cessation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;cessation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>

        <span class="c1"># transform the onset_df to the CPT format</span>
        <span class="c1"># Extract unique stations and their corresponding lat/lon</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">cessation_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Pivot df_yyy to match the wide format (years as rows, stations as columns)</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">cessation_df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;cessation&quot;</span><span class="p">)</span>

        <span class="c1"># Extract latitude and longitude values based on station order in pivoted DataFrame</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Reset index to ensure correct structure</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Rename the &quot;year&quot; column to &quot;STATION&quot; to match the required format</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Concatenate latitude, longitude, and pivoted onset values to form the final structure</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>


<div class="viewcode-block" id="WAS_compute_cessation.rainf_zone">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.rainf_zone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rainf_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">):</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="s2">&quot;YE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mask_5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
        <span class="n">mask_4</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> 
            <span class="o">&amp;</span>
            <span class="p">((</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">600</span><span class="p">)),</span>  
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
        <span class="n">mask_3</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_0</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">75</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_5</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_4</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_3</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_2</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_0</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="WAS_compute_cessation.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">,</span> <span class="n">nb_cores</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cessation dates for each pixel using criteria based on regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Load zone file &amp; slice it to the area of interest</span>
        <span class="c1"># mask_char = xr.open_dataset(&#39;./utilities/Isohyet_zones.nc&#39;)</span>
        <span class="c1"># mask_char = mask_char.sel(X=slice(extent[1], extent[3]),</span>
        <span class="c1">#                           Y=slice(extent[0], extent[2]))</span>
        <span class="c1"># # Flip Y if needed (as done in your example)</span>
        <span class="c1"># mask_char = mask_char.isel(Y=slice(None, None, -1)).to_array().drop_vars(&#39;variable&#39;).squeeze()</span>

        <span class="c1"># daily_data = daily_data.sel(</span>
        <span class="c1">#     X=mask_char.coords[&#39;X&#39;],</span>
        <span class="c1">#     Y=mask_char.coords[&#39;Y&#39;])</span>
        
        <span class="n">mask_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rainf_zone</span><span class="p">(</span><span class="n">daily_data</span><span class="p">)</span>
        
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask_char</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">unique_zone</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">)]</span>

        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">zone_id_to_use</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">))</span>
        <span class="n">T_from_here</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">zone_id_to_use</span><span class="p">][</span><span class="s1">&#39;start_search&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">mask_char_date_dry_soil</span> <span class="o">=</span> <span class="n">mask_char_ETP</span> <span class="o">=</span> <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">=</span> <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">mask_char</span>

        <span class="n">store_cessation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">unique_zone</span><span class="p">:</span>
                <span class="n">mask_char_date_dry_soil</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_date_dry_soil</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;date_dry_soil&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_date_dry_soil</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mask_char_start_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_start_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;start_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_start_search</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mask_char_ETP</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_char_ETP</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;ETP&quot;</span><span class="p">],</span> <span class="n">mask_char_ETP</span><span class="p">)</span>
                <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_Cap_ret_maxi</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mask_char_end_search</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_end_search</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;end_search&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_end_search</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cessation_function</span><span class="p">,</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_date_dry_soil</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_start_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_ETP</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_Cap_ret_maxi</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_end_search</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_cessation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="n">store_cessation</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_cessation</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_cessation</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_from_here</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">store_cessation</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Cessation&quot;</span>

        <span class="k">return</span> <span class="n">store_cessation</span> <span class="c1">#.to_array().drop_vars(&#39;variable&#39;).squeeze(&#39;variable&#39;)</span></div>
</div>




<div class="viewcode-block" id="WAS_compute_cessation_dry_spell">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_compute_cessation_dry_spell</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for computing the longest dry spell length </span>
<span class="sd">    after the onset of a rainy season, based on user-defined criteria.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class-level criteria dictionary</span>
    <span class="n">default_criteria</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel100_0mm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;05-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;08-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;09-30&quot;</span>
        <span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel200_100mm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;05-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;08-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;10-05&quot;</span>
        <span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel400_200mm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;05-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;09-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;11-10&quot;</span>
        <span class="p">},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sahel600_400mm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">45</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;09-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;11-15&quot;</span>
        <span class="p">},</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soudan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;03-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;07-31&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;10-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">4.5</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;11-30&quot;</span>
        <span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;zone_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Golfe_Of_Guinea&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;02-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cumulative&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;number_dry_days&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s2">&quot;end_search1&quot;</span><span class="p">:</span> <span class="s2">&quot;06-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nbjour&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;date_dry_soil&quot;</span><span class="p">:</span> <span class="s2">&quot;01-01&quot;</span><span class="p">,</span>
            <span class="s2">&quot;start_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;10-15&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ETP&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
            <span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span>
            <span class="s2">&quot;end_search2&quot;</span><span class="p">:</span> <span class="s2">&quot;12-01&quot;</span>
        <span class="p">},</span>
    <span class="p">}</span>

<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the WAS_compute_cessation_dry_spell class with user-defined or default criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_criteria : dict, optional</span>
<span class="sd">            A dictionary containing zone-specific criteria. If not provided,</span>
<span class="sd">            the class will use the default criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">user_criteria</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">user_criteria</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span> <span class="o">=</span> <span class="n">WAS_compute_cessation_dry_spell</span><span class="o">.</span><span class="n">default_criteria</span></div>


<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.adjust_duplicates">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.adjust_duplicates">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_duplicates</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any values in the Series repeat, nudge them by a tiny increment</span>
<span class="sd">        so that all are unique (to avoid indexing collisions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">):</span>
                <span class="n">series</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">series</span></div>


<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame with:</span>
<span class="sd">          - Row 0 = LON</span>
<span class="sd">          - Row 1 = LAT</span>
<span class="sd">          - Row 2 = ELEV</span>
<span class="sd">          - Rows 3+ = daily data (or any date) with &#39;ID&#39; column containing dates.</span>

<span class="sd">        Returns an xarray DataArray with coords = (T, Y, X), variable = &#39;Observation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- 1) Extract metadata (first 3 rows) ---</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_cessation_dry_spell</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_cessation_dry_spell</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_compute_cessation_dry_spell</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">])</span>

        <span class="c1"># --- 2) Extract actual data, rename ID -&gt; DATE ---</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long form</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>

        <span class="c1"># Merge metadata back into the melted data</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure DATE is treated as a proper datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create a complete date range from the first day of the first year to the last day of the last year in the data</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># Create a DataFrame with all combinations of dates and stations</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge the complete date-station combinations with the final_df to ensure all dates are present</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing values in the VALUE column with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Remove invalid rainfall values before computing the mean</span>
        <span class="c1"># Calculate the annual rainfall by summing the values for each year and station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Calculate the mean annual rainfall for each station</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="c1"># Merge back into final_df</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the zonename column based on the conditions for each station</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>    
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.rainf_zone">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.rainf_zone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rainf_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">):</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="s2">&quot;YE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mask_5</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mask_5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
        <span class="n">mask_4</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">annual_rainfall</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> 
            <span class="o">&amp;</span>
            <span class="p">((</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">600</span><span class="p">)),</span>  
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
        <span class="n">mask_3</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="n">mask_0</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">annual_rainfall</span> <span class="o">&gt;=</span> <span class="mi">75</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_5</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_4</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_3</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_2</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mask_0</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.dry_spell_cessation_function">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.dry_spell_cessation_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dry_spell_cessation_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">x</span><span class="p">,</span>
                                     <span class="n">idebut1</span><span class="p">,</span>
                                     <span class="n">cumul</span><span class="p">,</span>
                                     <span class="n">nbsec</span><span class="p">,</span>
                                     <span class="n">jour_pluvieux</span><span class="p">,</span>
                                     <span class="n">irch_fin1</span><span class="p">,</span>
                                     <span class="n">idebut2</span><span class="p">,</span>
                                     <span class="n">ijour_dem_cal</span><span class="p">,</span>
                                     <span class="n">ETP</span><span class="p">,</span>
                                     <span class="n">Cap_ret_maxi</span><span class="p">,</span>
                                     <span class="n">irch_fin2</span><span class="p">,</span>
                                     <span class="n">nbjour</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the longest dry spell length after the onset and</span>
<span class="sd">        determines the cessation date (when soil water returns to 0)</span>
<span class="sd">        based on water balance, then checks for a dry spell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall or similar values.</span>
<span class="sd">        idebut1 : int</span>
<span class="sd">            Start index to begin searching for the onset.</span>
<span class="sd">        cumul : float</span>
<span class="sd">            Cumulative rainfall threshold to trigger onset.</span>
<span class="sd">        nbsec : int</span>
<span class="sd">            Maximum number of dry days allowed in the sequence.</span>
<span class="sd">        jour_pluvieux : float</span>
<span class="sd">            Minimum rainfall to consider a day as rainy.</span>
<span class="sd">        irch_fin1 : int</span>
<span class="sd">            Maximum index limit for the onset search.</span>
<span class="sd">        idebut2 : int</span>
<span class="sd">            Start index for the cessation search.</span>
<span class="sd">        ijour_dem_cal : int</span>
<span class="sd">            Start index from which the water balance is calculated.</span>
<span class="sd">        ETP : float</span>
<span class="sd">            Daily evapotranspiration (mm).</span>
<span class="sd">        Cap_ret_maxi : float</span>
<span class="sd">            Maximum soil water retention capacity (mm).</span>
<span class="sd">        irch_fin2 : int</span>
<span class="sd">            Maximum index limit for the cessation search.</span>
<span class="sd">        nbjour : int</span>
<span class="sd">            Number of days after onset to check for the dry spell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Length of the longest dry spell sequence after onset and before soil water</span>
<span class="sd">            returns to zero, or NaN if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut1</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">idebut2</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ETP</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Cap_ret_maxi</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">irch_fin2</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nbjour</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Convert to int where needed</span>
        <span class="n">idebut1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut1</span><span class="p">)</span>
        <span class="n">nbsec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbsec</span><span class="p">)</span>
        <span class="n">irch_fin1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin1</span><span class="p">)</span>
        <span class="n">idebut2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idebut2</span><span class="p">)</span>
        <span class="n">ijour_dem_cal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">)</span>
        <span class="n">irch_fin2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irch_fin2</span><span class="p">)</span>
        <span class="n">nbjour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbjour</span><span class="p">)</span>

        <span class="n">ru</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">idate</span> <span class="o">=</span> <span class="n">idebut1</span>

        <span class="c1"># --- 1) Find onset date ---</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">idate</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ipreced</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">isuiv</span> <span class="o">=</span> <span class="n">idate</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Check for missing data or out-of-bounds</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">ipreced</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">idate</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">isuiv</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">])</span> <span class="ow">or</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">])</span> <span class="ow">or</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">])</span>
            <span class="p">):</span>
                <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">break</span>

            <span class="c1"># Check if we&#39;ve exceeded the search limit</span>
            <span class="k">if</span> <span class="n">idate</span> <span class="o">&gt;</span> <span class="n">irch_fin1</span><span class="p">:</span>
                <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin1</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin1</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># Calculate cumulative rainfall for 1, 2, 3 days</span>
            <span class="n">cumul3jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]</span>
            <span class="n">cumul2jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">]</span>
            <span class="n">cumul1jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">]</span>

            <span class="c1"># Check if threshold is met</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cumul1jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> <span class="n">cumul2jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span> <span class="ow">or</span> <span class="n">cumul3jr</span> <span class="o">&gt;=</span> <span class="n">cumul</span><span class="p">):</span>
                <span class="n">troisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">ipreced</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idate</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">isuiv</span><span class="p">]])</span>
                <span class="n">itroisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ipreced</span><span class="p">,</span> <span class="n">idate</span><span class="p">,</span> <span class="n">isuiv</span><span class="p">])</span>
                <span class="n">maxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">troisp</span><span class="p">)</span>
                <span class="n">imaxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">troisp</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ideb</span> <span class="o">=</span> <span class="n">itroisp</span><span class="p">[</span><span class="n">imaxp</span><span class="p">]</span>
                <span class="n">deb_saison</span> <span class="o">=</span> <span class="n">ideb</span>
                <span class="n">trouv</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Check for sequences of dry days within the next 30 days</span>
                <span class="n">finp</span> <span class="o">=</span> <span class="n">ideb</span> <span class="o">+</span> <span class="mi">30</span>
                <span class="k">if</span> <span class="n">finp</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">pluie30jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:</span> <span class="n">finp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pluie30jr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ideb</span><span class="p">:]</span>

                <span class="n">isec</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">isec</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">isecf</span> <span class="o">=</span> <span class="n">isec</span> <span class="o">+</span> <span class="n">nbsec</span>
                    <span class="k">if</span> <span class="n">isecf</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pluie30jr</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">donneeverif</span> <span class="o">=</span> <span class="n">pluie30jr</span><span class="p">[</span><span class="n">isec</span> <span class="p">:</span> <span class="n">isecf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># Count days with rainfall below &#39;jour_pluvieux&#39;</span>
                    <span class="n">test1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">donneeverif</span> <span class="o">&lt;</span> <span class="n">jour_pluvieux</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># found a fully dry subsequence</span>
                        <span class="n">trouv</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">test1</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbsec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isec</span> <span class="o">==</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">nbsec</span><span class="p">):</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">trouv</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># If deb_saison not found, no need to calculate further</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">deb_saison</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># --- 2) Soil water balance from ijour_dem_cal up to idebut2 ---</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ijour_dem_cal</span><span class="p">,</span> <span class="n">idebut2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">ru</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">ETP</span>
            <span class="c1"># Confine to [0, Cap_ret_maxi]</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">))</span>

        <span class="c1"># --- 3) Move forward until soil water returns to 0 or we hit irch_fin2 ---</span>
        <span class="n">ifin_saison</span> <span class="o">=</span> <span class="n">idebut2</span>
        <span class="k">while</span> <span class="n">ifin_saison</span> <span class="o">&lt;</span> <span class="n">irch_fin2</span><span class="p">:</span>
            <span class="n">ifin_saison</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ifin_saison</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ifin_saison</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">ru</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">ifin_saison</span><span class="p">]</span> <span class="o">-</span> <span class="n">ETP</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">Cap_ret_maxi</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ru</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">fin_saison</span> <span class="o">=</span> <span class="n">ifin_saison</span> <span class="k">if</span> <span class="n">ifin_saison</span> <span class="o">&lt;=</span> <span class="n">irch_fin2</span> <span class="k">else</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">irch_fin2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">irch_fin2</span><span class="p">)</span>

        <span class="c1"># --- 4) If we found a valid fin_saison beyond (deb_saison + nbjour), </span>
        <span class="c1">#         check the longest dry spell between them.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fin_saison</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="p">(</span><span class="n">fin_saison</span> <span class="o">-</span> <span class="p">(</span><span class="n">deb_saison</span> <span class="o">+</span> <span class="n">nbjour</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> 
            <span class="p">(</span><span class="n">deb_saison</span> <span class="o">+</span> <span class="n">nbjour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">pluie_period</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">deb_saison</span> <span class="o">+</span> <span class="n">nbjour</span> <span class="p">:</span> <span class="n">fin_saison</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pluie_period</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># Find indices of rainy days in that window</span>
            <span class="n">rainy_days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pluie_period</span> <span class="o">&gt;</span> <span class="n">jour_pluvieux</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">))</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rainy_days</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pluie_period</span><span class="p">)])</span>
            <span class="n">seq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d2</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">seq_max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.day_of_year">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.day_of_year">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dem_rech1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert year i and MM-DD string dem_rech1 (e.g., &#39;07-23&#39;) </span>
<span class="sd">        into a 1-based day of the year.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">full_date_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">dem_rech1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">current_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">full_date_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="n">origin_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">current_date</span> <span class="o">-</span> <span class="n">origin_date</span><span class="p">)</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_df</span><span class="p">):</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>
        <span class="n">unique_stations</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">unique_years</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">unique_stations</span><span class="p">:</span>
                <span class="c1"># Filter data for the current station and year</span>
                <span class="n">station_data</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">station</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span><span class="p">)]</span>
                <span class="c1"># Replace missing values with NaN</span>
                <span class="n">station_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="c1"># Extract unique zonenames</span>
                <span class="n">unique_zonenames</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="c1"># Extract the onset criteria for the current zonename</span>
                <span class="n">idebut1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;start_search1&quot;</span><span class="p">])</span>
                <span class="n">irch_fin1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end_search1&quot;</span><span class="p">])</span>
                <span class="n">cumul</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">]</span>
                <span class="n">nbsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">]</span>
                <span class="n">jour_pluvieux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">]</span>

                <span class="n">ijour_dem_cal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;date_dry_soil&quot;</span><span class="p">])</span>
                <span class="n">idebut2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;start_search2&quot;</span><span class="p">])</span>
                <span class="n">irch_fin2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end_search2&quot;</span><span class="p">])</span>
                <span class="n">ETP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;ETP&quot;</span><span class="p">]</span>
                <span class="n">Cap_ret_maxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">]</span>
                <span class="n">nbjour</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">unique_zonenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;nbjour&quot;</span><span class="p">]</span>
                
                <span class="c1"># Compute the cessation dryspell</span>
                <span class="n">cessation_dryspell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dry_spell_cessation_function</span><span class="p">(</span><span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                                   <span class="n">idebut1</span><span class="p">,</span>
                                                                   <span class="n">cumul</span><span class="p">,</span>
                                                                   <span class="n">nbsec</span><span class="p">,</span>
                                                                   <span class="n">jour_pluvieux</span><span class="p">,</span>
                                                                   <span class="n">irch_fin1</span><span class="p">,</span>
                                                                   <span class="n">idebut2</span><span class="p">,</span>
                                                                   <span class="n">ijour_dem_cal</span><span class="p">,</span>
                                                                   <span class="n">ETP</span><span class="p">,</span>
                                                                   <span class="n">Cap_ret_maxi</span><span class="p">,</span>
                                                                   <span class="n">irch_fin2</span><span class="p">,</span>
                                                                   <span class="n">nbjour</span><span class="p">)</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                    <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">station_data</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;cessation_dryspell&quot;</span><span class="p">:</span> <span class="n">cessation_dryspell</span>
                <span class="p">})</span>
        <span class="c1"># Convert results to a DataFrame</span>
        <span class="n">cessation_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">cessation_df</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;cessation_dryspell&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;cessation_dryspell&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>

        <span class="c1"># transform the onset_df to the CPT format</span>
        <span class="c1"># Extract unique stations and their corresponding lat/lon</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">cessation_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Pivot df_yyy to match the wide format (years as rows, stations as columns)</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">cessation_df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;cessation_dryspell&quot;</span><span class="p">)</span>

        <span class="c1"># Extract latitude and longitude values based on station order in pivoted DataFrame</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Reset index to ensure correct structure</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Rename the &quot;year&quot; column to &quot;STATION&quot; to match the required format</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Concatenate latitude, longitude, and pivoted onset values to form the final structure</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>




<div class="viewcode-block" id="WAS_compute_cessation_dry_spell.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_compute_cessation_dry_spell.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_data</span><span class="p">,</span> <span class="n">nb_cores</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the longest dry spell length after the rainy season onset </span>
<span class="sd">        for each pixel in the given daily rainfall DataArray, using different </span>
<span class="sd">        criteria (both for onset and cessation) based on isohyet zones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes (workers) to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Array with the longest dry spell length per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # 1) Load zone file &amp; slice it</span>
        <span class="c1"># mask_char = xr.open_dataset(&quot;./utilities/Isohyet_zones.nc&quot;)</span>
        <span class="c1"># mask_char = mask_char.sel(X=slice(extent[1], extent[3]),</span>
        <span class="c1">#                           Y=slice(extent[0], extent[2]))</span>

        <span class="c1"># # 2) Flip Y if needed</span>
        <span class="c1"># mask_char = mask_char.isel(Y=slice(None, None, -1)).to_array().drop_vars(&quot;variable&quot;).squeeze()</span>

        <span class="c1"># daily_data = daily_data.sel(</span>
        <span class="c1">#     X=mask_char.coords[&#39;X&#39;],</span>
        <span class="c1">#     Y=mask_char.coords[&#39;Y&#39;])</span>
        
        <span class="n">mask_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rainf_zone</span><span class="p">(</span><span class="n">daily_data</span><span class="p">)</span>
        
        <span class="c1"># 3) Get unique zone IDs</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask_char</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">unique_zone</span> <span class="o">=</span> <span class="n">unique_zone</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">)]</span>

        <span class="c1"># 4) Determine years from the dataset</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># 5) For illustration, pick the largest zone to define T dimension</span>
        <span class="n">zone_id_to_use</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_zone</span><span class="p">))</span>
        <span class="n">T_from_here</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">zone_id_to_use</span><span class="p">][</span><span class="s1">&#39;start_search2&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># 6) Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="c1"># 7) Create placeholders for all required masks </span>
        <span class="n">mask_char_start_search1</span> <span class="o">=</span> <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> \
            <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">mask_char_end_search1</span> <span class="o">=</span> <span class="n">mask_char_nbjour</span> <span class="o">=</span> \
            <span class="n">mask_char_start_search2</span> <span class="o">=</span> <span class="n">mask_char_date_dry_soil</span> <span class="o">=</span> <span class="n">mask_char_ETP</span> <span class="o">=</span> \
            <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">=</span> <span class="n">mask_char_end_search2</span> <span class="o">=</span> <span class="n">mask_char</span>

        <span class="n">store_dry_spell</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="c1"># Update masks for each zone &#39;j&#39;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">unique_zone</span><span class="p">:</span>
                <span class="n">mask_char_start_search1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_start_search1</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;start_search1&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_start_search1</span>
                <span class="p">)</span>
                <span class="n">mask_char_cumulative</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_cumulative</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;cumulative&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_cumulative</span>
                <span class="p">)</span>
                <span class="n">mask_char_number_dry_days</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_number_dry_days</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;number_dry_days&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_number_dry_days</span>
                <span class="p">)</span>
                <span class="n">mask_char_thrd_rain_day</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_thrd_rain_day</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;thrd_rain_day&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_thrd_rain_day</span>
                <span class="p">)</span>
                <span class="n">mask_char_end_search1</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_end_search1</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;end_search1&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_end_search1</span>
                <span class="p">)</span>
                <span class="n">mask_char_nbjour</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_nbjour</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;nbjour&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_nbjour</span>
                <span class="p">)</span>
                <span class="n">mask_char_date_dry_soil</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_date_dry_soil</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;date_dry_soil&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_date_dry_soil</span>
                <span class="p">)</span>
                <span class="n">mask_char_start_search2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_start_search2</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;start_search2&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_start_search2</span>
                <span class="p">)</span>
                <span class="n">mask_char_ETP</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_ETP</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;ETP&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_ETP</span>
                <span class="p">)</span>
                <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_Cap_ret_maxi</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;Cap_ret_maxi&quot;</span><span class="p">],</span>
                    <span class="n">mask_char_Cap_ret_maxi</span>
                <span class="p">)</span>
                <span class="n">mask_char_end_search2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">mask_char_end_search2</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criteria</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;end_search2&quot;</span><span class="p">]),</span>
                    <span class="n">mask_char_end_search2</span>
                <span class="p">)</span>

            <span class="c1"># Select the daily data for year i</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="c1"># 8) Parallel processing with Dask</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dry_spell_cessation_function</span><span class="p">,</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_start_search1</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_cumulative</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_number_dry_days</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_thrd_rain_day</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_end_search1</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_start_search2</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_date_dry_soil</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_ETP</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_Cap_ret_maxi</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_end_search2</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">mask_char_nbjour</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_dry_spell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># 9) Concatenate final result across years</span>
        <span class="n">store_dry_spell</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_dry_spell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_dry_spell</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_from_here</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">store_dry_spell</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Cessation_dryspell&quot;</span>

        <span class="k">return</span> <span class="n">store_dry_spell</span> <span class="c1">#.to_array().drop_vars(&#39;variable&#39;).squeeze(&#39;variable&#39;)</span></div>
</div>

    

<div class="viewcode-block" id="WAS_count_dry_spells">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_count_dry_spells</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute the number of dry spells within a specified period</span>
<span class="sd">    (onset to cessation) for each pixel or station in a daily rainfall dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_count_dry_spells.adjust_duplicates">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.adjust_duplicates">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_duplicates</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any values in the Series repeat, nudge them by a tiny increment</span>
<span class="sd">        so that all are unique (to avoid indexing collisions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">):</span>
                <span class="n">series</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">series</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame with:</span>
<span class="sd">          - Row 0 = LON</span>
<span class="sd">          - Row 1 = LAT</span>
<span class="sd">          - Row 2 = ELEV</span>
<span class="sd">          - Rows 3+ = daily data with &#39;ID&#39; column containing dates.</span>

<span class="sd">        Returns a DataFrame with columns like:</span>
<span class="sd">          DATE | STATION | VALUE | LON | LAT | ELEV | MEAN_ANNUAL_RAINFALL | zonename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Extract metadata (first 3 rows)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_count_dry_spells</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_count_dry_spells</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_count_dry_spells</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ELEV&quot;</span><span class="p">])</span>

        <span class="c1"># 2) Extract daily data, rename ID -&gt; DATE</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long form</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>

        <span class="c1"># Merge metadata</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Convert DATE to datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create complete date range</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># All combinations of (date, station)</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge to ensure every (date, station) is present</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing rainfall values with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Compute mean annual rainfall per station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Generate a zonename column (optional example logic)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells.transform_cpt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.transform_cpt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cpt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame in CPT format with:</span>
<span class="sd">         - Row 0 = LAT</span>
<span class="sd">         - Row 1 = LON</span>
<span class="sd">         - Rows 2+ = numeric year data in wide format (stations in columns).</span>

<span class="sd">        Returns a DataFrame with columns like:</span>
<span class="sd">          YEAR | STATION | VALUE | LAT | LON</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Extract metadata (first 2 rows: LAT, LON)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>  <span class="c1"># index = [&quot;LAT&quot;, &quot;LON&quot;]</span>
            <span class="o">.</span><span class="n">T</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>         <span class="c1"># columns: [&quot;index&quot;, &quot;LAT&quot;, &quot;LON&quot;]</span>
        <span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">]</span>
        
        <span class="c1"># Adjust duplicates in LAT / LON</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_count_dry_spells</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">])</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WAS_count_dry_spells</span><span class="o">.</span><span class="n">adjust_duplicates</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">])</span>
        
        <span class="c1"># 2) Extract the data part from row 2 onward</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;STATION&quot;</span><span class="p">:</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">})</span>
        <span class="n">data_part</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_part</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1"># 3) Wide to long</span>
        <span class="n">long_data</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 4) Merge with metadata</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">long_data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>          

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells._parse_cpt_to_long">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells._parse_cpt_to_long">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_cpt_to_long</span><span class="p">(</span><span class="n">df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset_or_cessation&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a DataFrame in CPT-like format to a long DataFrame with columns:</span>
<span class="sd">            [year, station, value_name, lat, lon]</span>

<span class="sd">        Assumes:</span>
<span class="sd">         - Row 0 = [&quot;LAT&quot;, lat_stn1, lat_stn2, ...]</span>
<span class="sd">         - Row 1 = [&quot;LON&quot;, lon_stn1, lon_stn2, ...]</span>
<span class="sd">         - Rows 2+ = [year, station1_val, station2_val, ...]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_cpt : pd.DataFrame</span>
<span class="sd">            CPT-like DataFrame (as returned by, e.g., compute_insitu).</span>
<span class="sd">        value_name : str</span>
<span class="sd">            Name to give to the column containing the value (e.g. &quot;onset&quot;, &quot;cessation&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Columns: [station, year, &lt;value_name&gt;, lat, lon]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Row 0 for LAT, row 1 for LON</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># all station lat</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># all station lon</span>

        <span class="c1"># Station names from columns</span>
        <span class="n">station_cols</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Rows from index=2 are year + station values</span>
        <span class="n">df_years</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;STATION&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Transform to long</span>
        <span class="n">df_long</span> <span class="o">=</span> <span class="n">df_years</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span>
        <span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>

        <span class="c1"># Map station -&gt; lat/lon</span>
        <span class="n">lat_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_cols</span><span class="p">,</span> <span class="n">lat_row</span><span class="p">))</span>
        <span class="n">lon_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_cols</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">))</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lat_map</span><span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lon_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_long</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells.count_dry_spells">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.count_dry_spells">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_dry_spells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">onset</span><span class="p">,</span> <span class="n">cessation</span><span class="p">,</span> <span class="n">dry_spell_length</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of dry spells of a specific length between onset and cessation dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall values.</span>
<span class="sd">        onset : int</span>
<span class="sd">            Start index for the calculation (onset date).</span>
<span class="sd">        cessation : int</span>
<span class="sd">            End index for the calculation (cessation date).</span>
<span class="sd">        dry_spell_length : int</span>
<span class="sd">            The length of a dry spell to count.</span>
<span class="sd">        dry_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;dry.&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or float</span>
<span class="sd">            The number of dry spells of the specified length (NaN if invalid).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">onset</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cessation</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">onset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">onset</span><span class="p">)</span>
        <span class="n">cessation</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cessation</span><span class="p">)</span>

        <span class="c1"># Prevent out-of-bounds</span>
        <span class="k">if</span> <span class="n">onset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cessation</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">onset</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">cessation</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">cessation</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># truncate</span>

        <span class="n">dry_spells_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_dry_days</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">cessation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">day</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dry_threshold</span><span class="p">:</span>
                <span class="n">current_dry_days</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_dry_days</span> <span class="o">==</span> <span class="n">dry_spell_length</span><span class="p">:</span>
                    <span class="n">dry_spells_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_dry_days</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check if the final run of dry days meets the criterion</span>
        <span class="k">if</span> <span class="n">current_dry_days</span> <span class="o">==</span> <span class="n">dry_spell_length</span><span class="p">:</span>
            <span class="n">dry_spells_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">dry_spells_count</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daily_df</span><span class="p">,</span> <span class="n">onset_df_cpt</span><span class="p">,</span> <span class="n">cessation_df_cpt</span><span class="p">,</span> <span class="n">dry_spell_length</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of dry spells (of length = dry_spell_length) between the</span>
<span class="sd">        onset and cessation dates for in-situ stations (CDT format).</span>

<span class="sd">        Returns a DataFrame in CPT format:</span>
<span class="sd">         - Row 0: [&quot;LAT&quot;, lat_stn1, lat_stn2, ...]</span>
<span class="sd">         - Row 1: [&quot;LON&quot;, lon_stn1, lon_stn2, ...]</span>
<span class="sd">         - Subsequent rows: [year, station1_value, station2_value, ...]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_df : pd.DataFrame</span>
<span class="sd">            CDT rainfall data (ID column = date, station columns).</span>
<span class="sd">        onset_df_cpt : pd.DataFrame</span>
<span class="sd">            CPT-format DataFrame containing onset dates (as returned by some method).</span>
<span class="sd">        cessation_df_cpt : pd.DataFrame</span>
<span class="sd">            CPT-format DataFrame containing cessation dates.</span>
<span class="sd">        dry_spell_length : int</span>
<span class="sd">            The length of the dry spell to look for.</span>
<span class="sd">        dry_threshold : float, optional</span>
<span class="sd">            Rainfall threshold below which a day is considered &quot;dry.&quot; Defaults to 1.0 mm.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Final dry-spell counts in CPT pivot format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Transform daily_df from CDT to a standard table</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="c1"># 2) Convert onset and cessation DataFrames from CPT to long format</span>
        <span class="n">onset_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">onset_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset&quot;</span><span class="p">)</span>
        <span class="n">cess_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">cessation_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;cessation&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Merge onset &amp; cessation by [station, year]</span>
        <span class="n">merged_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">onset_long</span><span class="p">,</span> <span class="n">cess_long</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">],</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;_cess&quot;</span><span class="p">))</span>

        <span class="c1"># Consolidate lat/lon columns</span>
        <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat_cess&quot;</span><span class="p">])</span>
        <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon_cess&quot;</span><span class="p">])</span>
        <span class="n">merged_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lat_cess&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_cess&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 4) Loop over (station, year) to compute the count of dry spells</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">yr</span><span class="p">),</span> <span class="n">subdf</span> <span class="ow">in</span> <span class="n">merged_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]):</span>
            <span class="n">onset_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cess_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;cessation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lat_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lon_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Filter daily data for this station and year</span>
            <span class="n">stn_data_year</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span>
                <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">yr</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Replace -99.0 with NaN</span>
            <span class="n">stn_data_year</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stn_data_year</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Convert the daily values to a NumPy array</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">stn_data_year</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Apply count_dry_spells</span>
            <span class="n">nb_dry_spells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_dry_spells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">onset_val</span><span class="p">,</span> <span class="n">cess_val</span><span class="p">,</span> <span class="n">dry_spell_length</span><span class="p">,</span> <span class="n">dry_threshold</span><span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">yr</span><span class="p">,</span>
                <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">stn</span><span class="p">,</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">lat_val</span><span class="p">,</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">lon_val</span><span class="p">,</span>
                <span class="s2">&quot;dry_spells_count&quot;</span><span class="p">:</span> <span class="n">nb_dry_spells</span>
            <span class="p">})</span>

        <span class="n">df_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="c1"># 5) Pivot back to CPT format</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;dry_spells_count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build LAT and LON rows using the first occurrence of each station in df_res</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>

        <span class="c1"># Concatenate lat, lon, and pivot</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>


<div class="viewcode-block" id="WAS_count_dry_spells.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_dry_spells.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">daily_data</span><span class="p">,</span>
        <span class="n">onset_date</span><span class="p">,</span>
        <span class="n">cessation_date</span><span class="p">,</span>
        <span class="n">dry_spell_length</span><span class="p">,</span>
        <span class="n">dry_threshold</span><span class="p">,</span>
        <span class="n">nb_cores</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of dry spells for each pixel within the onset and cessation period</span>
<span class="sd">        in a daily xarray DataArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        onset_date : xarray.DataArray</span>
<span class="sd">            DataArray containing onset dates for each pixel.</span>
<span class="sd">        cessation_date : xarray.DataArray</span>
<span class="sd">            DataArray containing cessation dates for each pixel.</span>
<span class="sd">        dry_spell_length : int</span>
<span class="sd">            The length of a dry spell to count.</span>
<span class="sd">        dry_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;dry.&quot;</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            An array with the count of dry spells per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure alignment</span>
        <span class="n">cessation_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span><span class="p">)</span>
        <span class="n">daily_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">onset_date</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">],</span>
            <span class="n">Y</span><span class="o">=</span><span class="n">onset_date</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Prepare chunk sizes for parallelization</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">store_nb_dryspell</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="c1"># Select data for the current year</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">year_cessation_date</span> <span class="o">=</span> <span class="n">cessation_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">year_onset_date</span> <span class="o">=</span> <span class="n">onset_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
            <span class="c1"># Set up parallel processing</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_dry_spells</span><span class="p">,</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_onset_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_cessation_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;dry_spell_length&quot;</span><span class="p">:</span> <span class="n">dry_spell_length</span><span class="p">,</span>
                    <span class="s2">&quot;dry_threshold&quot;</span><span class="p">:</span> <span class="n">dry_threshold</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_nb_dryspell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># Concatenate final result</span>
        <span class="n">store_nb_dryspell</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_nb_dryspell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_nb_dryspell</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">store_nb_dryspell</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Count_dryspell&quot;</span>

        <span class="k">return</span> <span class="n">store_nb_dryspell</span></div>
</div>



<div class="viewcode-block" id="WAS_count_wet_spells">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_count_wet_spells</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute the number of wet spells within a specified period</span>
<span class="sd">    (onset to cessation) for each pixel or station in a daily rainfall dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_count_wet_spells.count_wet_spells">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells.count_wet_spells">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_wet_spells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">onset_date</span><span class="p">,</span> <span class="n">cessation_date</span><span class="p">,</span> <span class="n">wet_spell_length</span><span class="p">,</span> <span class="n">wet_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of wet spells of a specific length between onset and cessation dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall values.</span>
<span class="sd">        onset_date : int</span>
<span class="sd">            Start index for the calculation (onset date).</span>
<span class="sd">        cessation_date : int</span>
<span class="sd">            End index for the calculation (cessation date).</span>
<span class="sd">        wet_spell_length : int</span>
<span class="sd">            The length of a wet spell to count.</span>
<span class="sd">        wet_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;wet.&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or float</span>
<span class="sd">            The number of wet spells of the specified length (NaN if data is invalid).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">onset_date</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Convert to int and prevent out-of-bounds</span>
        <span class="n">onset_date</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">onset_date</span><span class="p">)</span>
        <span class="n">cessation_date</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">onset_date</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cessation_date</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">onset_date</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">cessation_date</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">cessation_date</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">wet_spells_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_wet_days</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">onset_date</span><span class="p">,</span> <span class="n">cessation_date</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">day</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">wet_threshold</span><span class="p">:</span>
                <span class="n">current_wet_days</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_wet_days</span> <span class="o">==</span> <span class="n">wet_spell_length</span><span class="p">:</span>
                    <span class="n">wet_spells_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_wet_days</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check if the last run of wet days also qualifies</span>
        <span class="k">if</span> <span class="n">current_wet_days</span> <span class="o">==</span> <span class="n">wet_spell_length</span><span class="p">:</span>
            <span class="n">wet_spells_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">wet_spells_count</span></div>


<div class="viewcode-block" id="WAS_count_wet_spells._parse_cpt_to_long">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells._parse_cpt_to_long">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_cpt_to_long</span><span class="p">(</span><span class="n">df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset_or_cessation&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a CPT-format DataFrame into a long DataFrame with columns:</span>
<span class="sd">            [year, station, value_name, lat, lon]</span>

<span class="sd">        Assumes:</span>
<span class="sd">         - Row 0: [&quot;LAT&quot;, lat_stn1, lat_stn2, ...]</span>
<span class="sd">         - Row 1: [&quot;LON&quot;, lon_stn1, lon_stn2, ...]</span>
<span class="sd">         - Rows 2+: [year, station1_val, station2_val, ...]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_cpt : pd.DataFrame</span>
<span class="sd">            DataFrame in CPT-wide format (as returned by certain compute_insitu methods).</span>
<span class="sd">        value_name : str</span>
<span class="sd">            Name for the output column containing the values (e.g. &quot;onset&quot;, &quot;cessation&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Columns: [station, year, &lt;value_name&gt;, lat, lon]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Row 0 = LAT, Row 1 = LON</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># all station lat</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># all station lon</span>

        <span class="c1"># Station names (from columns)</span>
        <span class="n">station_cols</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Rows from index=2 =&gt; year + station values</span>
        <span class="n">df_years</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;STATION&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Melt (wide -&gt; long)</span>
        <span class="n">df_long</span> <span class="o">=</span> <span class="n">df_years</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span>
        <span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>

        <span class="c1"># Map station -&gt; lat/lon</span>
        <span class="n">lat_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_cols</span><span class="p">,</span> <span class="n">lat_row</span><span class="p">))</span>
        <span class="n">lon_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_cols</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">))</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lat_map</span><span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lon_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_long</span></div>


<div class="viewcode-block" id="WAS_count_wet_spells.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a CDT-format DataFrame into a standard table.</span>

<span class="sd">        CDT format assumptions:</span>
<span class="sd">         - Row 0 = LON</span>
<span class="sd">         - Row 1 = LAT</span>
<span class="sd">         - Row 2 = ELEV</span>
<span class="sd">         - Rows 3+ = daily data, &#39;ID&#39; column has dates in YYYYMMDD.</span>

<span class="sd">        Returns a DataFrame with columns:</span>
<span class="sd">          [DATE, STATION, VALUE, LON, LAT, ELEV, MEAN_ANNUAL_RAINFALL, zonename]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Example reuse from previous classes (adjust for your own logic if needed)</span>

        <span class="c1"># 1) Extract metadata (first 3 rows)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>

        <span class="c1"># 2) Extract daily data</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Convert DATE to datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Create a complete date range and expand data accordingly</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># Compute mean annual rainfall by station</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>

        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Assign a &#39;zonename&#39;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_count_wet_spells.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">daily_data</span><span class="p">,</span>
        <span class="n">onset_date</span><span class="p">,</span>
        <span class="n">cessation_date</span><span class="p">,</span>
        <span class="n">wet_spell_length</span><span class="p">,</span>
        <span class="n">wet_threshold</span><span class="p">,</span>
        <span class="n">nb_cores</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of wet spells for each pixel within the onset and cessation period</span>
<span class="sd">        in a daily xarray DataArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        onset_date : xarray.DataArray</span>
<span class="sd">            DataArray containing onset dates for each pixel.</span>
<span class="sd">        cessation_date : xarray.DataArray</span>
<span class="sd">            DataArray containing cessation dates for each pixel.</span>
<span class="sd">        wet_spell_length : int</span>
<span class="sd">            The length of a wet spell to count.</span>
<span class="sd">        wet_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;wet.&quot;</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Array with the count of wet spells per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Align onset and cessation</span>
        <span class="n">cessation_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span><span class="p">)</span>

        <span class="c1"># Determine each year</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Chunk sizes for parallel processing</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">store_nb_wetspell</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="c1"># Data for the current year</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">year_cessation_date</span> <span class="o">=</span> <span class="n">cessation_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">year_onset_date</span> <span class="o">=</span> <span class="n">onset_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
            <span class="c1"># Set up parallel</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_wet_spells</span><span class="p">,</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_onset_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_cessation_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;T&quot;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;wet_spell_length&quot;</span><span class="p">:</span> <span class="n">wet_spell_length</span><span class="p">,</span>
                    <span class="s2">&quot;wet_threshold&quot;</span><span class="p">:</span> <span class="n">wet_threshold</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_nb_wetspell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># Concatenate across all years</span>
        <span class="n">store_nb_wetspell</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_nb_wetspell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_nb_wetspell</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">store_nb_wetspell</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Count_wetspell&quot;</span>

        <span class="k">return</span> <span class="n">store_nb_wetspell</span></div>


<div class="viewcode-block" id="WAS_count_wet_spells.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_wet_spells.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">daily_df</span><span class="p">,</span>
        <span class="n">onset_df_cpt</span><span class="p">,</span>
        <span class="n">cessation_df_cpt</span><span class="p">,</span>
        <span class="n">wet_spell_length</span><span class="p">,</span>
        <span class="n">wet_threshold</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of wet spells (of length = wet_spell_length) between</span>
<span class="sd">        onset and cessation for in-situ stations (CDT data).</span>

<span class="sd">        Returns a DataFrame in CPT format:</span>
<span class="sd">         - Row 0: [&quot;LAT&quot;, lat_station1, lat_station2, ...]</span>
<span class="sd">         - Row 1: [&quot;LON&quot;, lon_station1, lon_station2, ...]</span>
<span class="sd">         - Then one row per year: [year, station1_value, station2_value, ...]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_df : pd.DataFrame</span>
<span class="sd">            CDT rainfall data (ID column = date, station columns).</span>
<span class="sd">        onset_df_cpt : pd.DataFrame</span>
<span class="sd">            CPT-format DataFrame with onset dates (same station columns).</span>
<span class="sd">        cessation_df_cpt : pd.DataFrame</span>
<span class="sd">            CPT-format DataFrame with cessation dates (same station columns).</span>
<span class="sd">        wet_spell_length : int</span>
<span class="sd">            The length of a wet spell to count.</span>
<span class="sd">        wet_threshold : float, optional</span>
<span class="sd">            Rainfall threshold classifying a day as &quot;wet.&quot; Defaults to 1.0 mm.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Final wet-spell counts in CPT pivot format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Transform the daily CDT data into a standard DataFrame</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="c1"># 2) Parse onset and cessation from CPT -&gt; long format</span>
        <span class="n">onset_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">onset_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset&quot;</span><span class="p">)</span>
        <span class="n">cess_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">cessation_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;cessation&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Merge on station/year</span>
        <span class="n">merged_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">onset_long</span><span class="p">,</span> <span class="n">cess_long</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">],</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;_cess&quot;</span><span class="p">))</span>
        
        <span class="c1"># Consolidate lat/lon columns</span>
        <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lat_cess&quot;</span><span class="p">])</span>
        <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="s2">&quot;lon_cess&quot;</span><span class="p">])</span>
        <span class="n">merged_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lat_cess&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_cess&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 4) Loop through station-year pairs and count wet spells</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">yr</span><span class="p">),</span> <span class="n">subdf</span> <span class="ow">in</span> <span class="n">merged_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]):</span>
            <span class="n">onset_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cess_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;cessation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lat_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lon_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Filter daily data for (station, year)</span>
            <span class="n">stn_data_year</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span>
                <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">yr</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Replace -99 with NaN</span>
            <span class="n">stn_data_year</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stn_data_year</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Convert to array</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="n">stn_data_year</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Apply count_wet_spells</span>
            <span class="n">nb_wet_spells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_wet_spells</span><span class="p">(</span>
                <span class="n">x_vals</span><span class="p">,</span> <span class="n">onset_val</span><span class="p">,</span> <span class="n">cess_val</span><span class="p">,</span>
                <span class="n">wet_spell_length</span><span class="p">,</span> <span class="n">wet_threshold</span>
            <span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">yr</span><span class="p">,</span>
                <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">stn</span><span class="p">,</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">lat_val</span><span class="p">,</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">lon_val</span><span class="p">,</span>
                <span class="s2">&quot;wet_spells_count&quot;</span><span class="p">:</span> <span class="n">nb_wet_spells</span>
            <span class="p">})</span>

        <span class="n">df_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="c1"># 5) Pivot back to CPT format</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;wet_spells_count&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build LAT and LON rows</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>

        <span class="c1"># Concatenate LAT, LON, and pivot</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>
</div>




<div class="viewcode-block" id="WAS_count_rainy_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_count_rainy_days</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute the number of rainy days between onset and cessation dates</span>
<span class="sd">    for each pixel or station in a daily rainfall dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_count_rainy_days.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a DataFrame in CDT format into a standardized long DataFrame.</span>

<span class="sd">        CDT format assumptions:</span>
<span class="sd">         - Row 0 = LON</span>
<span class="sd">         - Row 1 = LAT</span>
<span class="sd">         - Row 2 = ELEV</span>
<span class="sd">         - Rows 3+ = daily data with &#39;ID&#39; column holding dates in YYYYMMDD format.</span>

<span class="sd">        This method returns a DataFrame with columns:</span>
<span class="sd">            DATE, STATION, VALUE, LON, LAT, ELEV, (optional) MEAN_ANNUAL_RAINFALL, zonename</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Extract metadata (first 3 rows)</span>
        <span class="c1">#    - &#39;ID&#39; column in these rows has labels [&quot;LON&quot;, &quot;LAT&quot;, &quot;ELEV&quot;]</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>

        <span class="c1"># 2) Extract the daily data portion (from row 3 onward); rename &quot;ID&quot; -&gt; &quot;DATE&quot;</span>
        <span class="n">data_part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>

        <span class="c1"># Melt to long format: columns = [&quot;DATE&quot;, &quot;STATION&quot;, &quot;VALUE&quot;]</span>
        <span class="n">data_long</span> <span class="o">=</span> <span class="n">data_part</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Merge station metadata</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_long</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>

        <span class="c1"># Convert &quot;DATE&quot; from string YYYYMMDD to datetime</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Ensure a complete date range from Jan 1 of earliest year to Dec 31 of latest year</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">date_range</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">)</span>

        <span class="c1"># Create all (date, station) pairs so we don&#39;t miss any station or date</span>
        <span class="n">all_combinations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="n">date_range</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Merge to fill in missing rows</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">final_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Fill missing rainfall values with -99.0</span>
        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">)</span>

        <span class="c1"># 4) Compute mean annual rainfall per station for classification</span>
        <span class="n">annual_rainfall</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">final_df</span><span class="p">[</span><span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">])[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">mean_annual_rainfall</span> <span class="o">=</span> <span class="n">annual_rainfall</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">mean_annual_rainfall</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span>
        <span class="n">final_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">final_df</span><span class="p">,</span> <span class="n">mean_annual_rainfall</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Assign a &#39;zonename&#39; </span>
        <span class="k">def</span><span class="w"> </span><span class="nf">determine_zonename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="mi">600</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="mi">400</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="mi">200</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MEAN_ANNUAL_RAINFALL&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">4</span>

        <span class="n">final_df</span><span class="p">[</span><span class="s2">&quot;zonename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">determine_zonename</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_df</span></div>


<div class="viewcode-block" id="WAS_count_rainy_days.count_rainy_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days.count_rainy_days">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_rainy_days</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">onset_date</span><span class="p">,</span> <span class="n">cessation_date</span><span class="p">,</span> <span class="n">rain_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of rainy days between onset and cessation dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Daily rainfall values.</span>
<span class="sd">        onset_date : int</span>
<span class="sd">            Start index for the calculation (onset date).</span>
<span class="sd">        cessation_date : int</span>
<span class="sd">            End index for the calculation (cessation date).</span>
<span class="sd">        rain_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;rainy.&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or float</span>
<span class="sd">            Number of rainy days (returns NaN if data is invalid).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">onset_date</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Convert onset and cessation indices to integers</span>
        <span class="n">onset_date</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">onset_date</span><span class="p">)</span>
        <span class="n">cessation_date</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">)</span>

        <span class="c1"># Prevent out-of-bounds indices</span>
        <span class="k">if</span> <span class="n">onset_date</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cessation_date</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">onset_date</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">cessation_date</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">cessation_date</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Truncate if needed</span>

        <span class="n">rainy_days_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">onset_date</span><span class="p">,</span> <span class="n">cessation_date</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">day</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">rain_threshold</span><span class="p">:</span>
                <span class="n">rainy_days_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">rainy_days_count</span></div>


<div class="viewcode-block" id="WAS_count_rainy_days.compute">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">daily_data</span><span class="p">,</span>
        <span class="n">onset_date</span><span class="p">,</span>
        <span class="n">cessation_date</span><span class="p">,</span>
        <span class="n">rain_threshold</span><span class="p">,</span>
        <span class="n">nb_cores</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of rainy days for each pixel between onset and cessation dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_data : xarray.DataArray</span>
<span class="sd">            Daily rainfall data, coords = (T, Y, X).</span>
<span class="sd">        onset_date : xarray.DataArray</span>
<span class="sd">            DataArray containing onset dates for each pixel.</span>
<span class="sd">        cessation_date : xarray.DataArray</span>
<span class="sd">            DataArray containing cessation dates for each pixel.</span>
<span class="sd">        rain_threshold : float</span>
<span class="sd">            Rainfall threshold to classify a day as &quot;rainy.&quot;</span>
<span class="sd">        nb_cores : int</span>
<span class="sd">            Number of parallel processes to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            Array with the count of rainy days per pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Align onset and cessation dates</span>
        <span class="n">cessation_date</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">cessation_date</span><span class="p">,</span> <span class="n">onset_date</span><span class="p">)</span>

        <span class="c1"># Compute year range</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">daily_data</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Prepare chunk sizes</span>
        <span class="n">chunksize_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>
        <span class="n">chunksize_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daily_data</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))</span>

        <span class="n">store_nb_rainy_days</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="c1"># Select data for the current year</span>
            <span class="n">year_data</span> <span class="o">=</span> <span class="n">daily_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">year_cessation_date</span> <span class="o">=</span> <span class="n">cessation_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">year_onset_date</span> <span class="o">=</span> <span class="n">onset_date</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
            <span class="c1"># Set up parallel processing</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nb_cores</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_rainy_days</span><span class="p">,</span>
                <span class="n">year_data</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_onset_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">year_cessation_date</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">chunksize_y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">chunksize_x</span><span class="p">}),</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;T&#39;</span><span class="p">,),</span> <span class="p">(),</span> <span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rain_threshold&#39;</span><span class="p">:</span> <span class="n">rain_threshold</span><span class="p">},</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[()],</span>
                <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">store_nb_rainy_days</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>

        <span class="c1"># Concatenate the final result</span>
        <span class="n">store_nb_rainy_days</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">store_nb_rainy_days</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="n">store_nb_rainy_days</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onset_date</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">store_nb_rainy_days</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;nb_rainy_days&quot;</span>

        <span class="k">return</span> <span class="n">store_nb_rainy_days</span></div>


<div class="viewcode-block" id="WAS_count_rainy_days._parse_cpt_to_long">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days._parse_cpt_to_long">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_cpt_to_long</span><span class="p">(</span><span class="n">df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset_or_cessation&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a DataFrame in CPT format (like the one returned by &#39;compute_insitu&#39;)</span>
<span class="sd">        into a long format DataFrame: columns = [year, station, value_name, lat, lon].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_cpt : pd.DataFrame</span>
<span class="sd">            - Row 0: [&quot;LAT&quot;, lat_stn1, lat_stn2, ...]</span>
<span class="sd">            - Row 1: [&quot;LON&quot;, lon_stn1, lon_stn2, ...]</span>
<span class="sd">            - Rows 2+: [year, station1_value, station2_value, ...]</span>

<span class="sd">        value_name : str</span>
<span class="sd">            Name for the column containing the values (e.g., &quot;onset&quot;, &quot;cessation&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_long : pd.DataFrame</span>
<span class="sd">            Columns = [station, year, value_name, lat, lon]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Extract row 0 (LAT) and row 1 (LON)</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># 2) Extract station names (the columns) to map lat/lon</span>
        <span class="n">station_names</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># 3) Extract years + values</span>
        <span class="n">df_years</span> <span class="o">=</span> <span class="n">df_cpt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df_years</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;STATION&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 4) Reshape to long format</span>
        <span class="n">df_long</span> <span class="o">=</span> <span class="n">df_years</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span>
        <span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>

        <span class="c1"># 5) Add LAT/LON information</span>
        <span class="n">lat_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_names</span><span class="p">,</span> <span class="n">lat_row</span><span class="p">))</span>
        <span class="n">lon_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_names</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">))</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lat_map</span><span class="p">)</span>
        <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_long</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lon_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_long</span></div>


<div class="viewcode-block" id="WAS_count_rainy_days.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_count_rainy_days.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">daily_df</span><span class="p">,</span>
        <span class="n">onset_df_cpt</span><span class="p">,</span>
        <span class="n">cessation_df_cpt</span><span class="p">,</span>
        <span class="n">rain_threshold</span><span class="o">=</span><span class="mf">0.85</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute, for in-situ stations (CDT data), the number of rainy days between</span>
<span class="sd">        onset and cessation, for each station and year.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        daily_df : pd.DataFrame</span>
<span class="sd">            CDT precipitation data (ID column = date; columns = stations).</span>
<span class="sd">            Follows the standard CDT format.</span>
<span class="sd">        onset_df_cpt : pd.DataFrame</span>
<span class="sd">            Result of `WAS_compute_onset.compute_insitu(...)` for onset (CPT format).</span>
<span class="sd">        cessation_df_cpt : pd.DataFrame</span>
<span class="sd">            Same format for cessation (CPT format).</span>
<span class="sd">        rain_threshold : float, optional</span>
<span class="sd">            Precipitation threshold for counting a day as &quot;rainy,&quot; by default 0.85 mm.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_final : pd.DataFrame</span>
<span class="sd">            The count of rainy days in CPT pivot format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Transform daily_df (CDT format) into a standard table</span>
        <span class="n">daily_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">daily_df</span><span class="p">)</span>

        <span class="c1"># 2) Convert onset_df_cpt and cessation_df_cpt to long format</span>
        <span class="n">onset_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">onset_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;onset&quot;</span><span class="p">)</span>
        <span class="n">cess_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_cpt_to_long</span><span class="p">(</span><span class="n">cessation_df_cpt</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;cessation&quot;</span><span class="p">)</span>

        <span class="c1"># 3) Merge onset &amp; cessation =&gt; single DataFrame</span>
        <span class="n">merged_onset_cess</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">onset_long</span><span class="p">,</span>
            <span class="n">cess_long</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">],</span>
            <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;_cess&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Consolidate lat/lon columns</span>
        <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lat_cess&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lon_onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">merged_onset_cess</span><span class="p">[</span><span class="s2">&quot;lon_cess&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">merged_onset_cess</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lat_cess&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_onset&quot;</span><span class="p">,</span> <span class="s2">&quot;lon_cess&quot;</span><span class="p">],</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># 4) Loop over (station, year) to compute rainy-day counts</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">yr</span><span class="p">),</span> <span class="n">subdf</span> <span class="ow">in</span> <span class="n">merged_onset_cess</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]):</span>
            <span class="n">onset_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;onset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cess_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;cessation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lat_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lon_val</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Filter daily_df for this station and year</span>
            <span class="n">stn_year_data</span> <span class="o">=</span> <span class="n">daily_df</span><span class="p">[</span>
                <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">daily_df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">yr</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Replace -99 with NaN</span>
            <span class="n">stn_year_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stn_year_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Convert to array</span>
            <span class="n">x_values</span> <span class="o">=</span> <span class="n">stn_year_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Apply count_rainy_days</span>
            <span class="n">nb_rainy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_rainy_days</span><span class="p">(</span>
                <span class="n">x_values</span><span class="p">,</span> <span class="n">onset_val</span><span class="p">,</span> <span class="n">cess_val</span><span class="p">,</span> <span class="n">rain_threshold</span>
            <span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">yr</span><span class="p">,</span>
                <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">stn</span><span class="p">,</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">lat_val</span><span class="p">,</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">lon_val</span><span class="p">,</span>
                <span class="s2">&quot;nb_rainy_days&quot;</span><span class="p">:</span> <span class="n">nb_rainy</span>
            <span class="p">})</span>

        <span class="n">df_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="c1"># 5) Pivot to CPT format</span>
        <span class="n">df_pivot</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;nb_rainy_days&quot;</span><span class="p">)</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df_pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build LAT and LON rows</span>
        <span class="n">station_metadata</span> <span class="o">=</span> <span class="n">df_res</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">station_metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_pivot</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>

        <span class="c1"># Concatenate LAT, LON, and pivot</span>
        <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">df_pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_final</span></div>
</div>


        






<span class="c1">#############################################################################</span>

<span class="c1"># class WAS_tx95_tn95p:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the TX95p (Hot Days) and TN95p (Hot Nights) climate indices.</span>
    
<span class="c1">#     Compliance:</span>
<span class="c1">#     - Uses ETCCDI definition: Percentage of days &gt; 90th/95th/99th percentile.</span>
<span class="c1">#     - Thresholds calculated using a 5-day centered window on the base period.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, base_period: slice, season: list = None):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Initialize the temperature percentile computation class.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         base_period : slice</span>
<span class="c1">#             Base period for computing the percentiles, e.g., slice(&quot;1961&quot;, &quot;1990&quot;).</span>
<span class="c1">#         season : list, optional</span>
<span class="c1">#             List of months to include in the analysis (e.g., [6, 7, 8] for JJA).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.base_period = base_period</span>
<span class="c1">#         self.season = season</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def transform_cdt(df):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Transform a DataFrame in CDT format into a standardized long DataFrame.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # 1) Extract metadata</span>
<span class="c1">#         metadata = df.iloc[:3].set_index(&quot;ID&quot;).T.reset_index()</span>
<span class="c1">#         metadata.columns = [&quot;STATION&quot;, &quot;LON&quot;, &quot;LAT&quot;, &quot;ELEV&quot;]</span>

<span class="c1">#         # 2) Extract daily data</span>
<span class="c1">#         data_part = df.iloc[3:].rename(columns={&quot;ID&quot;: &quot;DATE&quot;})</span>
<span class="c1">#         data_long = data_part.melt(id_vars=[&quot;DATE&quot;], var_name=&quot;STATION&quot;, value_name=&quot;VALUE&quot;)</span>

<span class="c1">#         # Merge and Format</span>
<span class="c1">#         final_df = pd.merge(data_long, metadata, on=&quot;STATION&quot;)</span>
<span class="c1">#         final_df[&quot;DATE&quot;] = pd.to_datetime(final_df[&quot;DATE&quot;], format=&quot;%Y%m%d&quot;)</span>
        
<span class="c1">#         # Coerce to numeric, handle missing values (keep as NaN for calculation logic, or specific flag)</span>
<span class="c1">#         # We assume input might have -99.0 as missing, we replace with NaN for easier rolling stats</span>
<span class="c1">#         final_df[&quot;VALUE&quot;] = pd.to_numeric(final_df[&quot;VALUE&quot;], errors=&#39;coerce&#39;)</span>
<span class="c1">#         final_df[&quot;VALUE&quot;] = final_df[&quot;VALUE&quot;].replace(-99.0, np.nan)</span>

<span class="c1">#         return final_df</span>

<span class="c1">#     def _calc_rolling_thresholds_insitu(self, df_base, percentile):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Calculate daily percentiles using a 5-day centered window across all years</span>
<span class="c1">#         in the base period (Pandas/Station version).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
       
<span class="c1">#         # 1. Pivot to wide format: Index=Date, Columns=Station</span>
<span class="c1">#         wide = df_base.pivot(index=&quot;DATE&quot;, columns=&quot;STATION&quot;, values=&quot;VALUE&quot;)</span>
        
<span class="c1">#         # 2. Compute Day of Year for the wide index</span>
<span class="c1">#         # We fill leap years to 366 days to ensure consistent indexing</span>
<span class="c1">#         doy = wide.index.dayofyear</span>
        
<span class="c1">#         thresholds_list = []</span>
        
<span class="c1">#         unique_stations = wide.columns</span>
             
<span class="c1">#         # Optimization: Group data by DOY first</span>
<span class="c1">#         groups = {d: wide[doy == d].values for d in range(1, 367)}</span>
        
<span class="c1">#         daily_thresholds = {}</span>
        
<span class="c1">#         for d in range(1, 367):</span>
<span class="c1">#             # Identify the 5-day window indices (circular)</span>
<span class="c1">#             window_days = []</span>
<span class="c1">#             for offset in range(-2, 3): # -2, -1, 0, 1, 2</span>
<span class="c1">#                 target = d + offset</span>
<span class="c1">#                 if target &lt; 1: target += 365 # Treat leap year 366 loosely or strict? Standard is usually 366 max.</span>
<span class="c1">#                 if target &gt; 366: target -= 366</span>
<span class="c1">#                 window_days.append(target)</span>
            
<span class="c1">#             # Collect data for these days across all years</span>
<span class="c1">#             # arrays is a list of arrays [Year x Station]</span>
<span class="c1">#             arrays = [groups.get(wd, np.empty((0, len(unique_stations)))) for wd in window_days]</span>
            
<span class="c1">#             # Stack them: (N_years * 5) x N_stations</span>
<span class="c1">#             window_data = np.vstack(arrays)</span>
            
<span class="c1">#             # Calculate percentile along axis 0 (time/samples), ignoring NaNs</span>
<span class="c1">#             # Result: vector of thresholds for each station for day `d`</span>
<span class="c1">#             # Suppress &quot;All-NaN slice&quot; warnings</span>
<span class="c1">#             with np.errstate(invalid=&#39;ignore&#39;):</span>
<span class="c1">#                 th = np.nanpercentile(window_data, percentile, axis=0)</span>
            
<span class="c1">#             daily_thresholds[d] = th</span>

<span class="c1">#         # Convert back to DataFrame: Rows=DOY, Cols=Stations</span>
<span class="c1">#         thresh_df = pd.DataFrame(daily_thresholds, index=unique_stations).T</span>
<span class="c1">#         thresh_df.index.name = &quot;DOY&quot;</span>
        
<span class="c1">#         # Melt to long format for merging</span>
<span class="c1">#         thresh_long = thresh_df.reset_index().melt(</span>
<span class="c1">#             id_vars=&quot;DOY&quot;, </span>
<span class="c1">#             var_name=&quot;STATION&quot;, </span>
<span class="c1">#             value_name=&quot;THRESHOLD&quot;</span>
<span class="c1">#         )</span>
        
<span class="c1">#         return thresh_long</span>

<span class="c1">#     def _compute_percentile_index_insitu(self, df_full, percentile=95) -&gt; pd.DataFrame:</span>
<span class="c1">#         # 1) Filter by season (if applicable) for the final count, </span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             df_full = df_full[df_full[&quot;DATE&quot;].dt.month.isin(self.season)]</span>

<span class="c1">#         # 2) Extract Base Period</span>
<span class="c1">#         start_str, end_str = self.base_period.start, self.base_period.stop</span>
<span class="c1">#         # Handle year strings</span>
<span class="c1">#         if len(str(start_str)) == 4:</span>
<span class="c1">#             s_date = pd.to_datetime(f&quot;{start_str}-01-01&quot;)</span>
<span class="c1">#             e_date = pd.to_datetime(f&quot;{end_str}-12-31&quot;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             s_date = pd.to_datetime(start_str)</span>
<span class="c1">#             e_date = pd.to_datetime(end_str)</span>

<span class="c1">#         df_base = df_full[(df_full[&quot;DATE&quot;] &gt;= s_date) &amp; (df_full[&quot;DATE&quot;] &lt;= e_date)]</span>

<span class="c1">#         # 3) Calculate 5-day window thresholds</span>
<span class="c1">#         thresholds = self._calc_rolling_thresholds_insitu(df_base, percentile)</span>

<span class="c1">#         # 4) Merge thresholds into full data</span>
<span class="c1">#         df_full[&quot;DOY&quot;] = df_full[&quot;DATE&quot;].dt.dayofyear</span>
<span class="c1">#         df_merged = pd.merge(df_full, thresholds, on=[&quot;STATION&quot;, &quot;DOY&quot;], how=&quot;left&quot;)</span>

<span class="c1">#         # 5) Identify Exceedances</span>
<span class="c1">#         # Value &gt; Threshold. (NaNs in VALUE will be False)</span>
<span class="c1">#         df_merged[&quot;IS_EXTREME&quot;] = np.where(df_merged[&quot;VALUE&quot;] &gt; df_merged[&quot;THRESHOLD&quot;], 1, 0)</span>
        
<span class="c1">#         # Track valid observations (not NaN)</span>
<span class="c1">#         df_merged[&quot;IS_VALID&quot;] = np.where(df_merged[&quot;VALUE&quot;].notna(), 1, 0)</span>
        
<span class="c1">#         # 6) Aggregate</span>
<span class="c1">#         df_merged[&quot;year&quot;] = df_merged[&quot;DATE&quot;].dt.year</span>
        
<span class="c1">#         grouped = df_merged.groupby([&quot;STATION&quot;, &quot;year&quot;, &quot;LAT&quot;, &quot;LON&quot;], as_index=False)[</span>
<span class="c1">#             [&quot;IS_EXTREME&quot;, &quot;IS_VALID&quot;]</span>
<span class="c1">#         ].sum()</span>
        
<span class="c1">#         # Calculate Percentage</span>
<span class="c1">#         # If IS_VALID is 0, result is NaN (or -99)</span>
<span class="c1">#         grouped[f&quot;T{percentile}p&quot;] = (grouped[&quot;IS_EXTREME&quot;] / grouped[&quot;IS_VALID&quot;]) * 100</span>
        
<span class="c1">#         # Fill NaNs/Infs resulting from 0/0</span>
<span class="c1">#         grouped[f&quot;T{percentile}p&quot;] = grouped[f&quot;T{percentile}p&quot;].fillna(-99.0)</span>
        
<span class="c1">#         # Rename STATION back to station to match previous outputs if needed (lowercase &#39;station&#39;)</span>
<span class="c1">#         grouped.rename(columns={&quot;STATION&quot;: &quot;station&quot;}, inplace=True)</span>

<span class="c1">#         return grouped[[&quot;station&quot;, &quot;year&quot;, &quot;LAT&quot;, &quot;LON&quot;, f&quot;T{percentile}p&quot;]]</span>

<span class="c1">#     def compute_insitu_tx95p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         return self._wrapper_insitu_compute(df_cdt, percentile=95)</span>

<span class="c1">#     def compute_insitu_tn95p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         return self._wrapper_insitu_compute(df_cdt, percentile=95)</span>
    
<span class="c1">#     def _wrapper_insitu_compute(self, df_cdt, percentile):</span>
<span class="c1">#         df_full = self.transform_cdt(df_cdt)</span>
<span class="c1">#         df_res = self._compute_percentile_index_insitu(df_full, percentile=percentile)</span>
        
<span class="c1">#         col_name = f&quot;T{percentile}p&quot;</span>
<span class="c1">#         df_pivot = df_res.pivot(index=&quot;year&quot;, columns=&quot;station&quot;, values=col_name).reset_index()</span>
<span class="c1">#         df_pivot.rename(columns={&quot;year&quot;: &quot;STATION&quot;}, inplace=True)</span>

<span class="c1">#         # Reattach LAT/LON</span>
<span class="c1">#         station_metadata = (</span>
<span class="c1">#             df_res.groupby(&quot;station&quot;)[[&quot;LAT&quot;, &quot;LON&quot;]]</span>
<span class="c1">#             .first()</span>
<span class="c1">#             .reindex(df_pivot.columns[1:])</span>
<span class="c1">#         )</span>
<span class="c1">#         lat_row = [&quot;LAT&quot;] + station_metadata[&quot;LAT&quot;].tolist()</span>
<span class="c1">#         lon_row = [&quot;LON&quot;] + station_metadata[&quot;LON&quot;].tolist()</span>

<span class="c1">#         lat_df = pd.DataFrame([lat_row], columns=df_pivot.columns)</span>
<span class="c1">#         lon_df = pd.DataFrame([lon_row], columns=df_pivot.columns)</span>

<span class="c1">#         return pd.concat([lat_df, lon_df, df_pivot], ignore_index=True)</span>

<span class="c1">#     # -------------------------------------------------------------------------</span>
<span class="c1">#     # XARRAY METHODS (Raster)</span>
<span class="c1">#     # -------------------------------------------------------------------------</span>

<span class="c1">#     def compute_tx95p(self, da: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         return self._compute_percentile_index_xarray(da, percentile=95)</span>

<span class="c1">#     def compute_tn95p(self, da: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         return self._compute_percentile_index_xarray(da, percentile=95)</span>

<span class="c1">#     def _compute_percentile_index_xarray(self, da: &quot;xr.DataArray&quot;, percentile: float) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute percentile index using Xarray with a 5-day centered window.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # 1. Select Base Period</span>
<span class="c1">#         da_base = da.sel(time=self.base_period)</span>

<span class="c1">#         # 2. Construct 5-day window view</span>
<span class="c1">#         da_windowed = da_base.rolling(time=5, center=True, min_periods=1).construct(&quot;window&quot;)</span>
        
<span class="c1">#         # 3. Group by Day of Year and compute Quantile</span>
<span class="c1">#         da_thresh = (</span>
<span class="c1">#             da_windowed</span>
<span class="c1">#             .groupby(&quot;time.dayofyear&quot;)</span>
<span class="c1">#             .reduce(</span>
<span class="c1">#                 np.nanpercentile, </span>
<span class="c1">#                 dim=[&quot;time&quot;, &quot;window&quot;], </span>
<span class="c1">#                 q=percentile</span>
<span class="c1">#             )</span>
<span class="c1">#         )</span>

<span class="c1">#         # 4. Filter data by season if requested (after computing thresholds to ensure robustness)</span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             da = da.where(da.time.dt.month.isin(self.season), drop=True)</span>
        
<span class="c1">#         # 5. Broadcast Thresholds</span>
<span class="c1">#         doy = da.time.dt.dayofyear</span>
<span class="c1">#         threshold_broadcast = da_thresh.sel(dayofyear=doy)</span>

<span class="c1">#         # 6. Compare and Aggregate</span>
<span class="c1">#         # 1 if &gt; threshold, 0 otherwise. </span>
<span class="c1">#         is_extreme = xr.where(da &gt; threshold_broadcast, 1, 0)</span>
        
<span class="c1">#         # Mask NaNs in original data so they don&#39;t count as non-extreme 0s</span>
<span class="c1">#         is_extreme = is_extreme.where(da.notnull())</span>

<span class="c1">#         # Percentage of days</span>
<span class="c1">#         result = is_extreme.resample(time=&quot;Y&quot;).mean(dim=&quot;time&quot;, skipna=True) * 100</span>
        
<span class="c1">#         return result</span>



<div class="viewcode-block" id="ExtremeType">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ExtremeType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExtremeType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type of temperature extreme.&quot;&quot;&quot;</span>
    <span class="n">HOT</span> <span class="o">=</span> <span class="s2">&quot;hot&quot;</span>      <span class="c1"># Days above upper percentile (e.g., TX90p, TN90p)</span>
    <span class="n">COLD</span> <span class="o">=</span> <span class="s2">&quot;cold&quot;</span>    <span class="c1"># Days below lower percentile (e.g., TX10p, TN10p)</span></div>


<div class="viewcode-block" id="WAS_TempPercentileIndices">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_TempPercentileIndices</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct implementation of ETCCDI temperature percentile indices.</span>
<span class="sd">    </span>
<span class="sd">    Standard ETCCDI Indices:</span>
<span class="sd">    - Hot Days: TX90p (daily max temperature &gt; 90th percentile)</span>
<span class="sd">    - Hot Nights: TN90p (daily min temperature &gt; 90th percentile)</span>
<span class="sd">    - Cold Days: TX10p (daily max temperature &lt; 10th percentile)</span>
<span class="sd">    - Cold Nights: TN10p (daily min temperature &lt; 10th percentile)</span>
<span class="sd">    </span>
<span class="sd">    Reference: ETCCDI Climate Change Indices (2009)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="WAS_TempPercentileIndices.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">var_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;TMAX&#39;</span><span class="p">,</span>          <span class="c1"># &#39;TMAX&#39; or &#39;TMIN&#39;</span>
        <span class="n">extreme_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">,</span>         <span class="c1"># &#39;hot&#39; or &#39;cold&#39;</span>
        <span class="n">bootstrap_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">min_base_years</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_period : slice</span>
<span class="sd">            Slice for base period years, e.g., slice(&quot;1961&quot;, &quot;1990&quot;)</span>
<span class="sd">        percentile : float</span>
<span class="sd">            Percentile value:</span>
<span class="sd">            - For hot extremes: 90, 95, 99 (days above percentile)</span>
<span class="sd">            - For cold extremes: 10, 5, 1 (days below percentile)</span>
<span class="sd">        season : list, optional</span>
<span class="sd">            Months to consider (e.g., [6, 7, 8] for JJA)</span>
<span class="sd">        var_type : str</span>
<span class="sd">            Temperature variable type: &#39;TMAX&#39; (TX) or &#39;TMIN&#39; (TN)</span>
<span class="sd">        extreme_type : str</span>
<span class="sd">            Type of extreme: &#39;hot&#39; or &#39;cold&#39;</span>
<span class="sd">        bootstrap_samples : int</span>
<span class="sd">            Number of bootstrap samples for confidence intervals</span>
<span class="sd">        min_base_years : int</span>
<span class="sd">            Minimum years required in base period</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_period</span> <span class="o">=</span> <span class="n">base_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="o">=</span> <span class="n">season</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span> <span class="o">=</span> <span class="n">var_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">=</span> <span class="n">ExtremeType</span><span class="p">(</span><span class="n">extreme_type</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_samples</span> <span class="o">=</span> <span class="n">bootstrap_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span> <span class="o">=</span> <span class="n">min_base_years</span>
        
        <span class="c1"># Validate inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span>
        
        <span class="c1"># Set index name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_index_name</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._validate_inputs">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._validate_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate all input parameters.&quot;&quot;&quot;</span>
        <span class="c1"># Validate percentile based on extreme type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">HOT</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">50</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;For hot extremes, percentile must be &gt;= 50 and &lt; 100, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s2">. Common values: 90, 95, 99.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">COLD</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;For cold extremes, percentile must be &gt; 0 and &lt;= 50, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s2">. Common values: 10, 5, 1.&quot;</span>
                <span class="p">)</span>
        
        <span class="c1"># Validate variable type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;TMAX&#39;</span><span class="p">,</span> <span class="s1">&#39;TMIN&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var_type must be &#39;TMAX&#39; or &#39;TMIN&#39;, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">var_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._generate_index_name">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._generate_index_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_index_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the proper ETCCDI index name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;TMAX&#39;</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;TX&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;TN&quot;</span>
        
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">)</span><span class="si">}</span><span class="s2">p&quot;</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform CDT format to long format DataFrame.&quot;&quot;&quot;</span>
        <span class="c1"># Extract metadata</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Extract data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span>
        <span class="p">)</span>
        
        <span class="c1"># Merge and clean</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        
        <span class="c1"># Convert -99.0 to NaN</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">final</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._validate_base_period">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._validate_base_period">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_base_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">years</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that base period has sufficient data.&quot;&quot;&quot;</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">years</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_years</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Base period has only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_years</span><span class="p">)</span><span class="si">}</span><span class="s2"> years, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;which is less than recommended minimum of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._calculate_percentile_thresholds">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._calculate_percentile_thresholds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_percentile_thresholds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">temp_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">confidence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate percentile thresholds using 5-day centered window.</span>
<span class="sd">        </span>
<span class="sd">        For hot extremes: Calculate upper percentile (e.g., 90th)</span>
<span class="sd">        For cold extremes: Calculate lower percentile (e.g., 10th)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pivot to wide format (stations as columns)</span>
        <span class="n">wide</span> <span class="o">=</span> <span class="n">temp_data</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>
        
        <span class="c1"># Handle leap days: map February 29 to February 28</span>
        <span class="n">doy_series</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">)</span>
        <span class="n">wide_doy</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">wide_doy</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">doy_series</span>
        
        <span class="c1"># For each day of year (1-365), use 5-day centered window</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ci_lower</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ci_upper</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">doy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">366</span><span class="p">):</span>
            <span class="c1"># Create 5-day window (centered on doy, circular for year boundaries)</span>
            <span class="n">window_days</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">window_doy</span> <span class="o">=</span> <span class="p">((</span><span class="n">doy</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">365</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">window_days</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_doy</span><span class="p">)</span>
            
            <span class="c1"># Get all data for this window across all years</span>
            <span class="n">window_mask</span> <span class="o">=</span> <span class="n">wide_doy</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">window_days</span><span class="p">)</span>
            <span class="n">window_data</span> <span class="o">=</span> <span class="n">wide_doy</span><span class="p">[</span><span class="n">window_mask</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate percentile for each station</span>
                <span class="n">threshold_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                    <span class="n">window_data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span> 
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">thresholds</span><span class="p">[</span><span class="n">doy</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold_values</span>
                
                <span class="c1"># Bootstrap confidence intervals if requested</span>
                <span class="k">if</span> <span class="n">confidence</span><span class="p">:</span>
                    <span class="n">n_bootstrap</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">))</span>
                    <span class="n">bootstrap_samples</span> <span class="o">=</span> <span class="p">[]</span>
                    
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">):</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">),</span> 
                            <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">),</span> 
                            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="n">sample</span> <span class="o">=</span> <span class="n">window_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="n">sample_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                            <span class="n">sample</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span> 
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                        <span class="n">bootstrap_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_percentile</span><span class="p">)</span>
                    
                    <span class="n">bootstrap_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">)</span>
                    <span class="n">ci_lower</span><span class="p">[</span><span class="n">doy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">bootstrap_array</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ci_upper</span><span class="p">[</span><span class="n">doy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">bootstrap_array</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Convert to DataFrames</span>
        <span class="n">thresholds_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">wide</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">thresholds_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;DOY&quot;</span>
        <span class="n">thresholds_df</span> <span class="o">=</span> <span class="n">thresholds_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;DOY&quot;</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;THRESHOLD&quot;</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">confidence</span><span class="p">:</span>
            <span class="n">ci_lower_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ci_lower</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">wide</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ci_lower_df</span> <span class="o">=</span> <span class="n">ci_lower_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
                <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;DOY&quot;</span><span class="p">,</span>
                <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
                <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;CI_LOWER&quot;</span>
            <span class="p">)</span>
            
            <span class="n">ci_upper_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ci_upper</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">wide</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ci_upper_df</span> <span class="o">=</span> <span class="n">ci_upper_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
                <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;DOY&quot;</span><span class="p">,</span>
                <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
                <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;CI_UPPER&quot;</span>
            <span class="p">)</span>
            
            <span class="k">return</span> <span class="n">thresholds_df</span><span class="p">,</span> <span class="n">ci_lower_df</span><span class="p">,</span> <span class="n">ci_upper_df</span>
        
        <span class="k">return</span> <span class="n">thresholds_df</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._calculate_extreme_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._calculate_extreme_days">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_extreme_days</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">temp_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">thresholds</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate number of extreme temperature days.</span>
<span class="sd">        </span>
<span class="sd">        For hot extremes: days when temperature &gt; percentile (e.g., TX90p, TN90p)</span>
<span class="sd">        For cold extremes: days when temperature &lt; percentile (e.g., TX10p, TN10p)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge thresholds with data</span>
        <span class="n">temp_data</span><span class="p">[</span><span class="s2">&quot;DOY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_data</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">temp_data</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;DOY&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        
        <span class="c1"># Determine if day is extreme based on extreme type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">HOT</span><span class="p">:</span>
            <span class="c1"># Hot extremes: temperature &gt; percentile threshold</span>
            <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;THRESHOLD&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;EXTREME_TYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;hot&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">COLD</span><span class="p">:</span>
            <span class="c1"># Cold extremes: temperature &lt; percentile threshold</span>
            <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;THRESHOLD&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;EXTREME_TYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cold&quot;</span>
        
        <span class="c1"># Preserve NaN values from original data</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">return</span> <span class="n">merged</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">df_cdt</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">return_confidence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute index for in-situ (station) data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform to long format</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">df_cdt</span><span class="p">)</span>
        
        <span class="c1"># Filter base period</span>
        <span class="n">base_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">base_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">df_base</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">base_start</span><span class="p">,</span> <span class="n">base_stop</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Validate base period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_base_period</span><span class="p">(</span><span class="n">df_base</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># Calculate thresholds</span>
        <span class="k">if</span> <span class="n">return_confidence</span><span class="p">:</span>
            <span class="n">thresholds</span><span class="p">,</span> <span class="n">ci_lower</span><span class="p">,</span> <span class="n">ci_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_percentile_thresholds</span><span class="p">(</span>
                <span class="n">df_base</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_percentile_thresholds</span><span class="p">(</span><span class="n">df_base</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Calculate extreme days</span>
        <span class="n">df_extreme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_extreme_days</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)</span>
        
        <span class="c1"># Apply seasonal filter if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">df_extreme</span> <span class="o">=</span> <span class="n">df_extreme</span><span class="p">[</span><span class="n">df_extreme</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">)]</span>
        
        <span class="c1"># Group by year and station</span>
        <span class="n">df_extreme</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_extreme</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        
        <span class="c1"># Calculate percentage of extreme days</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df_extreme</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;IS_EXTREME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span><span class="p">]</span>
        
        <span class="c1"># Format to CDT</span>
        <span class="n">result_cdt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_to_cdt</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_confidence</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result_cdt</span><span class="p">,</span> <span class="p">(</span><span class="n">ci_lower</span><span class="p">,</span> <span class="n">ci_upper</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result_cdt</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices.compute_xarray">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices.compute_xarray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_xarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">ds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">var_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># chunk_size: Optional[Dict[str, int]] = None,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute index for xarray data (gridded).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract DataArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">ds</span>
        
        <span class="c1"># Standardize dimension names</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_dims</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
        
        <span class="c1"># Apply seasonal mask if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Handle chunking for Dask</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span> <span class="c1"># and hasattr(da.data, &#39;chunks&#39;):</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))}</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">chunk_size</span><span class="p">})</span>
            
        <span class="c1"># Select base period</span>
        <span class="n">da_base</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="p">)</span>
        
        <span class="c1"># Validate base period</span>
        <span class="n">base_years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da_base</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_base_period</span><span class="p">(</span><span class="n">base_years</span><span class="p">)</span>
        
        <span class="c1"># Calculate thresholds using 5-day centered window</span>
        <span class="n">windowed</span> <span class="o">=</span> <span class="n">da_base</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">)</span>
        
        <span class="c1"># Calculate percentile</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">windowed</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;time.dayofyear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;window&quot;</span><span class="p">],</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        
        <span class="c1"># Handle leap days</span>
        <span class="n">doy</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofyear</span>
        <span class="n">doy_fixed</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">doy</span> <span class="o">==</span> <span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="n">doy</span><span class="p">)</span>
        
        <span class="c1"># Map thresholds to all time steps</span>
        <span class="n">full_thresholds</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">dayofyear</span><span class="o">=</span><span class="n">doy_fixed</span><span class="p">)</span>
        <span class="n">full_thresholds</span> <span class="o">=</span> <span class="n">full_thresholds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;dayofyear&quot;</span><span class="p">)</span>
        <span class="n">full_thresholds</span> <span class="o">=</span> <span class="n">full_thresholds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        
        <span class="c1"># Identify extreme days based on extreme type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">HOT</span><span class="p">:</span>
            <span class="c1"># Hot extremes: temperature &gt; percentile</span>
            <span class="n">is_extreme</span> <span class="o">=</span> <span class="p">(</span><span class="n">da</span> <span class="o">&gt;</span> <span class="n">full_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">COLD</span><span class="p">:</span>
            <span class="c1"># Cold extremes: temperature &lt; percentile</span>
            <span class="n">is_extreme</span> <span class="o">=</span> <span class="p">(</span><span class="n">da</span> <span class="o">&lt;</span> <span class="n">full_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="c1"># Preserve NaN values</span>
        <span class="n">is_extreme</span> <span class="o">=</span> <span class="n">is_extreme</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">notnull</span><span class="p">())</span>
        
        <span class="c1"># Calculate annual percentage of extreme days</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">is_extreme</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;YS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        
        <span class="c1"># Set metadata</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;Y&quot;</span><span class="p">})</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._standardize_dims">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._standardize_dims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standardize dimension names.&quot;&quot;&quot;</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Identify time dimension</span>
        <span class="n">time_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">time_candidates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dim_map</span><span class="p">[</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
                <span class="k">break</span>
        
        <span class="c1"># Identify spatial dimensions</span>
        <span class="n">spatial_pairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">([</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="s1">&#39;lat&#39;</span><span class="p">),</span>
            <span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">std_name</span> <span class="ow">in</span> <span class="n">spatial_pairs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">dim_map</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_name</span>
                    <span class="k">break</span>
        
        <span class="c1"># Rename dimensions if needed</span>
        <span class="k">if</span> <span class="n">dim_map</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DataArray must have &#39;time&#39; dimension. Found: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">da</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._get_metadata">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._get_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metadata dictionary for the index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span> <span class="o">==</span> <span class="n">ExtremeType</span><span class="o">.</span><span class="n">HOT</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;TMAX&#39;</span><span class="p">:</span>
                <span class="n">long_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Percentage of hot days (TX &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">long_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Percentage of hot nights (TN &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;TMAX&#39;</span><span class="p">:</span>
                <span class="n">long_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Percentage of cold days (TX &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">long_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Percentage of cold nights (TN &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="n">long_name</span><span class="p">,</span>
            <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span>
            <span class="s1">&#39;base_period&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;percentile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span>
            <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_type</span><span class="p">,</span>
            <span class="s1">&#39;extreme_type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="s1">&#39;season&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">else</span> <span class="s1">&#39;all months&#39;</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;5-day centered window percentile&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;ETCCDI Climate Change Indices (2009)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;calculation&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual percentage of days when </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">var_type</span><span class="si">}</span><span class="s1"> is </span><span class="si">{</span><span class="s2">&quot;&gt;&quot;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">extreme_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ExtremeType</span><span class="o">.</span><span class="n">HOT</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;&lt;&quot;</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile of base period&#39;</span>
        <span class="p">}</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._format_to_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._format_to_cdt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_to_cdt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert to CDT format.&quot;&quot;&quot;</span>
        <span class="c1"># Pivot to wide format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index_name</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Exclude YEAR column</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        
        <span class="c1"># Rename YEAR column to ID for CDT format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">lat_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">lon_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        
        <span class="c1"># Combine all rows</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices.get_index_definition">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices.get_index_definition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index definition metadata.&quot;&quot;&quot;</span>
        <span class="n">definition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata</span><span class="p">()</span>
        <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;index_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span>
        <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;etccdi_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_etccdi_id</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">definition</span></div>

    
<div class="viewcode-block" id="WAS_TempPercentileIndices._get_etccdi_id">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_TempPercentileIndices._get_etccdi_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_etccdi_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get ETCCDI official ID for the index.&quot;&quot;&quot;</span>
        <span class="c1"># Standard ETCCDI indices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">==</span> <span class="s2">&quot;TX90p&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Warm days&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">==</span> <span class="s2">&quot;TN90p&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Warm nights&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">==</span> <span class="s2">&quot;TX10p&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Cold days&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">==</span> <span class="s2">&quot;TN10p&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Cold nights&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Custom: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index_name</span><span class="si">}</span><span class="s2">&quot;</span></div>
</div>



<span class="c1"># Convenience class creators for standard ETCCDI indices</span>
<div class="viewcode-block" id="ETCCDITempIndices">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDITempIndices">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ETCCDITempIndices</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory for creating standard ETCCDI temperature indices.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ETCCDITempIndices.hot_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDITempIndices.hot_days">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hot_days</span><span class="p">(</span><span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for hot days (TX90p).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
            <span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;TMAX&#39;</span><span class="p">,</span>
            <span class="n">extreme_type</span><span class="o">=</span><span class="s1">&#39;hot&#39;</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="ETCCDITempIndices.hot_nights">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDITempIndices.hot_nights">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hot_nights</span><span class="p">(</span><span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for hot nights (TN90p).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
            <span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;TMIN&#39;</span><span class="p">,</span>
            <span class="n">extreme_type</span><span class="o">=</span><span class="s1">&#39;hot&#39;</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="ETCCDITempIndices.cold_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDITempIndices.cold_days">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cold_days</span><span class="p">(</span><span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for cold days (TX10p).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
            <span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;TMAX&#39;</span><span class="p">,</span>
            <span class="n">extreme_type</span><span class="o">=</span><span class="s1">&#39;cold&#39;</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="ETCCDITempIndices.cold_nights">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDITempIndices.cold_nights">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cold_nights</span><span class="p">(</span><span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for cold nights (TN10p).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_TempPercentileIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
            <span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;TMIN&#39;</span><span class="p">,</span>
            <span class="n">extreme_type</span><span class="o">=</span><span class="s1">&#39;cold&#39;</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>
</div>



<span class="c1"># class WAS_r95_99p:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the R95p and R99p climate indices.</span>
    
<span class="c1">#     Definition (Adapted ETCCDI): </span>
<span class="c1">#     Annual total precipitation from days exceeding the daily percentile threshold.</span>
<span class="c1">#     - Thresholds are calculated using a 5-day centered window on the base period.</span>
<span class="c1">#     - Percentiles are typically derived from Wet Days (&gt;= 1mm) only.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, base_period: slice, season: list = None, wet_day_threshold: float = 1.0):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Initialize the precipitation percentile computation class.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         base_period : slice</span>
<span class="c1">#             Base period for computing the percentiles, e.g., slice(&quot;1961&quot;, &quot;1990&quot;).</span>
<span class="c1">#         season : list, optional</span>
<span class="c1">#             List of months to include in the analysis (e.g., [6, 7, 8] for JJA).</span>
<span class="c1">#         wet_day_threshold : float, optional</span>
<span class="c1">#             Threshold to define a &#39;wet day&#39; for percentile calculation (default 1.0 mm).</span>
<span class="c1">#             Values below this are excluded when calculating the percentile to avoid </span>
<span class="c1">#             skewing the threshold with zeros.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.base_period = base_period</span>
<span class="c1">#         self.season = season</span>
<span class="c1">#         self.wet_day_threshold = wet_day_threshold</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def transform_cdt(df):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Transform a DataFrame in CDT format into a standardized long DataFrame.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         metadata = df.iloc[:3].set_index(&quot;ID&quot;).T.reset_index()</span>
<span class="c1">#         metadata.columns = [&quot;STATION&quot;, &quot;LON&quot;, &quot;LAT&quot;, &quot;ELEV&quot;]</span>

<span class="c1">#         data_part = df.iloc[3:].rename(columns={&quot;ID&quot;: &quot;DATE&quot;})</span>
<span class="c1">#         data_long = data_part.melt(id_vars=[&quot;DATE&quot;], var_name=&quot;STATION&quot;, value_name=&quot;VALUE&quot;)</span>

<span class="c1">#         final_df = pd.merge(data_long, metadata, on=&quot;STATION&quot;)</span>
<span class="c1">#         final_df[&quot;DATE&quot;] = pd.to_datetime(final_df[&quot;DATE&quot;], format=&quot;%Y%m%d&quot;)</span>

<span class="c1">#         # Handle numeric conversion and missing values</span>
<span class="c1">#         final_df[&quot;VALUE&quot;] = pd.to_numeric(final_df[&quot;VALUE&quot;], errors=&#39;coerce&#39;)</span>
<span class="c1">#         # Treat -99.0 as NaN</span>
<span class="c1">#         final_df[&quot;VALUE&quot;] = final_df[&quot;VALUE&quot;].replace(-99.0, np.nan)</span>

<span class="c1">#         return final_df</span>

<span class="c1">#     def _calc_rolling_thresholds_insitu(self, df_base, percentile):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Calculate daily percentiles using a 5-day centered window across all years.</span>
<span class="c1">#         Only considers WET DAYS (&gt;= self.wet_day_threshold).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Filter for wet days ONLY for the threshold calculation</span>
<span class="c1">#         # (Standard ETCCDI practice: percentiles are based on wet sample)</span>
<span class="c1">#         df_wet = df_base[df_base[&quot;VALUE&quot;] &gt;= self.wet_day_threshold].copy()</span>

<span class="c1">#         if df_wet.empty:</span>
<span class="c1">#             # Return empty or handle gracefully if no wet days exist</span>
<span class="c1">#             return pd.DataFrame(columns=[&quot;DOY&quot;, &quot;STATION&quot;, &quot;THRESHOLD&quot;])</span>

<span class="c1">#         # Pivot: Index=Date, Columns=Station</span>
<span class="c1">#         wide = df_wet.pivot(index=&quot;DATE&quot;, columns=&quot;STATION&quot;, values=&quot;VALUE&quot;)</span>
<span class="c1">#         doy = wide.index.dayofyear</span>
        
<span class="c1">#         # Pre-group by DOY for speed</span>
<span class="c1">#         groups = {d: wide[doy == d].values for d in range(1, 367)}</span>
<span class="c1">#         unique_stations = wide.columns</span>
        
<span class="c1">#         daily_thresholds = {}</span>

<span class="c1">#         for d in range(1, 367):</span>
<span class="c1">#             # 5-day circular window</span>
<span class="c1">#             window_days = []</span>
<span class="c1">#             for offset in range(-2, 3):</span>
<span class="c1">#                 target = d + offset</span>
<span class="c1">#                 if target &lt; 1: target += 365</span>
<span class="c1">#                 if target &gt; 366: target -= 366</span>
<span class="c1">#                 window_days.append(target)</span>
            
<span class="c1">#             # Gather data</span>
<span class="c1">#             arrays = [groups.get(wd, np.empty((0, len(unique_stations)))) for wd in window_days]</span>
<span class="c1">#             window_data = np.vstack(arrays)</span>
            
<span class="c1">#             # Compute percentile (ignoring NaNs)</span>
<span class="c1">#             with np.errstate(invalid=&#39;ignore&#39;):</span>
<span class="c1">#                 th = np.nanpercentile(window_data, percentile, axis=0)</span>
            
<span class="c1">#             daily_thresholds[d] = th</span>

<span class="c1">#         thresh_df = pd.DataFrame(daily_thresholds, index=unique_stations).T</span>
<span class="c1">#         thresh_df.index.name = &quot;DOY&quot;</span>
        
<span class="c1">#         return thresh_df.reset_index().melt(</span>
<span class="c1">#             id_vars=&quot;DOY&quot;, var_name=&quot;STATION&quot;, value_name=&quot;THRESHOLD&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#     def _compute_percentile_index_insitu(self, df_full, percentile=95) -&gt; pd.DataFrame:</span>
<span class="c1">#         # 1) Filter Season</span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             df_full = df_full[df_full[&quot;DATE&quot;].dt.month.isin(self.season)]</span>

<span class="c1">#         # 2) Extract Base Period</span>
<span class="c1">#         start_str, end_str = self.base_period.start, self.base_period.stop</span>
<span class="c1">#         if len(str(start_str)) == 4:</span>
<span class="c1">#             s_date = pd.to_datetime(f&quot;{start_str}-01-01&quot;)</span>
<span class="c1">#             e_date = pd.to_datetime(f&quot;{end_str}-12-31&quot;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             s_date = pd.to_datetime(start_str)</span>
<span class="c1">#             e_date = pd.to_datetime(end_str)</span>

<span class="c1">#         df_base = df_full[(df_full[&quot;DATE&quot;] &gt;= s_date) &amp; (df_full[&quot;DATE&quot;] &lt;= e_date)]</span>

<span class="c1">#         # 3) Calculate Thresholds (5-day window, Wet days only)</span>
<span class="c1">#         thresholds = self._calc_rolling_thresholds_insitu(df_base, percentile)</span>

<span class="c1">#         # 4) Merge Thresholds</span>
<span class="c1">#         df_full[&quot;DOY&quot;] = df_full[&quot;DATE&quot;].dt.dayofyear</span>
<span class="c1">#         df_merged = pd.merge(df_full, thresholds, on=[&quot;STATION&quot;, &quot;DOY&quot;], how=&quot;left&quot;)</span>

<span class="c1">#         # 5) Identify Exceedances</span>
<span class="c1">#         # Definition: Total PR where PR &gt; Threshold.</span>
<span class="c1">#         # Note: We check against original VALUE (which includes dry days).</span>
<span class="c1">#         # Usually, a dry day (0mm) won&#39;t exceed a wet-day percentile, but we check validity.</span>
        
<span class="c1">#         df_merged[&quot;EXCESS_VAL&quot;] = np.where(</span>
<span class="c1">#             (df_merged[&quot;VALUE&quot;] &gt; df_merged[&quot;THRESHOLD&quot;]) &amp; (df_merged[&quot;VALUE&quot;].notna()),</span>
<span class="c1">#             df_merged[&quot;VALUE&quot;], # Add the rain amount</span>
<span class="c1">#             0.0</span>
<span class="c1">#         )</span>
        
<span class="c1">#         # 6) Aggregate Sum by Year/Station</span>
<span class="c1">#         df_merged[&quot;year&quot;] = df_merged[&quot;DATE&quot;].dt.year</span>
        
<span class="c1">#         # R95p is the SUM of precipitation on extreme days</span>
<span class="c1">#         df_result = (</span>
<span class="c1">#             df_merged</span>
<span class="c1">#             .groupby([&quot;station&quot;, &quot;year&quot;, &quot;LAT&quot;, &quot;LON&quot;], as_index=False)[&quot;EXCESS_VAL&quot;]</span>
<span class="c1">#             .sum()</span>
<span class="c1">#             .rename(columns={&quot;EXCESS_VAL&quot;: f&quot;R{percentile}p&quot;})</span>
<span class="c1">#         )</span>

<span class="c1">#         return df_result</span>

<span class="c1">#     def compute_insitu_r95p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot;Compute R95p (Total Precip on days &gt; 95th percentile).&quot;&quot;&quot;</span>
<span class="c1">#         return self._wrapper_insitu_compute(df_cdt, percentile=95)</span>

<span class="c1">#     def compute_insitu_r99p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot;Compute R99p (Total Precip on days &gt; 99th percentile).&quot;&quot;&quot;</span>
<span class="c1">#         return self._wrapper_insitu_compute(df_cdt, percentile=99)</span>

<span class="c1">#     def _wrapper_insitu_compute(self, df_cdt, percentile):</span>
<span class="c1">#         df_full = self.transform_cdt(df_cdt)</span>
<span class="c1">#         df_res = self._compute_percentile_index_insitu(df_full, percentile=percentile)</span>
        
<span class="c1">#         col_name = f&quot;R{percentile}p&quot;</span>
<span class="c1">#         df_pivot = df_res.pivot(index=&quot;year&quot;, columns=&quot;station&quot;, values=col_name).reset_index()</span>
<span class="c1">#         df_pivot.rename(columns={&quot;year&quot;: &quot;STATION&quot;}, inplace=True)</span>

<span class="c1">#         station_metadata = (</span>
<span class="c1">#             df_res.groupby(&quot;station&quot;)[[&quot;LAT&quot;, &quot;LON&quot;]]</span>
<span class="c1">#             .first()</span>
<span class="c1">#             .reindex(df_pivot.columns[1:])</span>
<span class="c1">#         )</span>
<span class="c1">#         lat_row = [&quot;LAT&quot;] + station_metadata[&quot;LAT&quot;].tolist()</span>
<span class="c1">#         lon_row = [&quot;LON&quot;] + station_metadata[&quot;LON&quot;].tolist()</span>

<span class="c1">#         lat_df = pd.DataFrame([lat_row], columns=df_pivot.columns)</span>
<span class="c1">#         lon_df = pd.DataFrame([lon_row], columns=df_pivot.columns)</span>

<span class="c1">#         return pd.concat([lat_df, lon_df, df_pivot], ignore_index=True)</span>

<span class="c1">#     # -------------------------------------------------------------------------</span>
<span class="c1">#     # XARRAY METHODS</span>
<span class="c1">#     # -------------------------------------------------------------------------</span>

<span class="c1">#     def compute_r95p(self, pr: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         return self._compute_percentile_index_xarray(pr, percentile=95)</span>

<span class="c1">#     def compute_r99p(self, pr: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         return self._compute_percentile_index_xarray(pr, percentile=99)</span>

<span class="c1">#     def _compute_percentile_index_xarray(self, pr: &quot;xr.DataArray&quot;, percentile: float) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         # 1. Select Base Period</span>
<span class="c1">#         pr_base = pr.sel(time=self.base_period)</span>

<span class="c1">#         # 2. Filter Wet Days for Threshold Calculation</span>
<span class="c1">#         # Replace non-wet days with NaN so they are ignored in percentile calc</span>
<span class="c1">#         pr_base_wet = pr_base.where(pr_base &gt;= self.wet_day_threshold)</span>

<span class="c1">#         # 3. Construct 5-day Window</span>
<span class="c1">#         # (time, lat, lon) -&gt; (time, window, lat, lon)</span>
<span class="c1">#         pr_windowed = pr_base_wet.rolling(time=5, center=True, min_periods=1).construct(&quot;window&quot;)</span>
        
<span class="c1">#         # 4. Compute Threshold (Group by DOY)</span>
<span class="c1">#         pr_thresh = (</span>
<span class="c1">#             pr_windowed</span>
<span class="c1">#             .groupby(&quot;time.dayofyear&quot;)</span>
<span class="c1">#             .reduce(</span>
<span class="c1">#                 np.nanpercentile, </span>
<span class="c1">#                 dim=[&quot;time&quot;, &quot;window&quot;], </span>
<span class="c1">#                 q=percentile</span>
<span class="c1">#             )</span>
<span class="c1">#         )</span>

<span class="c1">#         # 5. Filter Season (if applied)</span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             pr = pr.where(pr.time.dt.month.isin(self.season), drop=True)</span>

<span class="c1">#         # 6. Broadcast and Compare</span>
<span class="c1">#         doy = pr.time.dt.dayofyear</span>
<span class="c1">#         threshold_broadcast = pr_thresh.sel(dayofyear=doy)</span>

<span class="c1">#         # Identify extreme days (Original data &gt; Threshold)</span>
<span class="c1">#         # Note: No need to filter wet days here; if it&#39;s &gt; threshold (which is &gt; 1mm), it&#39;s wet.</span>
<span class="c1">#         extreme_precip = pr.where(pr &gt; threshold_broadcast, 0.0)</span>

<span class="c1">#         # 7. Resample and Sum</span>
<span class="c1">#         result = extreme_precip.resample(time=&quot;Y&quot;).sum(dim=&quot;time&quot;, skipna=True)</span>

<span class="c1">#         return result</span>


<div class="viewcode-block" id="WAS_PrecipIndices">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_PrecipIndices</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct implementation of ETCCDI precipitation indices (R95p, R99p, etc.)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_period : slice</span>
<span class="sd">        Slice for base period years, e.g., slice(&quot;1991&quot;, &quot;2020&quot;)</span>
<span class="sd">    percentile : float</span>
<span class="sd">        Percentile value (95 for R95p, 99 for R99p)</span>
<span class="sd">    season : list, optional</span>
<span class="sd">        Months to consider (e.g., [6, 7, 8, 9] for JJAS)</span>
<span class="sd">    wet_day_threshold : float</span>
<span class="sd">        Minimum precipitation for a wet day (default 1.0 mm)</span>
<span class="sd">    min_base_years : int</span>
<span class="sd">        Minimum years required in base period (default 15)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="WAS_PrecipIndices.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wet_day_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">min_base_years</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_period</span> <span class="o">=</span> <span class="n">base_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="o">=</span> <span class="n">season</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span> <span class="o">=</span> <span class="n">wet_day_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span> <span class="o">=</span> <span class="n">min_base_years</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;R</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">)</span><span class="si">}</span><span class="s2">p&quot;</span>
        
        <span class="c1"># Validate percentile</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">percentile</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Percentile must be between 0 and 100, got </span><span class="si">{</span><span class="n">percentile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform CDT format to long format DataFrame.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pd.DataFrame</span>
<span class="sd">            Input DataFrame in CDT format</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Long format DataFrame with columns: DATE, STATION, VALUE, LAT, LON</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract metadata (first 3 rows)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Extract data (from row 3 onwards)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span>
        <span class="p">)</span>
        
        <span class="c1"># Merge and clean</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        
        <span class="c1"># Convert -99.0 to NaN</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">final</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices._validate_base_period">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices._validate_base_period">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_base_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">years</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that base period has sufficient data.&quot;&quot;&quot;</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">years</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_years</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Base period has only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_years</span><span class="p">)</span><span class="si">}</span><span class="s2"> years, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;which is less than recommended minimum of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_base_years</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices._compute_percentile_threshold">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices._compute_percentile_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_percentile_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute percentile threshold from base period wet days.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            DataFrame with threshold per station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Filter base period</span>
        <span class="n">base_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">base_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">df_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">base_start</span><span class="p">,</span> <span class="n">base_stop</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Filter wet days</span>
        <span class="n">df_wet</span> <span class="o">=</span> <span class="n">df_base</span><span class="p">[</span><span class="n">df_base</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Validate base period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_base_period</span><span class="p">(</span><span class="n">df_base</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># Compute threshold per station</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">df_wet</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">thresholds</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;THRESHOLD&quot;</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">thresholds</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_cdt</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute index for in-situ (station) data in CDT format.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_cdt : pd.DataFrame</span>
<span class="sd">            Input data in CDT format</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Result in CDT format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform to long format</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">df_cdt</span><span class="p">)</span>
        
        <span class="c1"># Compute thresholds from base period</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_percentile_threshold</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        
        <span class="c1"># Merge thresholds with data</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        
        <span class="c1"># Identify extreme precipitation days</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;EXTREME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">)</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;THRESHOLD&quot;</span><span class="p">]),</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span>
            <span class="mf">0.0</span>
        <span class="p">)</span>
        
        <span class="c1"># Apply seasonal filter if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">)]</span>
        
        <span class="c1"># Group by year and station</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">])[</span><span class="s2">&quot;EXTREME&quot;</span><span class="p">]</span> \
                   <span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> \
                   <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;EXTREME&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Convert back to CDT format</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_to_cdt</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices.compute_xarray">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices.compute_xarray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_xarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="c1"># chunk_size: Optional[Dict[str, int]] = None,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute index for xarray DataArray (gridded data).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xr.DataArray</span>
<span class="sd">            Precipitation DataArray with dimensions (time, y, x) or (time, lat, lon)</span>
<span class="sd">        chunk_size : dict, optional</span>
<span class="sd">            Chunk sizes for parallel processing, e.g., {&#39;y&#39;: 100, &#39;x&#39;: 100}</span>
<span class="sd">        parallel : bool</span>
<span class="sd">            Whether to use Dask for parallel processing</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            Annual index values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rename dimensions to standard names if needed</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_dims</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>

        
        <span class="c1"># Apply seasonal mask if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Handle chunking for Dask</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span><span class="c1"># and hasattr(da.data, &#39;chunks&#39;):</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))}</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">chunk_size</span><span class="p">})</span>
        
        <span class="c1"># Select base period</span>
        <span class="n">da_base</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="p">)</span>
        
        <span class="c1"># Get wet days in base period</span>
        <span class="n">wet_base</span> <span class="o">=</span> <span class="n">da_base</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da_base</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">)</span>
        
        <span class="c1"># Validate base period</span>
        <span class="n">base_years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da_base</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_base_period</span><span class="p">(</span><span class="n">base_years</span><span class="p">)</span>
        
        <span class="c1"># Compute percentile threshold from base period wet days</span>
        <span class="c1"># Using method=&#39;linear&#39; for consistency with ETCCDI</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">wet_base</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span> 
            <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        
        <span class="c1"># Identify extreme precipitation days</span>
        <span class="c1"># Condition: precipitation &gt;= wet_day_threshold AND &gt; threshold</span>
        <span class="n">extreme</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">da</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">da</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">),</span>
            <span class="n">da</span><span class="p">,</span>
            <span class="mf">0.0</span>
        <span class="p">)</span>
        
        <span class="c1"># Handle leap days by using &#39;YS&#39; (year start) resampling</span>
        <span class="c1"># This avoids issues with February 29th</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">extreme</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;YS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Rename result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual total precipitation when daily precipitation &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile&#39;</span><span class="p">,</span>
            <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="s1">&#39;mm&#39;</span><span class="p">),</span>
            <span class="s1">&#39;base_period&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;percentile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span>
            <span class="s1">&#39;wet_day_threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">,</span>
            <span class="s1">&#39;season&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">else</span> <span class="s1">&#39;all months&#39;</span>
        <span class="p">})</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;Y&quot;</span><span class="p">})</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices._standardize_dims">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices._standardize_dims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standardize dimension names.&quot;&quot;&quot;</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Identify time dimension</span>
        <span class="n">time_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">time_candidates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dim_map</span><span class="p">[</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
                <span class="k">break</span>
        
        <span class="c1"># Identify spatial dimensions</span>
        <span class="n">spatial_pairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">([</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span>
            <span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">std_name</span> <span class="ow">in</span> <span class="n">spatial_pairs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">dim_map</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_name</span>
                    <span class="k">break</span>
        
        <span class="c1"># Rename dimensions if needed</span>
        <span class="k">if</span> <span class="n">dim_map</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span>
        
        <span class="c1"># Ensure required dimensions exist</span>
        <span class="n">required_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">required_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DataArray must have &#39;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&#39; dimension. Found: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">da</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices._format_to_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices._format_to_cdt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_to_cdt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert long format DataFrame to CDT format.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pd.DataFrame</span>
<span class="sd">            Long format DataFrame with columns: STATION, YEAR, index_name, LAT, LON</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            DataFrame in CDT format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pivot to wide format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index_name</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        
        <span class="c1"># Ensure column order matches metadata</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Exclude YEAR column</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        
        <span class="c1"># Rename YEAR column to ID for CDT format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">lat_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">lon_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        
        <span class="c1"># Combine all rows</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span></div>

    
<div class="viewcode-block" id="WAS_PrecipIndices.get_index_definition">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_PrecipIndices.get_index_definition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index definition metadata.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;index_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_name</span><span class="p">,</span>
            <span class="s1">&#39;definition&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual total precipitation from days &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="si">}</span><span class="s1">th percentile of wet days (&gt;= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="si">}</span><span class="s1"> mm) in base period&#39;</span><span class="p">,</span>
            <span class="s1">&#39;base_period&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;wet_day_threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wet_day_threshold</span><span class="p">,</span>
            <span class="s1">&#39;season&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">else</span> <span class="s1">&#39;all months&#39;</span><span class="p">,</span>
            <span class="s1">&#39;etccdi_reference&#39;</span><span class="p">:</span> <span class="s1">&#39;ETCCDI Climate Change Indices&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;Zhang et al. (2011), Weather and Climate Extremes&#39;</span>
        <span class="p">}</span></div>
</div>



<span class="c1"># # Example usage</span>
<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#     # Example 1: In-situ data</span>
<span class="c1">#     # Assuming df_cdt is your CDT format DataFrame</span>
<span class="c1">#     # index_calc = WAS_PrecipIndices(base_period=slice(&quot;1991&quot;, &quot;2020&quot;), percentile=95)</span>
<span class="c1">#     # result_cdt = index_calc.compute_insitu(df_cdt)</span>
    
<span class="c1">#     # Example 2: Xarray data</span>
<span class="c1">#     # Assuming pr is your precipitation DataArray</span>
<span class="c1">#     # pr = xr.open_dataset(&#39;precipitation.nc&#39;).pr</span>
<span class="c1">#     # index_calc = WAS_PrecipIndices(base_period=slice(&quot;1991&quot;, &quot;2020&quot;), percentile=95)</span>
<span class="c1">#     # r95p = index_calc.compute_xarray(pr)</span>
    
<span class="c1">#     # Example 3: With season</span>
<span class="c1">#     # index_calc = WAS_PrecipIndices(</span>
<span class="c1">#     #     base_period=slice(&quot;1991&quot;, &quot;2020&quot;),</span>
<span class="c1">#     #     percentile=99,</span>
<span class="c1">#     #     season=[6, 7, 8, 9],  # JJAS</span>
<span class="c1">#     #     wet_day_threshold=1.0</span>
<span class="c1">#     # )</span>
    
<span class="c1">#     print(&quot;WAS_PrecipIndices class implemented with correct ETCCDI methodology.&quot;)</span>
<span class="c1">##########################################################################</span>
<span class="c1"># class WAS_r95_99p_:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the R95p and R99p climate indices using either:</span>
<span class="c1">#     - Dask-enabled xarray for large raster/time-series</span>
<span class="c1">#     - An &quot;insitu&quot; method for station-based (CDT) data.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, base_period: slice, season: list = None):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Initialize the R95p/R99p computation class.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         base_period : slice</span>
<span class="c1">#             Base period for computing the percentiles, e.g., slice(&quot;1961-01-01&quot;, &quot;1990-12-31&quot;).</span>
<span class="c1">#             This should be something like slice(&quot;YYYY-MM-DD&quot;, &quot;YYYY-MM-DD&quot;) or </span>
<span class="c1">#             slice(&quot;YYYY&quot;, &quot;YYYY&quot;) if you only have year-level bounds.</span>
<span class="c1">#         season : list, optional</span>
<span class="c1">#             List of months to include in the analysis (e.g., [6, 7, 8] for JJA).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.base_period = base_period</span>
<span class="c1">#         self.season = season</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def transform_cdt(df):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Transform a DataFrame in CDT format into a standardized long DataFrame.</span>

<span class="c1">#         CDT format assumptions:</span>
<span class="c1">#          - Row 0 = LON</span>
<span class="c1">#          - Row 1 = LAT</span>
<span class="c1">#          - Row 2 = ELEV</span>
<span class="c1">#          - Rows 3+ = daily data with &#39;ID&#39; column holding dates in YYYYMMDD format.</span>

<span class="c1">#         Returns a DataFrame with columns:</span>
<span class="c1">#             [DATE, STATION, VALUE, LON, LAT, ELEV]</span>
<span class="c1">#         &quot;&quot;&quot;</span>

<span class="c1">#         # 1) Extract metadata (first 3 rows)</span>
<span class="c1">#         #    - &#39;ID&#39; column in these rows has labels [&quot;LON&quot;, &quot;LAT&quot;, &quot;ELEV&quot;]</span>
<span class="c1">#         metadata = df.iloc[:3].set_index(&quot;ID&quot;).T.reset_index()</span>
<span class="c1">#         metadata.columns = [&quot;STATION&quot;, &quot;LON&quot;, &quot;LAT&quot;, &quot;ELEV&quot;]</span>

<span class="c1">#         # 2) Extract the daily data portion (from row 3 onward); rename &quot;ID&quot; -&gt; &quot;DATE&quot;</span>
<span class="c1">#         data_part = df.iloc[3:].rename(columns={&quot;ID&quot;: &quot;DATE&quot;})</span>

<span class="c1">#         # Melt to long format: columns = [&quot;DATE&quot;, &quot;STATION&quot;, &quot;VALUE&quot;]</span>
<span class="c1">#         data_long = data_part.melt(</span>
<span class="c1">#             id_vars=[&quot;DATE&quot;],</span>
<span class="c1">#             var_name=&quot;STATION&quot;,</span>
<span class="c1">#             value_name=&quot;VALUE&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         # Merge station metadata</span>
<span class="c1">#         final_df = pd.merge(data_long, metadata, on=&quot;STATION&quot;)</span>

<span class="c1">#         # Convert &quot;DATE&quot; from string YYYYMMDD to datetime</span>
<span class="c1">#         final_df[&quot;DATE&quot;] = pd.to_datetime(final_df[&quot;DATE&quot;], format=&quot;%Y%m%d&quot;)</span>

<span class="c1">#         # Fill missing rainfall values with -99.0</span>
<span class="c1">#         final_df[&quot;VALUE&quot;] = final_df[&quot;VALUE&quot;].fillna(-99.0)</span>

<span class="c1">#         return final_df</span>

<span class="c1">#     def _compute_percentile_index_insitu(self, df_full, percentile=95) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Internal method that computes the &#39;Rxp&#39; index (R95p or R99p) for insitu data.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         df_full : pd.DataFrame</span>
<span class="c1">#             Must have columns [DATE, STATION, VALUE, LAT, LON, ELEV].</span>
<span class="c1">#         percentile : float</span>
<span class="c1">#             Percentile to compute (e.g., 95 for R95p or 99 for R99p).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         df_result : pd.DataFrame</span>
<span class="c1">#             DataFrame with [year, station, lat, lon, rX_p_value],</span>
<span class="c1">#             where rX_p_value is total precipitation above the threshold for each year.</span>
<span class="c1">#         &quot;&quot;&quot;</span>

<span class="c1">#         # 1) Possibly filter by season</span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             # Keep only rows whose month is in self.season</span>
<span class="c1">#             df_full = df_full[df_full[&quot;DATE&quot;].dt.month.isin(self.season)]</span>

<span class="c1">#         # 2) Separate out the base period to compute thresholds</span>
<span class="c1">#         #    self.base_period is typically something like slice(&quot;1961-01-01&quot;, &quot;1990-12-31&quot;)</span>
<span class="c1">#         #    We&#39;ll interpret it so we can do: df_base = df_full[(df_full[&quot;DATE&quot;] &gt;= start) &amp; (df_full[&quot;DATE&quot;] &lt;= end)]</span>
<span class="c1">#         start_str, end_str = self.base_period.start, self.base_period.stop</span>
<span class="c1">#         start_date = pd.to_datetime(start_str)</span>
<span class="c1">#         end_date = pd.to_datetime(end_str)</span>
<span class="c1">#         df_base = df_full[(df_full[&quot;DATE&quot;] &gt;= start_date) &amp; (df_full[&quot;DATE&quot;] &lt;= end_date)]</span>

<span class="c1">#         # 3) Compute day-of-year in both data sets</span>
<span class="c1">#         df_full[&quot;DOY&quot;] = df_full[&quot;DATE&quot;].dt.dayofyear</span>
<span class="c1">#         df_base[&quot;DOY&quot;] = df_base[&quot;DATE&quot;].dt.dayofyear</span>

<span class="c1">#         # 4) For each station and day-of-year in the base period, compute the percentile threshold</span>
<span class="c1">#         #    We&#39;ll group by (STATION, DOY) and compute np.nanpercentile</span>
<span class="c1">#         thresholds = (</span>
<span class="c1">#             df_base[df_base[&quot;VALUE&quot;] &gt;= 0]  # ignore negative placeholder</span>
<span class="c1">#             .groupby([&quot;STATION&quot;, &quot;DOY&quot;])[&quot;VALUE&quot;]</span>
<span class="c1">#             .apply(lambda x: np.nanpercentile(x, percentile))</span>
<span class="c1">#             .reset_index()</span>
<span class="c1">#             .rename(columns={&quot;VALUE&quot;: &quot;THRESHOLD&quot;})</span>
<span class="c1">#         )</span>

<span class="c1">#         # Merge thresholds back into df_full on (STATION, DOY)</span>
<span class="c1">#         df_merged = pd.merge(</span>
<span class="c1">#             df_full, </span>
<span class="c1">#             thresholds, </span>
<span class="c1">#             on=[&quot;STATION&quot;, &quot;DOY&quot;], </span>
<span class="c1">#             how=&quot;left&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         # 5) Identify days exceeding that threshold and sum them up (precip total) by station &amp; year</span>
<span class="c1">#         #    We&#39;ll also ignore negative precipitation (i.e. -99.0)</span>
<span class="c1">#         df_merged[&quot;EXCEEDS&quot;] = np.where(</span>
<span class="c1">#             (df_merged[&quot;VALUE&quot;] &gt; df_merged[&quot;THRESHOLD&quot;]) &amp; (df_merged[&quot;VALUE&quot;] &gt;= 0),</span>
<span class="c1">#             df_merged[&quot;VALUE&quot;],</span>
<span class="c1">#             0</span>
<span class="c1">#         )</span>
<span class="c1">#         df_merged[&quot;year&quot;] = df_merged[&quot;DATE&quot;].dt.year</span>

<span class="c1">#         # 6) Sum precipitation on those &quot;extreme&quot; days for each station-year</span>
<span class="c1">#         #    Then keep lat/lon from the first occurrence (assuming station lat/lon is fixed)</span>
<span class="c1">#         df_result = (</span>
<span class="c1">#             df_merged</span>
<span class="c1">#             .groupby([&quot;station&quot;, &quot;year&quot;, &quot;LAT&quot;, &quot;LON&quot;], as_index=False)[&quot;EXCEEDS&quot;]</span>
<span class="c1">#             .sum()</span>
<span class="c1">#             .rename(columns={&quot;EXCEEDS&quot;: f&quot;R{percentile}p&quot;})</span>
<span class="c1">#         )</span>

<span class="c1">#         return df_result</span>

<span class="c1">#     def compute_insitu_r95p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute R95p index (total precipitation on days above the daily 95th percentile)</span>
<span class="c1">#         for station-based data in CDT format.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         df_cdt : pd.DataFrame</span>
<span class="c1">#             CDT-format DataFrame (rows 0..2 = LON/LAT/ELEV, row 3+ = daily data).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         df_final : pd.DataFrame</span>
<span class="c1">#             A DataFrame in CPT format with the R95p values pivoted by station vs. year.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # 1) Transform CDT to standard DataFrame</span>
<span class="c1">#         df_full = self.transform_cdt(df_cdt)</span>

<span class="c1">#         # 2) Compute R95p</span>
<span class="c1">#         df_r95 = self._compute_percentile_index_insitu(df_full, percentile=95)</span>

<span class="c1">#         # 3) Pivot back to CPT format</span>
<span class="c1">#         #    a) Station in columns, year in rows</span>
<span class="c1">#         df_pivot = df_r95.pivot(index=&quot;year&quot;, columns=&quot;station&quot;, values=&quot;R95p&quot;).reset_index()</span>
<span class="c1">#         df_pivot.rename(columns={&quot;year&quot;: &quot;STATION&quot;}, inplace=True)</span>

<span class="c1">#         # b) Build LAT/LON rows, using first occurrence for each station</span>
<span class="c1">#         station_metadata = (</span>
<span class="c1">#             df_r95.groupby(&quot;station&quot;)[[&quot;LAT&quot;, &quot;LON&quot;]]</span>
<span class="c1">#             .first()</span>
<span class="c1">#             .reindex(df_pivot.columns[1:])  # ensure same station order as pivot</span>
<span class="c1">#         )</span>
<span class="c1">#         lat_row = [&quot;LAT&quot;] + station_metadata[&quot;LAT&quot;].tolist()</span>
<span class="c1">#         lon_row = [&quot;LON&quot;] + station_metadata[&quot;LON&quot;].tolist()</span>

<span class="c1">#         # c) Insert them above the pivoted DataFrame</span>
<span class="c1">#         lat_df = pd.DataFrame([lat_row], columns=df_pivot.columns)</span>
<span class="c1">#         lon_df = pd.DataFrame([lon_row], columns=df_pivot.columns)</span>

<span class="c1">#         df_final = pd.concat([lat_df, lon_df, df_pivot], ignore_index=True)</span>

<span class="c1">#         return df_final</span>

<span class="c1">#     def compute_insitu_r99p(self, df_cdt: pd.DataFrame) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute R99p index (total precipitation on days above the daily 99th percentile)</span>
<span class="c1">#         for station-based data in CDT format.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         df_cdt : pd.DataFrame</span>
<span class="c1">#             CDT-format DataFrame.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         df_final : pd.DataFrame (CPT format)</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # 1) Transform</span>
<span class="c1">#         df_full = self.transform_cdt(df_cdt)</span>

<span class="c1">#         # 2) Compute R99p</span>
<span class="c1">#         df_r99 = self._compute_percentile_index_insitu(df_full, percentile=99)</span>

<span class="c1">#         # 3) Pivot to CPT format</span>
<span class="c1">#         df_pivot = df_r99.pivot(index=&quot;year&quot;, columns=&quot;station&quot;, values=&quot;R99p&quot;).reset_index()</span>
<span class="c1">#         df_pivot.rename(columns={&quot;year&quot;: &quot;STATION&quot;}, inplace=True)</span>

<span class="c1">#         station_metadata = (</span>
<span class="c1">#             df_r99.groupby(&quot;station&quot;)[[&quot;LAT&quot;, &quot;LON&quot;]]</span>
<span class="c1">#             .first()</span>
<span class="c1">#             .reindex(df_pivot.columns[1:])</span>
<span class="c1">#         )</span>
<span class="c1">#         lat_row = [&quot;LAT&quot;] + station_metadata[&quot;LAT&quot;].tolist()</span>
<span class="c1">#         lon_row = [&quot;LON&quot;] + station_metadata[&quot;LON&quot;].tolist()</span>

<span class="c1">#         lat_df = pd.DataFrame([lat_row], columns=df_pivot.columns)</span>
<span class="c1">#         lon_df = pd.DataFrame([lon_row], columns=df_pivot.columns)</span>

<span class="c1">#         df_final = pd.concat([lat_df, lon_df, df_pivot], ignore_index=True)</span>
<span class="c1">#         return df_final</span>

<span class="c1">#     #</span>
<span class="c1">#     # The existing xarray-based methods for large raster data remain the same:</span>
<span class="c1">#     #</span>
<span class="c1">#     def compute_r95p(self, pr: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Existing method for xarray-based data (unchanged).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         return self._compute_percentile_index(pr, percentile=95)</span>

<span class="c1">#     def compute_r99p(self, pr: &quot;xr.DataArray&quot;) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Existing method for xarray-based data (unchanged).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         return self._compute_percentile_index(pr, percentile=99)</span>

<span class="c1">#     def _compute_percentile_index(self, pr: &quot;xr.DataArray&quot;, percentile: float) -&gt; &quot;xr.DataArray&quot;:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Existing private method for xarray-based data (unchanged).</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Subset to base period</span>
<span class="c1">#         pr_base = pr.sel(time=self.base_period)</span>

<span class="c1">#         # Apply seasonal filtering if specified</span>
<span class="c1">#         if self.season:</span>
<span class="c1">#             pr = pr.where(pr.time.dt.month.isin(self.season), drop=True)</span>
<span class="c1">#             pr_base = pr_base.where(pr_base.time.dt.month.isin(self.season), drop=True)</span>

<span class="c1">#         # Compute the percentile for each day-of-year in the base period</span>
<span class="c1">#         pr_thresh = pr_base.groupby(&quot;time.dayofyear&quot;).reduce(</span>
<span class="c1">#             np.nanpercentile, q=percentile, dim=&quot;time&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         # Broadcast threshold to full time dimension</span>
<span class="c1">#         doy = pr.time.dt.dayofyear</span>
<span class="c1">#         threshold_broadcast = pr_thresh.sel(dayofyear=doy.values)</span>

<span class="c1">#         # Identify very wet days exceeding the threshold</span>
<span class="c1">#         extreme_days = pr.where(pr &gt; threshold_broadcast)</span>

<span class="c1">#         # Sum precipitation on very wet days for each year</span>
<span class="c1">#         result = extreme_days.resample(time=&quot;Y&quot;).sum(dim=&quot;time&quot;, skipna=True)</span>

<span class="c1">#         return result</span>




<div class="viewcode-block" id="HeatWaveMetric">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.HeatWaveMetric">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HeatWaveMetric</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ETCCDI Heat Wave Indices.&quot;&quot;&quot;</span>
    <span class="n">HWDI</span> <span class="o">=</span> <span class="s2">&quot;HWDI&quot;</span>  <span class="c1"># Heat Wave Duration Index (days in longest heat wave)</span>
    <span class="n">HWF</span> <span class="o">=</span> <span class="s2">&quot;HWF&quot;</span>    <span class="c1"># Heat Wave Frequency (number of heat waves)</span>
    <span class="n">HWN</span> <span class="o">=</span> <span class="s2">&quot;HWN&quot;</span>    <span class="c1"># Heat Wave Number (not standard ETCCDI, but sometimes used)</span>
    <span class="n">WSDI</span> <span class="o">=</span> <span class="s2">&quot;WSDI&quot;</span>  <span class="c1"># Warm Spell Duration Index (ETCCDI standard)</span></div>


<div class="viewcode-block" id="HeatWaveDefinition">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.HeatWaveDefinition">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">HeatWaveDefinition</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Definition of a heat wave event.&quot;&quot;&quot;</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span>
    <span class="n">end_date</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span>
    <span class="n">duration</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">max_temp</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">mean_temp</span><span class="p">:</span> <span class="nb">float</span></div>


<div class="viewcode-block" id="WAS_HeatWaveIndices">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_HeatWaveIndices</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct implementation of ETCCDI heat wave indices.</span>
<span class="sd">    </span>
<span class="sd">    Standard ETCCDI Indices:</span>
<span class="sd">    1. WSDI (Warm Spell Duration Index): Annual count of days with at least </span>
<span class="sd">       6 consecutive days when TX &gt; 90th percentile</span>
<span class="sd">    2. HWF (Heat Wave Frequency): Annual count of heat wave events</span>
<span class="sd">    3. HWDI (Heat Wave Duration Index): Annual maximum length of heat waves</span>
<span class="sd">    </span>
<span class="sd">    Reference: </span>
<span class="sd">    - ETCCDI Climate Change Indices (2009)</span>
<span class="sd">    - Perkins &amp; Alexander (2013): On the measurement of heat waves</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="WAS_HeatWaveIndices.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">tx_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>        <span class="c1"># Percentile for TX (usually 90)</span>
        <span class="n">tn_percentile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Optional: for TN in compound heat waves</span>
        <span class="n">min_consecutive_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>    <span class="c1"># Min days for a heat wave (ETCCDI uses 6 for WSDI)</span>
        <span class="n">max_break_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>          <span class="c1"># Max break days allowed within a heat wave</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Months to consider (e.g., [5, 6, 7, 8, 9])</span>
        <span class="n">require_both_tx_tn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># If True, requires both TX and TN exceed percentiles</span>
        <span class="n">min_intensity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optional minimum intensity threshold</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_period : slice</span>
<span class="sd">            Base period for percentile calculation, e.g., slice(&quot;1961&quot;, &quot;1990&quot;)</span>
<span class="sd">        tx_percentile : float</span>
<span class="sd">            Percentile for daily maximum temperature (TX)</span>
<span class="sd">        tn_percentile : float, optional</span>
<span class="sd">            Percentile for daily minimum temperature (TN) for compound heat waves</span>
<span class="sd">        min_consecutive_days : int</span>
<span class="sd">            Minimum consecutive days for a heat wave (ETCCDI WSDI uses 6)</span>
<span class="sd">        max_break_days : int</span>
<span class="sd">            Maximum number of break days allowed within a heat wave</span>
<span class="sd">        season : list, optional</span>
<span class="sd">            Months to consider for heat wave analysis</span>
<span class="sd">        require_both_tx_tn : bool</span>
<span class="sd">            If True, requires both TX and TN to exceed percentiles (compound heat wave)</span>
<span class="sd">        min_intensity : float, optional</span>
<span class="sd">            Minimum intensity (e.g., temperature anomaly) for a heat wave</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_period</span> <span class="o">=</span> <span class="n">base_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span> <span class="o">=</span> <span class="n">tx_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span> <span class="o">=</span> <span class="n">tn_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span> <span class="o">=</span> <span class="n">min_consecutive_days</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_break_days</span> <span class="o">=</span> <span class="n">max_break_days</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="o">=</span> <span class="n">season</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_both_tx_tn</span> <span class="o">=</span> <span class="n">require_both_tx_tn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_intensity</span> <span class="o">=</span> <span class="n">min_intensity</span>
        
        <span class="c1"># Validate inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._validate_inputs">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._validate_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate all input parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_consecutive_days must be &gt;= 1, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_break_days</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_break_days must be &gt;= 0, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_break_days</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tx_percentile must be between 0 and 100, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tn_percentile must be between 0 and 100, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices.transform_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices.transform_cdt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_cdt</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform CDT format to long format DataFrame.&quot;&quot;&quot;</span>
        <span class="c1"># Extract metadata</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEV&quot;</span><span class="p">]</span>
        
        <span class="c1"># Extract data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;DATE&quot;</span><span class="p">})</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span>
        <span class="p">)</span>
        
        <span class="c1"># Merge and clean</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        
        <span class="c1"># Convert -99.0 to NaN</span>
        <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">final</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._calculate_temperature_thresholds">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._calculate_temperature_thresholds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_temperature_thresholds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">df_temp</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TX&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate temperature thresholds using 5-day centered window.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_temp : pd.DataFrame</span>
<span class="sd">            Temperature data with columns: DATE, STATION, VALUE</span>
<span class="sd">        percentile : float</span>
<span class="sd">            Percentile to calculate (e.g., 90 for 90th percentile)</span>
<span class="sd">        var_name : str</span>
<span class="sd">            Variable name for metadata</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Thresholds for each day of year and station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pivot to wide format</span>
        <span class="n">wide</span> <span class="o">=</span> <span class="n">df_temp</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">)</span>
        
        <span class="c1"># Handle leap days</span>
        <span class="n">doy_series</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">)</span>
        <span class="n">wide_doy</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">wide_doy</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">doy_series</span>
        
        <span class="c1"># Calculate thresholds for each day of year (1-365) using 5-day window</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">doy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">366</span><span class="p">):</span>
            <span class="c1"># Create 5-day centered window (circular for year boundaries)</span>
            <span class="n">window_days</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">window_doy</span> <span class="o">=</span> <span class="p">((</span><span class="n">doy</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">365</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">window_days</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_doy</span><span class="p">)</span>
            
            <span class="c1"># Get data for this window</span>
            <span class="n">window_mask</span> <span class="o">=</span> <span class="n">wide_doy</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">window_days</span><span class="p">)</span>
            <span class="n">window_data</span> <span class="o">=</span> <span class="n">wide_doy</span><span class="p">[</span><span class="n">window_mask</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate percentile for each station</span>
                <span class="n">threshold_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                    <span class="n">window_data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                    <span class="n">percentile</span><span class="p">,</span> 
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">thresholds</span><span class="p">[</span><span class="n">doy</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold_values</span>
        
        <span class="c1"># Convert to DataFrame</span>
        <span class="n">thresholds_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">wide</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">thresholds_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;DOY&quot;</span>
        <span class="n">thresholds_df</span> <span class="o">=</span> <span class="n">thresholds_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;DOY&quot;</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">_THRESHOLD&quot;</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">thresholds_df</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._identify_hot_days">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._identify_hot_days">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_identify_hot_days</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df_temp</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">thresholds</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TX&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify days when temperature exceeds threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge thresholds with data</span>
        <span class="n">df_temp</span><span class="p">[</span><span class="s2">&quot;DOY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">df_temp</span><span class="p">,</span> 
            <span class="n">thresholds</span><span class="p">,</span> 
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;DOY&quot;</span><span class="p">],</span> 
            <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
        <span class="p">)</span>
        
        <span class="c1"># Identify hot days (temperature &gt; threshold)</span>
        <span class="n">threshold_col</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">_THRESHOLD&quot;</span>
        <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;IS_HOT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">threshold_col</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="s2">&quot;IS_HOT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">return</span> <span class="n">merged</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._detect_heat_waves">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._detect_heat_waves">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_heat_waves</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df_hot_days</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">intensity_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect heat wave events from sequence of hot days.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_hot_days : pd.DataFrame</span>
<span class="sd">            DataFrame with IS_HOT column (0/1 for non-hot/hot days)</span>
<span class="sd">        intensity_col : str, optional</span>
<span class="sd">            Column with intensity values for filtering</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            DataFrame with heat wave events detected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort by station and date</span>
        <span class="n">df_hot_days</span> <span class="o">=</span> <span class="n">df_hot_days</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;DATE&quot;</span><span class="p">])</span>
        
        <span class="n">heat_waves</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">station</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df_hot_days</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">):</span>
            <span class="c1"># Get hot day sequence</span>
            <span class="n">is_hot</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;IS_HOT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dates</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            
            <span class="c1"># Identify runs of hot days</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_hot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Find start and end of hot spells</span>
            <span class="c1"># Pad with False at both ends for edge detection</span>
            <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_hot</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">padded</span><span class="p">)</span>
            
            <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Check each potential heat wave</span>
            <span class="k">for</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">):</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span>
                
                <span class="c1"># Apply minimum duration filter</span>
                <span class="k">if</span> <span class="n">duration</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="p">:</span>
                    <span class="c1"># Extract heat wave period</span>
                    <span class="n">heat_wave_dates</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
                    <span class="n">heat_wave_data</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
                    
                    <span class="c1"># Optional intensity filter</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_intensity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">intensity_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">mean_intensity</span> <span class="o">=</span> <span class="n">heat_wave_data</span><span class="p">[</span><span class="n">intensity_col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">mean_intensity</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_intensity</span><span class="p">:</span>
                            <span class="k">continue</span>
                    
                    <span class="c1"># Create heat wave record</span>
                    <span class="n">heat_wave</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;STATION&quot;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                        <span class="s2">&quot;START_DATE&quot;</span><span class="p">:</span> <span class="n">heat_wave_dates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s2">&quot;END_DATE&quot;</span><span class="p">:</span> <span class="n">heat_wave_dates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s2">&quot;DURATION&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                        <span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="n">heat_wave_dates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                        <span class="s2">&quot;LAT&quot;</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s2">&quot;LON&quot;</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">}</span>
                    
                    <span class="c1"># Add intensity metrics if available</span>
                    <span class="k">if</span> <span class="s2">&quot;VALUE&quot;</span> <span class="ow">in</span> <span class="n">heat_wave_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">heat_wave</span><span class="p">[</span><span class="s2">&quot;MAX_TEMP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heat_wave_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                        <span class="n">heat_wave</span><span class="p">[</span><span class="s2">&quot;MEAN_TEMP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heat_wave_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="n">heat_wave</span><span class="p">[</span><span class="s2">&quot;INTENSITY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">heat_wave_data</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">-</span> 
                            <span class="n">heat_wave_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;TX_THRESHOLD&quot;</span><span class="p">]</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    
                    <span class="n">heat_waves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heat_wave</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">heat_waves</span><span class="p">)</span> <span class="k">if</span> <span class="n">heat_waves</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices.compute_insitu">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices.compute_insitu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_insitu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df_cdt_tx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">df_cdt_tn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;WSDI&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute heat wave indices for in-situ data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_cdt_tx : pd.DataFrame</span>
<span class="sd">            Daily maximum temperature in CDT format</span>
<span class="sd">        df_cdt_tn : pd.DataFrame, optional</span>
<span class="sd">            Daily minimum temperature in CDT format (for compound heat waves)</span>
<span class="sd">        metric : str</span>
<span class="sd">            Heat wave metric to compute: &quot;WSDI&quot;, &quot;HWF&quot;, or &quot;HWDI&quot;</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Results in CDT format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform CDT data</span>
        <span class="n">df_tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">df_cdt_tx</span><span class="p">)</span>
        
        <span class="c1"># Filter base period for threshold calculation</span>
        <span class="n">base_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">base_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">df_tx_base</span> <span class="o">=</span> <span class="n">df_tx</span><span class="p">[</span>
            <span class="n">df_tx</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">base_start</span><span class="p">,</span> <span class="n">base_stop</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Calculate TX thresholds</span>
        <span class="n">tx_thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_temperature_thresholds</span><span class="p">(</span>
            <span class="n">df_tx_base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="p">,</span> <span class="s2">&quot;TX&quot;</span>
        <span class="p">)</span>
        
        <span class="c1"># Identify hot days based on TX</span>
        <span class="n">df_hot_days</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_hot_days</span><span class="p">(</span><span class="n">df_tx</span><span class="p">,</span> <span class="n">tx_thresholds</span><span class="p">,</span> <span class="s2">&quot;TX&quot;</span><span class="p">)</span>
        
        <span class="c1"># If TN data provided for compound heat waves</span>
        <span class="k">if</span> <span class="n">df_cdt_tn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_both_tx_tn</span><span class="p">:</span>
            <span class="n">df_tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_cdt</span><span class="p">(</span><span class="n">df_cdt_tn</span><span class="p">)</span>
            <span class="n">df_tn_base</span> <span class="o">=</span> <span class="n">df_tn</span><span class="p">[</span>
                <span class="n">df_tn</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">base_start</span><span class="p">,</span> <span class="n">base_stop</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># Calculate TN thresholds</span>
            <span class="n">tn_thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_temperature_thresholds</span><span class="p">(</span>
                <span class="n">df_tn_base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span> <span class="ow">or</span> <span class="mi">90</span><span class="p">,</span> <span class="s2">&quot;TN&quot;</span>
            <span class="p">)</span>
            
            <span class="c1"># Identify hot nights</span>
            <span class="n">df_hot_nights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_hot_days</span><span class="p">(</span><span class="n">df_tn</span><span class="p">,</span> <span class="n">tn_thresholds</span><span class="p">,</span> <span class="s2">&quot;TN&quot;</span><span class="p">)</span>
            
            <span class="c1"># Merge TX and TN data</span>
            <span class="n">df_merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">df_hot_days</span><span class="p">,</span>
                <span class="n">df_hot_nights</span><span class="p">[[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;IS_HOT&quot;</span><span class="p">]],</span>
                <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION&quot;</span><span class="p">],</span>
                <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_TX&quot;</span><span class="p">,</span> <span class="s2">&quot;_TN&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Compound condition: both TX and TN exceed thresholds</span>
            <span class="n">df_merged</span><span class="p">[</span><span class="s2">&quot;IS_HOT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">df_merged</span><span class="p">[</span><span class="s2">&quot;IS_HOT_TX&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> 
                <span class="p">(</span><span class="n">df_merged</span><span class="p">[</span><span class="s2">&quot;IS_HOT_TN&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="n">df_hot_days</span> <span class="o">=</span> <span class="n">df_merged</span>
        
        <span class="c1"># Apply seasonal filter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">df_hot_days</span> <span class="o">=</span> <span class="n">df_hot_days</span><span class="p">[</span>
                <span class="n">df_hot_days</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">)</span>
            <span class="p">]</span>
        
        <span class="c1"># Detect heat waves</span>
        <span class="n">heat_waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_heat_waves</span><span class="p">(</span><span class="n">df_hot_days</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">heat_waves</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="c1"># Return empty result with proper structure</span>
            <span class="n">empty_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_to_cdt</span><span class="p">(</span><span class="n">empty_df</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        
        <span class="c1"># Calculate requested metric</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;WSDI&quot;</span><span class="p">:</span>
            <span class="c1"># WSDI: Annual total number of hot days in heat waves</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">heat_waves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="n">WSDI</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;DURATION&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HWF&quot;</span><span class="p">:</span>
            <span class="c1"># HWF: Annual count of heat wave events</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">heat_waves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="n">HWF</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;DURATION&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HWDI&quot;</span><span class="p">:</span>
            <span class="c1"># HWDI: Annual maximum duration of heat waves</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">heat_waves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="n">HWDI</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;DURATION&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown metric: </span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">. Use &#39;WSDI&#39;, &#39;HWF&#39;, or &#39;HWDI&#39;.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Fill NaN for years without heat waves</span>
        <span class="n">result</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_to_cdt</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices.compute_xarray">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices.compute_xarray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_xarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ds_tx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">ds_tn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;WSDI&quot;</span><span class="p">,</span>
        <span class="c1"># chunk_size: Optional[Dict[str, int]] = None,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nb_cores</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute heat wave indices for xarray data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds_tx : xr.Dataset or xr.DataArray</span>
<span class="sd">            Daily maximum temperature</span>
<span class="sd">        ds_tn : xr.Dataset or xr.DataArray, optional</span>
<span class="sd">            Daily minimum temperature (for compound heat waves)</span>
<span class="sd">        metric : str</span>
<span class="sd">            Heat wave metric to compute</span>
<span class="sd">        chunk_size : dict, optional</span>
<span class="sd">            Chunk sizes for parallel processing</span>
<span class="sd">        parallel : bool</span>
<span class="sd">            Whether to use Dask for parallel processing</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            Heat wave index values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract TX DataArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds_tx</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">da_tx</span> <span class="o">=</span> <span class="n">ds_tx</span><span class="p">[</span><span class="s2">&quot;TMAX&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;TMAX&quot;</span> <span class="ow">in</span> <span class="n">ds_tx</span> <span class="k">else</span> <span class="n">ds_tx</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ds_tx</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_tx</span> <span class="o">=</span> <span class="n">ds_tx</span>
        
        <span class="c1"># Standardize dimension names</span>
        <span class="n">da_tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_dims</span><span class="p">(</span><span class="n">da_tx</span><span class="p">)</span>
        
        <span class="c1"># Apply seasonal mask if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
            <span class="n">da_tx</span> <span class="o">=</span> <span class="n">da_tx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da_tx</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># # Handle chunking for Dask</span>
        <span class="c1"># if parallel and hasattr(da_tx.data, &#39;chunks&#39;):</span>
        <span class="c1">#     if chunk_size is None:</span>
        <span class="c1">#         chunk_size = {&#39;lat&#39;: 50, &#39;lon&#39;: 50}</span>
        <span class="c1">#     da_tx = da_tx.chunk({&#39;time&#39;: -1, **chunk_size})</span>

        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span><span class="c1"># and hasattr(da.data, &#39;chunks&#39;):</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da_tx</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">da_tx</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">nb_cores</span><span class="p">))}</span>
            <span class="n">da_tx</span> <span class="o">=</span> <span class="n">da_tx</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">chunk_size</span><span class="p">})</span>
        
        <span class="c1"># Select base period</span>
        <span class="n">da_tx_base</span> <span class="o">=</span> <span class="n">da_tx</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="p">)</span>
        
        <span class="c1"># Calculate TX thresholds using 5-day centered window</span>
        <span class="n">windowed_tx</span> <span class="o">=</span> <span class="n">da_tx_base</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">)</span>
        <span class="n">tx_thresholds</span> <span class="o">=</span> <span class="n">windowed_tx</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;time.dayofyear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;window&quot;</span><span class="p">],</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        
        <span class="c1"># Handle leap days</span>
        <span class="n">doy</span> <span class="o">=</span> <span class="n">da_tx</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofyear</span>
        <span class="n">doy_fixed</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">doy</span> <span class="o">==</span> <span class="mi">366</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="n">doy</span><span class="p">)</span>
        
        <span class="c1"># Map thresholds to all time steps</span>
        <span class="n">full_tx_thresholds</span> <span class="o">=</span> <span class="n">tx_thresholds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">dayofyear</span><span class="o">=</span><span class="n">doy_fixed</span><span class="p">)</span>
        <span class="n">full_tx_thresholds</span> <span class="o">=</span> <span class="n">full_tx_thresholds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;dayofyear&quot;</span><span class="p">)</span>
        <span class="n">full_tx_thresholds</span> <span class="o">=</span> <span class="n">full_tx_thresholds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">da_tx</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        
        <span class="c1"># Identify hot days based on TX</span>
        <span class="n">is_hot_tx</span> <span class="o">=</span> <span class="p">(</span><span class="n">da_tx</span> <span class="o">&gt;</span> <span class="n">full_tx_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">is_hot_tx</span> <span class="o">=</span> <span class="n">is_hot_tx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da_tx</span><span class="o">.</span><span class="n">notnull</span><span class="p">())</span>
        
        <span class="c1"># If TN data provided for compound heat waves</span>
        <span class="k">if</span> <span class="n">ds_tn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_both_tx_tn</span><span class="p">:</span>
            <span class="c1"># Extract TN DataArray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds_tn</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                <span class="n">da_tn</span> <span class="o">=</span> <span class="n">ds_tn</span><span class="p">[</span><span class="s2">&quot;TMIN&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;TMIN&quot;</span> <span class="ow">in</span> <span class="n">ds_tn</span> <span class="k">else</span> <span class="n">ds_tn</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ds_tn</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">da_tn</span> <span class="o">=</span> <span class="n">ds_tn</span>
            
            <span class="n">da_tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_dims</span><span class="p">(</span><span class="n">da_tn</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">:</span>
                <span class="n">da_tn</span> <span class="o">=</span> <span class="n">da_tn</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da_tn</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">season</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Calculate TN thresholds</span>
            <span class="n">da_tn_base</span> <span class="o">=</span> <span class="n">da_tn</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="p">)</span>
            <span class="n">windowed_tn</span> <span class="o">=</span> <span class="n">da_tn_base</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">)</span>
            <span class="n">tn_thresholds</span> <span class="o">=</span> <span class="n">windowed_tn</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;time.dayofyear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span> <span class="ow">or</span> <span class="mi">90</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;window&quot;</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            
            <span class="c1"># Map TN thresholds</span>
            <span class="n">full_tn_thresholds</span> <span class="o">=</span> <span class="n">tn_thresholds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">dayofyear</span><span class="o">=</span><span class="n">doy_fixed</span><span class="p">)</span>
            <span class="n">full_tn_thresholds</span> <span class="o">=</span> <span class="n">full_tn_thresholds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;dayofyear&quot;</span><span class="p">)</span>
            <span class="n">full_tn_thresholds</span> <span class="o">=</span> <span class="n">full_tn_thresholds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">da_tn</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            
            <span class="c1"># Identify hot nights</span>
            <span class="n">is_hot_tn</span> <span class="o">=</span> <span class="p">(</span><span class="n">da_tn</span> <span class="o">&gt;</span> <span class="n">full_tn_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">is_hot_tn</span> <span class="o">=</span> <span class="n">is_hot_tn</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da_tn</span><span class="o">.</span><span class="n">notnull</span><span class="p">())</span>
            
            <span class="c1"># Compound condition: both TX and TN exceed thresholds</span>
            <span class="n">is_hot</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_hot_tx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">is_hot_tn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_hot</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_hot_tx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Apply minimum consecutive days filter</span>
        <span class="c1"># Use rolling sum to identify periods with at least min_consecutive_days</span>
        <span class="n">rolling_hot</span> <span class="o">=</span> <span class="n">is_hot</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">heat_wave_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">rolling_hot</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="p">)</span>
        
        <span class="c1"># Extend mask to include all days in heat waves</span>
        <span class="c1"># For each heat wave start, mark the next min_consecutive_days-1 days</span>
        <span class="n">heat_wave_extended</span> <span class="o">=</span> <span class="n">heat_wave_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Calculate metric</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;WSDI&quot;</span><span class="p">:</span>
            <span class="c1"># WSDI: Annual count of hot days in heat waves</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">heat_wave_extended</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;YS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HWF&quot;</span><span class="p">:</span>
            <span class="c1"># HWF: Annual count of heat wave events</span>
            <span class="c1"># Find start of each heat wave</span>
            <span class="n">heat_wave_start</span> <span class="o">=</span> <span class="n">heat_wave_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">heat_wave_mask</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">heat_wave_start</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;YS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HWDI&quot;</span><span class="p">:</span>
            <span class="c1"># HWDI: Annual maximum duration of heat waves</span>
            <span class="c1"># This is more complex - need to find longest consecutive sequence</span>
            <span class="c1"># We&#39;ll use apply_ufunc for this</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">max_consecutive</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Find maximum consecutive True values in 1D array.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="mi">0</span>
                
                <span class="n">arr_bool</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arr_bool</span><span class="p">):</span>
                    <span class="k">return</span> <span class="mi">0</span>
                
                <span class="c1"># Find runs of True</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="kc">False</span><span class="p">],</span> <span class="n">arr_bool</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">])))</span>
                <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">durations</span> <span class="o">=</span> <span class="n">ends</span> <span class="o">-</span> <span class="n">starts</span>
                
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            
            <span class="c1"># Apply to each year</span>
            <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">heat_wave_extended</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
                <span class="n">year_data</span> <span class="o">=</span> <span class="n">heat_wave_extended</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">heat_wave_extended</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span>
                <span class="p">)</span>
                
                <span class="c1"># Apply function to each grid cell</span>
                <span class="n">max_durations</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                    <span class="n">max_consecutive</span><span class="p">,</span>
                    <span class="n">year_data</span><span class="p">,</span>
                    <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;time&#39;</span><span class="p">]],</span>
                    <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[]],</span>
                    <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="s1">&#39;allowed&#39;</span>
                <span class="p">)</span>
                
                <span class="c1"># Add year coordinate</span>
                <span class="n">max_durations</span> <span class="o">=</span> <span class="n">max_durations</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">-01-01&quot;</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_durations</span><span class="p">)</span>
            
            <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown metric: </span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">. Use &#39;WSDI&#39;, &#39;HWF&#39;, or &#39;HWDI&#39;.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set metadata</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;Y&quot;</span><span class="p">})</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._standardize_dims">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._standardize_dims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standardize dimension names.&quot;&quot;&quot;</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Identify time dimension</span>
        <span class="n">time_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">time_candidates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dim_map</span><span class="p">[</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
                <span class="k">break</span>
        
        <span class="c1"># Identify spatial dimensions</span>
        <span class="n">spatial_pairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">([</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="s1">&#39;lat&#39;</span><span class="p">),</span>
            <span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">std_name</span> <span class="ow">in</span> <span class="n">spatial_pairs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">dim_map</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_name</span>
                    <span class="k">break</span>
        
        <span class="c1"># Rename dimensions if needed</span>
        <span class="k">if</span> <span class="n">dim_map</span><span class="p">:</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DataArray must have &#39;time&#39; dimension. Found: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">da</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._get_metadata">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._get_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metadata dictionary for the index.&quot;&quot;&quot;</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1"> Heat Wave Index&#39;</span><span class="p">,</span>
            <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;days&#39;</span> <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;WSDI&#39;</span> <span class="k">else</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
            <span class="s1">&#39;base_period&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_period</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;tx_percentile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="p">,</span>
            <span class="s1">&#39;tn_percentile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tn_percentile</span><span class="p">,</span>
            <span class="s1">&#39;min_consecutive_days&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="p">,</span>
            <span class="s1">&#39;max_break_days&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_break_days</span><span class="p">,</span>
            <span class="s1">&#39;season&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">season</span> <span class="k">else</span> <span class="s1">&#39;all months&#39;</span><span class="p">,</span>
            <span class="s1">&#39;require_both_tx_tn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_both_tx_tn</span><span class="p">,</span>
            <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;ETCCDI Climate Change Indices (2009)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;definition&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_definition</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">metadata</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._get_index_definition">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._get_index_definition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_index_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get definition string for the index.&quot;&quot;&quot;</span>
        <span class="n">definitions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;WSDI&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual count of days with at least </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;consecutive days when TX &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="si">}</span><span class="s1">th percentile&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HWF&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual number of heat wave events (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_consecutive_days</span><span class="si">}</span><span class="s1"> &#39;</span>
                   <span class="sa">f</span><span class="s1">&#39;consecutive days when TX &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HWDI&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Annual maximum length of heat waves (consecutive days &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;when TX &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_percentile</span><span class="si">}</span><span class="s1">th percentile)&#39;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_both_tx_tn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">definitions</span><span class="p">:</span>
                <span class="n">definitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">definitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span> <span class="s1">&#39;TX and TN&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;Custom heat wave index&#39;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="WAS_HeatWaveIndices._format_to_cdt">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.WAS_HeatWaveIndices._format_to_cdt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_to_cdt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert to CDT format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="c1"># Return empty CDT structure</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">])</span>
        
        <span class="c1"># Pivot to wide format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;STATION&quot;</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">metric</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;STATION&quot;</span><span class="p">)[[</span><span class="s2">&quot;LAT&quot;</span><span class="p">,</span> <span class="s2">&quot;LON&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Exclude YEAR column</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span>
        
        <span class="c1"># Create metadata rows</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LAT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;LON&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> 
                              <span class="n">columns</span><span class="o">=</span><span class="n">pivot</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        
        <span class="c1"># Rename YEAR column to ID for CDT format</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lat_row</span> <span class="o">=</span> <span class="n">lat_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        <span class="n">lon_row</span> <span class="o">=</span> <span class="n">lon_row</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">})</span>
        
        <span class="c1"># Combine all rows</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lat_row</span><span class="p">,</span> <span class="n">lon_row</span><span class="p">,</span> <span class="n">pivot</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span></div>
</div>



<span class="c1"># Convenience class for standard ETCCDI WSDI</span>
<div class="viewcode-block" id="ETCCDIHeatWaveIndices">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDIHeatWaveIndices">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ETCCDIHeatWaveIndices</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory for creating standard ETCCDI heat wave indices.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ETCCDIHeatWaveIndices.wsdi">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDIHeatWaveIndices.wsdi">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wsdi</span><span class="p">(</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">tx_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">min_consecutive_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for WSDI (Warm Spell Duration Index).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">tx_percentile</span><span class="o">=</span><span class="n">tx_percentile</span><span class="p">,</span>
            <span class="n">min_consecutive_days</span><span class="o">=</span><span class="n">min_consecutive_days</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="ETCCDIHeatWaveIndices.heat_wave_frequency">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDIHeatWaveIndices.heat_wave_frequency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">heat_wave_frequency</span><span class="p">(</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">tx_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">min_consecutive_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for Heat Wave Frequency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">tx_percentile</span><span class="o">=</span><span class="n">tx_percentile</span><span class="p">,</span>
            <span class="n">min_consecutive_days</span><span class="o">=</span><span class="n">min_consecutive_days</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="ETCCDIHeatWaveIndices.compound_heat_wave">
<a class="viewcode-back" href="../../api.html#wass2s.was_compute_predictand.ETCCDIHeatWaveIndices.compound_heat_wave">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compound_heat_wave</span><span class="p">(</span>
        <span class="n">base_period</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span>
        <span class="n">tx_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">tn_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">min_consecutive_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">season</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create calculator for compound heat waves (both TX and TN).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WAS_HeatWaveIndices</span><span class="p">(</span>
            <span class="n">base_period</span><span class="o">=</span><span class="n">base_period</span><span class="p">,</span>
            <span class="n">tx_percentile</span><span class="o">=</span><span class="n">tx_percentile</span><span class="p">,</span>
            <span class="n">tn_percentile</span><span class="o">=</span><span class="n">tn_percentile</span><span class="p">,</span>
            <span class="n">min_consecutive_days</span><span class="o">=</span><span class="n">min_consecutive_days</span><span class="p">,</span>
            <span class="n">season</span><span class="o">=</span><span class="n">season</span><span class="p">,</span>
            <span class="n">require_both_tx_tn</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>
</div>


        
<span class="c1"># #### look this part again -----</span>
<span class="c1"># class WAS_compute_HWSDI:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the Heat Wave Severity Duration Index (HWSDI),</span>
<span class="c1">#     including calculating TXin90 (90th percentile of daily max temperature) </span>
<span class="c1">#     and annual counts of heatwave days with at least 6 consecutive hot days.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def calculate_TXin90(temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Calculate the daily 90th percentile temperature (TXin90) centered on a 5-day window</span>
<span class="c1">#         for each calendar day based on the base period.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period (default is &#39;1990&#39;).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             TXin90 for each day of the year.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Filter the data for the base period</span>
<span class="c1">#         base_period = temperature_data.sel(T=slice(base_period_start, base_period_end))</span>

<span class="c1">#         # Group by day of the year (DOY) and calculate the 90th percentile over a centered 5-day window</span>
<span class="c1">#         TXin90 = base_period.rolling(T=5, center=True).construct(&quot;window_dim&quot;).groupby(&quot;T.dayofyear&quot;).reduce(</span>
<span class="c1">#             np.nanpercentile, q=90, dim=&quot;window_dim&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return TXin90</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def _count_consecutive_days(data, min_days=6):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count sequences of at least `min_days` consecutive True values in a boolean array.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         data : np.ndarray</span>
<span class="c1">#             Boolean array.</span>
<span class="c1">#         min_days : int</span>
<span class="c1">#             Minimum number of consecutive True values to count as a sequence.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         int</span>
<span class="c1">#             Count of sequences with at least `min_days` consecutive True values.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         count = 0</span>
<span class="c1">#         current_streak = 0</span>

<span class="c1">#         for value in data:</span>
<span class="c1">#             if value:</span>
<span class="c1">#                 current_streak += 1</span>
<span class="c1">#                 if current_streak == min_days:</span>
<span class="c1">#                     count += 1</span>
<span class="c1">#             else:</span>
<span class="c1">#                 current_streak = 0</span>

<span class="c1">#         return count</span>

<span class="c1">#     def count_hot_days(self, temperature_data, TXin90):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count the number of days per year with at least 6 consecutive days</span>
<span class="c1">#         where daily maximum temperature is above the 90th percentile.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         TXin90 : xarray.DataArray</span>
<span class="c1">#             90th percentile temperature for each day of the year.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             Annual count of hot days.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Ensure TXin90 covers each day of the year by broadcasting</span>
<span class="c1">#         TXin90_full = TXin90.sel(dayofyear=temperature_data.time.dt.dayofyear)</span>

<span class="c1">#         # Find days where daily temperature exceeds the 90th percentile</span>
<span class="c1">#         hot_days = temperature_data &gt; TXin90_full</span>

<span class="c1">#         # Convert to integer (1 for hot day, 0 otherwise) and group by year</span>
<span class="c1">#         hot_days_per_year = hot_days.astype(int).groupby(&quot;time.year&quot;)</span>

<span class="c1">#         # Count sequences of at least 6 consecutive hot days within each year</span>
<span class="c1">#         annual_hot_days_count = xr.DataArray(</span>
<span class="c1">#             np.array([</span>
<span class="c1">#                 self._count_consecutive_days(year_data.values, min_days=6) </span>
<span class="c1">#                 for year_data in hot_days_per_year</span>
<span class="c1">#             ]),</span>
<span class="c1">#             coords={&quot;year&quot;: list(hot_days_per_year.groups.keys())},</span>
<span class="c1">#             dims=&quot;year&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return annual_hot_days_count</span>

<span class="c1">#     def compute(self, temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;, nb_cores=4):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute the Heat Wave Severity Duration Index (HWSDI) for each pixel</span>
<span class="c1">#         in a given daily temperature DataArray.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature data, coords = (T, Y, X).</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period for TXin90 calculation (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period for TXin90 calculation (default is &#39;1990&#39;).</span>
<span class="c1">#         nb_cores : int, optional</span>
<span class="c1">#             Number of parallel processes to use (default is 4).</span>
        
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             HWSDI computed for each pixel.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Rename &#39;T&#39; dimension to &#39;time&#39; so dayofyear and year grouping work as expected</span>
<span class="c1">#         temperature_data = temperature_data.rename({&#39;T&#39;: &#39;time&#39;})</span>

<span class="c1">#         # Compute TXin90</span>
<span class="c1">#         TXin90 = self.calculate_TXin90(temperature_data, base_period_start, base_period_end)</span>

<span class="c1">#         # Prepare chunk sizes</span>
<span class="c1">#         chunksize_x = int(np.round(len(temperature_data.get_index(&quot;X&quot;)) / nb_cores))</span>
<span class="c1">#         chunksize_y = int(np.round(len(temperature_data.get_index(&quot;Y&quot;)) / nb_cores))</span>

<span class="c1">#         # Set up parallel processing</span>
<span class="c1">#         client = Client(n_workers=nb_cores, threads_per_worker=1)</span>

<span class="c1">#         # Apply function</span>
<span class="c1">#         result = xr.apply_ufunc(</span>
<span class="c1">#             self.count_hot_days,</span>
<span class="c1">#             temperature_data.chunk({&#39;Y&#39;: chunksize_y, &#39;X&#39;: chunksize_x}),</span>
<span class="c1">#             TXin90,</span>
<span class="c1">#             input_core_dims=[(&#39;T&#39;,), (&#39;dayofyear&#39;,)],</span>
<span class="c1">#             vectorize=True,</span>
<span class="c1">#             output_core_dims=[(&#39;year&#39;,)],</span>
<span class="c1">#             dask=&#39;parallelized&#39;,</span>
<span class="c1">#             output_dtypes=[&#39;float&#39;]</span>
<span class="c1">#         )</span>

<span class="c1">#         result_ = result.compute()</span>
<span class="c1">#         client.close()</span>

<span class="c1">#         return result_</span>



<span class="c1"># class WAS_compute_HWSDI_monthly:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the Heat Wave Severity Duration Index (HWSDI) **monthly**,</span>
<span class="c1">#     calculating TXin90 (90th percentile of daily max temperature) and counting heatwave days</span>
<span class="c1">#     for each month with at least 6 consecutive hot days.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def calculate_TXin90(temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Calculate the monthly 90th percentile temperature (TXin90) centered on a 5-day window</span>
<span class="c1">#         for each calendar day based on the base period.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period (default is &#39;1990&#39;).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             TXin90 for each month of the year.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Filter data for the base period</span>
<span class="c1">#         base_period = temperature_data.sel(time=slice(base_period_start, base_period_end))</span>

<span class="c1">#         # Compute the rolling 90th percentile temperature for each **month**</span>
<span class="c1">#         TXin90 = base_period.rolling(time=5, center=True).construct(&quot;window_dim&quot;).groupby(&quot;time.month&quot;).reduce(</span>
<span class="c1">#             np.nanpercentile, q=90, dim=&quot;window_dim&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return TXin90</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def _count_consecutive_days(data, min_days=6):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count sequences of at least `min_days` consecutive True values in a boolean array.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         data : np.ndarray</span>
<span class="c1">#             Boolean array.</span>
<span class="c1">#         min_days : int</span>
<span class="c1">#             Minimum number of consecutive True values to count as a sequence.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         int</span>
<span class="c1">#             Count of sequences with at least `min_days` consecutive True values.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         count = 0</span>
<span class="c1">#         current_streak = 0</span>

<span class="c1">#         for value in data:</span>
<span class="c1">#             if value:</span>
<span class="c1">#                 current_streak += 1</span>
<span class="c1">#                 if current_streak == min_days:</span>
<span class="c1">#                     count += 1</span>
<span class="c1">#             else:</span>
<span class="c1">#                 current_streak = 0</span>

<span class="c1">#         return count</span>

<span class="c1">#     def count_hot_days(self, temperature_data, TXin90):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count the number of days per month with at least 6 consecutive days</span>
<span class="c1">#         where daily maximum temperature is above the 90th percentile.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         TXin90 : xarray.DataArray</span>
<span class="c1">#             90th percentile temperature for each month.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             Monthly count of hot days.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Ensure TXin90 covers each month by broadcasting</span>
<span class="c1">#         TXin90_full = TXin90.sel(month=temperature_data.time.dt.month)</span>

<span class="c1">#         # Find days where daily temperature exceeds the 90th percentile</span>
<span class="c1">#         hot_days = temperature_data &gt; TXin90_full</span>

<span class="c1">#         # Convert to integer (1 for hot day, 0 otherwise) and group by month</span>
<span class="c1">#         hot_days_per_month = hot_days.astype(int).groupby(&quot;time.month&quot;)</span>

<span class="c1">#         # Count sequences of at least 6 consecutive hot days within each month</span>
<span class="c1">#         monthly_hot_days_count = xr.DataArray(</span>
<span class="c1">#             np.array([</span>
<span class="c1">#                 self._count_consecutive_days(month_data.values, min_days=6) </span>
<span class="c1">#                 for month_data in hot_days_per_month</span>
<span class="c1">#             ]),</span>
<span class="c1">#             coords={&quot;month&quot;: list(hot_days_per_month.groups.keys())},</span>
<span class="c1">#             dims=&quot;month&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return monthly_hot_days_count</span>

<span class="c1">#     def compute(self, temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;, nb_cores=4):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute the Monthly Heat Wave Severity Duration Index (HWSDI)</span>
<span class="c1">#         for each pixel in a given daily temperature DataArray.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature data, coords = (T, Y, X).</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period for TXin90 calculation (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period for TXin90 calculation (default is &#39;1990&#39;).</span>
<span class="c1">#         nb_cores : int, optional</span>
<span class="c1">#             Number of parallel processes to use (default is 4).</span>
        
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             HWSDI computed for each pixel per month.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Rename &#39;T&#39; dimension to &#39;time&#39; so month grouping works as expected</span>
<span class="c1">#         temperature_data = temperature_data.rename({&#39;T&#39;: &#39;time&#39;})</span>

<span class="c1">#         # Compute TXin90</span>
<span class="c1">#         TXin90 = self.calculate_TXin90(temperature_data, base_period_start, base_period_end)</span>

<span class="c1">#         # Prepare chunk sizes for parallel processing</span>
<span class="c1">#         chunksize_x = int(np.round(len(temperature_data.get_index(&quot;X&quot;)) / nb_cores))</span>
<span class="c1">#         chunksize_y = int(np.round(len(temperature_data.get_index(&quot;Y&quot;)) / nb_cores))</span>

<span class="c1">#         # Set up parallel processing</span>
<span class="c1">#         client = Client(n_workers=nb_cores, threads_per_worker=1)</span>

<span class="c1">#         # Apply function in parallel</span>
<span class="c1">#         result = xr.apply_ufunc(</span>
<span class="c1">#             self.count_hot_days,</span>
<span class="c1">#             temperature_data.chunk({&#39;Y&#39;: chunksize_y, &#39;X&#39;: chunksize_x}),</span>
<span class="c1">#             TXin90,</span>
<span class="c1">#             input_core_dims=[(&#39;time&#39;,), (&#39;month&#39;,)],</span>
<span class="c1">#             vectorize=True,</span>
<span class="c1">#             output_core_dims=[(&#39;month&#39;,)],</span>
<span class="c1">#             dask=&#39;parallelized&#39;,</span>
<span class="c1">#             output_dtypes=[&#39;float&#39;]</span>
<span class="c1">#         )</span>

<span class="c1">#         result_ = result.compute()</span>
<span class="c1">#         client.close()</span>

<span class="c1">#         return result_</span>


<span class="c1"># class WAS_compute_HWSDI_Seasonal:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A class to compute the Heat Wave Severity Duration Index (HWSDI) for a given season.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def calculate_TXin90(temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;, season=[6, 7, 8]):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Calculate the daily 90th percentile temperature (TXin90) for each calendar day </span>
<span class="c1">#         based on the base period, but only considering the specified season.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period (default is &#39;1990&#39;).</span>
<span class="c1">#         season : list, optional</span>
<span class="c1">#             List of months to include in the calculation (default is [6, 7, 8] for JJA).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             TXin90 for each day of the selected season.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Filter the data for the base period and only the selected season</span>
<span class="c1">#         base_period = temperature_data.sel(time=slice(base_period_start, base_period_end))</span>
<span class="c1">#         seasonal_data = base_period.where(base_period.time.dt.month.isin(season), drop=True)</span>

<span class="c1">#         # Group by day of the year (DOY) and calculate the 90th percentile</span>
<span class="c1">#         TXin90 = seasonal_data.rolling(time=5, center=True).construct(&quot;window_dim&quot;).groupby(&quot;time.dayofyear&quot;).reduce(</span>
<span class="c1">#             np.nanpercentile, q=90, dim=&quot;window_dim&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return TXin90</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def _count_consecutive_days(data, min_days=5):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count sequences of at least `min_days` consecutive True values in a boolean array.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         data : np.ndarray</span>
<span class="c1">#             Boolean array.</span>
<span class="c1">#         min_days : int</span>
<span class="c1">#             Minimum number of consecutive True values to count as a sequence.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         int</span>
<span class="c1">#             Count of sequences with at least `min_days` consecutive True values.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         count = 0</span>
<span class="c1">#         current_streak = 0</span>

<span class="c1">#         for value in data:</span>
<span class="c1">#             if value:</span>
<span class="c1">#                 current_streak += 1</span>
<span class="c1">#                 if current_streak == min_days:</span>
<span class="c1">#                     count += 1</span>
<span class="c1">#             else:</span>
<span class="c1">#                 current_streak = 0</span>

<span class="c1">#         return count</span>

<span class="c1">#     def count_hot_days(self, temperature_data, TXin90):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Count the number of days per season with at least 6 consecutive days</span>
<span class="c1">#         where daily maximum temperature is above the 90th percentile.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature with time dimension.</span>
<span class="c1">#         TXin90 : xarray.DataArray</span>
<span class="c1">#             90th percentile temperature for each day of the year.</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             Seasonal count of hot days.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Ensure TXin90 covers each day of the season by broadcasting</span>
<span class="c1">#         TXin90_full = TXin90.sel(dayofyear=temperature_data.time.dt.dayofyear)</span>

<span class="c1">#         # Find days where daily temperature exceeds the 90th percentile</span>
<span class="c1">#         hot_days = temperature_data &gt; TXin90_full</span>

<span class="c1">#         # Convert to integer (1 for hot day, 0 otherwise) and group by year</span>
<span class="c1">#         hot_days_per_year = hot_days.astype(int).groupby(&quot;time.year&quot;)</span>

<span class="c1">#         # Count sequences of at least 6 consecutive hot days within each season</span>
<span class="c1">#         seasonal_hot_days_count = xr.DataArray(</span>
<span class="c1">#             np.array([</span>
<span class="c1">#                 self._count_consecutive_days(year_data.values, min_days=6) </span>
<span class="c1">#                 for year_data in hot_days_per_year</span>
<span class="c1">#             ]),</span>
<span class="c1">#             coords={&quot;year&quot;: list(hot_days_per_year.groups.keys())},</span>
<span class="c1">#             dims=&quot;year&quot;</span>
<span class="c1">#         )</span>

<span class="c1">#         return seasonal_hot_days_count</span>

<span class="c1">#     def compute(self, temperature_data, base_period_start=&#39;1961&#39;, base_period_end=&#39;1990&#39;, nb_cores=4, season=[6, 7, 8]):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Compute the HWSDI for each pixel in a given daily temperature DataArray for a specific season.</span>

<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         temperature_data : xarray.DataArray</span>
<span class="c1">#             Daily maximum temperature data, coords = (T, Y, X).</span>
<span class="c1">#         base_period_start : str, optional</span>
<span class="c1">#             Start year of the base period for TXin90 calculation (default is &#39;1961&#39;).</span>
<span class="c1">#         base_period_end : str, optional</span>
<span class="c1">#             End year of the base period for TXin90 calculation (default is &#39;1990&#39;).</span>
<span class="c1">#         nb_cores : int, optional</span>
<span class="c1">#             Number of parallel processes to use (default is 4).</span>
<span class="c1">#         season : list, optional</span>
<span class="c1">#             List of months to include in the calculation (default is [6, 7, 8] for JJA).</span>

<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         xarray.DataArray</span>
<span class="c1">#             HWSDI computed for each pixel for the given season.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # Rename &#39;T&#39; dimension to &#39;time&#39; so dayofyear and year grouping work as expected</span>
<span class="c1">#         temperature_data = temperature_data.rename({&#39;T&#39;: &#39;time&#39;})</span>

<span class="c1">#         # Filter data to only include selected season</span>
<span class="c1">#         seasonal_temperature_data = temperature_data.where(temperature_data.time.dt.month.isin(season), drop=True)</span>

<span class="c1">#         # Compute TXin90 based on the season</span>
<span class="c1">#         TXin90 = self.calculate_TXin90(seasonal_temperature_data, base_period_start, base_period_end, season)</span>

<span class="c1">#         # Prepare chunk sizes</span>
<span class="c1">#         chunksize_x = int(np.round(len(temperature_data.get_index(&quot;X&quot;)) / nb_cores))</span>
<span class="c1">#         chunksize_y = int(np.round(len(temperature_data.get_index(&quot;Y&quot;)) / nb_cores))</span>

<span class="c1">#         # Set up parallel processing</span>
<span class="c1">#         client = Client(n_workers=nb_cores, threads_per_worker=1)</span>

<span class="c1">#         # Apply function</span>
<span class="c1">#         result = xr.apply_ufunc(</span>
<span class="c1">#             self.count_hot_days,</span>
<span class="c1">#             seasonal_temperature_data.chunk({&#39;Y&#39;: chunksize_y, &#39;X&#39;: chunksize_x}),</span>
<span class="c1">#             TXin90,</span>
<span class="c1">#             input_core_dims=[(&#39;time&#39;,), (&#39;dayofyear&#39;,)],</span>
<span class="c1">#             vectorize=True,</span>
<span class="c1">#             output_core_dims=[(&#39;year&#39;,)],</span>
<span class="c1">#             dask=&#39;parallelized&#39;,</span>
<span class="c1">#             output_dtypes=[&#39;float&#39;]</span>
<span class="c1">#         )</span>

<span class="c1">#         result_ = result.compute()</span>
<span class="c1">#         client.close()</span>

<span class="c1">#         return result_</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>