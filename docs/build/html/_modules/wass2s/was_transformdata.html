

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wass2s.was_transformdata &mdash; wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel. 0.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1e28cc32"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wass2s: A python-based tool for seasonal climate forecast in West Africa and the Sahel.</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wass2s.was_transformdata</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wass2s.was_transformdata</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">WAS_TransformData: Skewness Analysis and Transformation for Geospatial Time-Series</span>

<span class="sd">This module provides the `WAS_TransformData` class to analyze skewness, apply</span>
<span class="sd">transformations, fit distributions, and visualize geospatial time-series data with</span>
<span class="sd">dimensions (T, Y, X) representing time, latitude, and longitude, respectively.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">skew</span><span class="p">,</span> <span class="n">boxcox</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">PowerTransformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fitter</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cartopy.crs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ccrs</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cartopy.feature</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cfeature</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">ListedColormap</span><span class="p">,</span> <span class="n">BoundaryNorm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_dist</span><span class="p">,</span> <span class="n">weibull_min</span><span class="p">,</span> <span class="n">t</span> <span class="k">as</span> <span class="n">t_dist</span><span class="p">,</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">nbinom</span><span class="p">,)</span>

<div class="viewcode-block" id="inv_boxcox">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.inv_boxcox">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inv_boxcox</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse Box-Cox transformation for SciPy 1.11.3 compatibility.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Transformed data.</span>
<span class="sd">    lmbda : float</span>
<span class="sd">        Box-Cox lambda parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Original data before Box-Cox transformation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Implements the inverse of the Box-Cox transformation manually</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lmbda</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">lmbda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">)</span></div>


<div class="viewcode-block" id="WAS_TransformData">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WAS_TransformData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manage skewness analysis, data transformation, distribution fitting, and visualization</span>
<span class="sd">    for geospatial time-series data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : xarray.DataArray</span>
<span class="sd">        Input data with dimensions (T, Y, X) for time, latitude, and longitude.</span>
<span class="sd">    distribution_map : dict, optional</span>
<span class="sd">        Mapping of distribution names to numeric codes. Default is:</span>
<span class="sd">        {&#39;norm&#39;: 1, &#39;lognorm&#39;: 2, &#39;expon&#39;: 3, &#39;gamma&#39;: 4, &#39;weibull_min&#39;: 5}.</span>
<span class="sd">    n_clusters : int, optional</span>
<span class="sd">        Number of clusters for KMeans in distribution fitting. Default is 5.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    data : xarray.DataArray</span>
<span class="sd">        Input geospatial time-series data.</span>
<span class="sd">    distribution_map : dict</span>
<span class="sd">        Mapping of distribution names to codes.</span>
<span class="sd">    n_clusters : int</span>
<span class="sd">        Number of clusters for KMeans.</span>
<span class="sd">    transformed_data : xarray.DataArray or None</span>
<span class="sd">        Transformed data after applying transformations.</span>
<span class="sd">    transform_methods : xarray.DataArray or None</span>
<span class="sd">        Transformation methods applied per grid cell.</span>
<span class="sd">    transform_params : xarray.DataArray or None</span>
<span class="sd">        Parameters for parametric transformations (e.g., Box-Cox lambda).</span>
<span class="sd">    skewness_ds : xarray.Dataset or None</span>
<span class="sd">        Skewness analysis results.</span>
<span class="sd">    handle_ds : xarray.Dataset or None</span>
<span class="sd">        Skewness handling recommendations.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    detect_skewness()</span>
<span class="sd">        Compute and classify skewness per grid cell.</span>
<span class="sd">    handle_skewness()</span>
<span class="sd">        Recommend transformations based on skewness.</span>
<span class="sd">    apply_transformation(method=None)</span>
<span class="sd">        Apply transformations to data.</span>
<span class="sd">    inverse_transform()</span>
<span class="sd">        Reverse transformations to recover original data.</span>
<span class="sd">    find_best_distribution_grid(use_transformed=False)</span>
<span class="sd">        Fit distributions to data using KMeans clustering.</span>
<span class="sd">    plot_best_fit_map(data_array, map_dict, output_file=&#39;map.png&#39;, ...)</span>
<span class="sd">        Plot categorical map of distributions or skewness classes.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `data` is not an xarray.DataArray or lacks required dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WAS_TransformData.__init__">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">distribution_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must be an xarray.DataArray&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dim</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must have dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span> <span class="o">=</span> <span class="n">distribution_map</span> <span class="ow">or</span> <span class="p">{</span>
            <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;lognorm&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;expon&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s1">&#39;weibull_min&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;t_dist&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
            <span class="s2">&quot;poisson&quot;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span>
            <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span><span class="mi">8</span>
        
            
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_methods</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_ds</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WAS_TransformData._safe_boxcox">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData._safe_boxcox">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_safe_boxcox</span><span class="p">(</span><span class="n">arr1d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply Box-Cox transformation while handling NaNs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr1d : array_like</span>
<span class="sd">            1D array of data to transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transformed : ndarray</span>
<span class="sd">            Transformed array, same shape as input, with NaNs preserved.</span>
<span class="sd">        lmbda : float</span>
<span class="sd">            Box-Cox lambda parameter.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If fewer than 2 non-NaN values or if data is not strictly positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">arr1d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr1d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least two non-NaN values for Box-Cox&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">arr1d</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Box-Cox requires strictly positive data&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">lmbda</span> <span class="o">=</span> <span class="n">boxcox</span><span class="p">(</span><span class="n">arr1d</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">lmbda</span></div>


<div class="viewcode-block" id="WAS_TransformData.detect_skewness">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.detect_skewness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">detect_skewness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and classify skewness for each grid cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        skewness_ds : xarray.Dataset</span>
<span class="sd">            Dataset with variables &#39;skewness&#39; (float) and &#39;skewness_class&#39; (str).</span>
<span class="sd">            Skewness classes: &#39;symmetric&#39;, &#39;moderate_positive&#39;, &#39;moderate_negative&#39;,</span>
<span class="sd">            &#39;high_positive&#39;, &#39;high_negative&#39;, &#39;invalid&#39;.</span>
<span class="sd">        summary : dict</span>
<span class="sd">            Dictionary with &#39;class_counts&#39; mapping skewness classes to grid cell counts.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Skewness is computed using `scipy.stats.skew` with `nan_policy=&#39;omit&#39;`.</span>
<span class="sd">        Classification thresholds:</span>
<span class="sd">        - Symmetric: -0.5 ≤ skewness ≤ 0.5</span>
<span class="sd">        - Moderate positive: 0.5 &lt; skewness ≤ 1</span>
<span class="sd">        - Moderate negative: -1 ≤ skewness &lt; -0.5</span>
<span class="sd">        - High positive: skewness &gt; 1</span>
<span class="sd">        - High negative: skewness &lt; -1</span>
<span class="sd">        - Invalid: insufficient data (&lt; 3 non-NaN values).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_compute</span><span class="p">(</span><span class="n">precip</span><span class="p">):</span>
            <span class="n">precip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">precip</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">precip</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;invalid&#39;</span>
            <span class="n">sk</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">precip</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sk</span><span class="p">):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;invalid&#39;</span>
            <span class="k">elif</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">&lt;=</span> <span class="n">sk</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;symmetric&#39;</span>
            <span class="k">elif</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">sk</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;moderate_positive&#39;</span>
            <span class="k">elif</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">sk</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;moderate_negative&#39;</span>
            <span class="k">elif</span> <span class="n">sk</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;high_positive&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="s1">&#39;high_negative&#39;</span>
            <span class="k">return</span> <span class="n">sk</span><span class="p">,</span> <span class="bp">cls</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_compute</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[],</span> <span class="p">[]],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s1">&#39;skewness&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                <span class="s1">&#39;skewness_class&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span><span class="p">[</span><span class="s1">&#39;skewness_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;class_counts&#39;</span><span class="p">:</span> <span class="n">counts</span><span class="p">}</span></div>


<div class="viewcode-block" id="WAS_TransformData.handle_skewness">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.handle_skewness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">handle_skewness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recommend transformations based on skewness and data properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        handle_ds : xarray.Dataset</span>
<span class="sd">            Dataset with variables &#39;skewness&#39;, &#39;skewness_class&#39;, and &#39;recommended_methods&#39;</span>
<span class="sd">            (semicolon-separated string of transformation methods).</span>
<span class="sd">        summary : dict</span>
<span class="sd">            Dictionary with &#39;general_recommendations&#39; mapping skewness classes to advice.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `detect_skewness` has not been called.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Recommendations consider data properties (e.g., zeros, negatives) and skewness class.</span>
<span class="sd">        Example methods: &#39;log&#39;, &#39;square_root&#39;, &#39;box_cox&#39;, &#39;yeo_johnson&#39;, &#39;clipping&#39;, &#39;binning&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Run detect_skewness() first&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_suggest</span><span class="p">(</span><span class="n">precip</span><span class="p">,</span> <span class="n">sk_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sk_class</span> <span class="o">==</span> <span class="s1">&#39;invalid&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;none&#39;</span>
            <span class="n">precip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">precip</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">precip</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">precip</span><span class="p">)]</span>
            <span class="n">all_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">valid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">has_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">sk_class</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;moderate_positive&#39;</span><span class="p">,</span> <span class="s1">&#39;high_positive&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">all_pos</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_zeros</span><span class="p">:</span>
                    <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;square_root&#39;</span><span class="p">,</span> <span class="s1">&#39;box_cox&#39;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">all_pos</span><span class="p">:</span>
                    <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;square_root&#39;</span><span class="p">,</span> <span class="s1">&#39;box_cox&#39;</span><span class="p">]</span>
                <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;yeo_johnson&#39;</span><span class="p">,</span> <span class="s1">&#39;clipping&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">sk_class</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;moderate_negative&#39;</span><span class="p">,</span> <span class="s1">&#39;high_negative&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">all_pos</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_zeros</span><span class="p">:</span>
                    <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;reflect_log&#39;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">all_pos</span><span class="p">:</span>
                    <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;reflect_square_root&#39;</span><span class="p">]</span>
                <span class="n">methods</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;reflect_yeo_johnson&#39;</span><span class="p">,</span> <span class="s1">&#39;clipping&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">methods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">methods</span><span class="p">)</span>

        <span class="n">recommended</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_suggest</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span><span class="p">[</span><span class="s1">&#39;skewness_class&#39;</span><span class="p">],</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">],</span> <span class="p">[]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[]],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">handle_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s1">&#39;skewness&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span><span class="p">[</span><span class="s1">&#39;skewness&#39;</span><span class="p">],</span>
                <span class="s1">&#39;skewness_class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">skewness_ds</span><span class="p">[</span><span class="s1">&#39;skewness_class&#39;</span><span class="p">],</span>
                <span class="s1">&#39;recommended_methods&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="n">recommended</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">general</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="s1">&#39;No transformation needed.&#39;</span><span class="p">,</span>
            <span class="s1">&#39;moderate_positive&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="s1">&#39;Consider square root or Yeo-Johnson; log or Box-Cox if no zeros; &#39;</span>
                <span class="s1">&#39;clip or bin outliers.&#39;</span>
            <span class="p">),</span>
            <span class="s1">&#39;high_positive&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="s1">&#39;Strongly consider log (no zeros), Box-Cox (positive), or Yeo-Johnson; &#39;</span>
                <span class="s1">&#39;clip or bin extremes.&#39;</span>
            <span class="p">),</span>
            <span class="s1">&#39;moderate_negative&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="s1">&#39;Reflect and apply square root or Yeo-Johnson; clip or bin outliers.&#39;</span>
            <span class="p">),</span>
            <span class="s1">&#39;high_negative&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="s1">&#39;Reflect and apply log (no zeros), Box-Cox, or Yeo-Johnson; &#39;</span>
                <span class="s1">&#39;clip or bin extremes.&#39;</span>
            <span class="p">),</span>
            <span class="s1">&#39;invalid&#39;</span><span class="p">:</span> <span class="s1">&#39;Insufficient valid data for skewness calculation.&#39;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_ds</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;general_recommendations&#39;</span><span class="p">:</span> <span class="n">general</span><span class="p">}</span></div>


<div class="viewcode-block" id="WAS_TransformData.apply_transformation">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.apply_transformation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply transformations to reduce skewness in the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or xarray.DataArray, optional</span>
<span class="sd">            Transformation method to apply. Options:</span>
<span class="sd">            - None: Use first recommended method per grid cell from `handle_skewness`.</span>
<span class="sd">            - str: Apply the same method to all grid cells (e.g., &#39;log&#39;, &#39;box_cox&#39;).</span>
<span class="sd">            - xarray.DataArray: Specify method per grid cell with dimensions (Y, X).</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transformed_data : xarray.DataArray</span>
<span class="sd">            Transformed data with same shape as input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `method` is None and `handle_skewness` has not been called.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Supported methods: &#39;log&#39;, &#39;square_root&#39;, &#39;box_cox&#39;, &#39;yeo_johnson&#39;,</span>
<span class="sd">        &#39;reflect_log&#39;, &#39;reflect_square_root&#39;, &#39;reflect_yeo_johnson&#39;, &#39;clipping&#39;, &#39;binning&#39;.</span>
<span class="sd">        Transformations are skipped for invalid data or methods, with warnings printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Run handle_skewness() first or specify `method`&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">extract_first_method</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="s1">&#39;none&#39;</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">extract_first_method</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">handle_ds</span><span class="p">[</span><span class="s1">&#39;recommended_methods&#39;</span><span class="p">],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_methods</span> <span class="o">=</span> <span class="n">method</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]),</span> <span class="n">method</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_methods</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">])):</span>
                    <span class="k">continue</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cell</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skip log at Y=</span><span class="si">{</span><span class="n">iy</span><span class="si">}</span><span class="s2">, X=</span><span class="si">{</span><span class="n">ix</span><span class="si">}</span><span class="s2">: non-positive values&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;square_root&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skip square_root at Y=</span><span class="si">{</span><span class="n">iy</span><span class="si">}</span><span class="s2">, X=</span><span class="si">{</span><span class="n">ix</span><span class="si">}</span><span class="s2">: negative values&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;box_cox&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">transformed</span><span class="p">,</span> <span class="n">lam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_boxcox</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lambda&#39;</span><span class="p">:</span> <span class="n">lam</span><span class="p">}</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skip Box-Cox at Y=</span><span class="si">{</span><span class="n">iy</span><span class="si">}</span><span class="s2">, X=</span><span class="si">{</span><span class="n">ix</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;yeo_johnson&#39;</span><span class="p">:</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">PowerTransformer</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;yeo-johnson&#39;</span><span class="p">)</span>
                    <span class="n">transformed</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;transformer&#39;</span><span class="p">:</span> <span class="n">pt</span><span class="p">}</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;reflect_log&#39;</span><span class="p">:</span>
                    <span class="n">cell_ref</span> <span class="o">=</span> <span class="o">-</span><span class="n">cell</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cell_ref</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skip reflect_log at Y=</span><span class="si">{</span><span class="n">iy</span><span class="si">}</span><span class="s2">, X=</span><span class="si">{</span><span class="n">ix</span><span class="si">}</span><span class="s2">: non-positive values&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cell_ref</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;reflect_square_root&#39;</span><span class="p">:</span>
                    <span class="n">cell_ref</span> <span class="o">=</span> <span class="o">-</span><span class="n">cell</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cell_ref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skip reflect_square_root at Y=</span><span class="si">{</span><span class="n">iy</span><span class="si">}</span><span class="s2">, X=</span><span class="si">{</span><span class="n">ix</span><span class="si">}</span><span class="s2">: negative values&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cell_ref</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;reflect_yeo_johnson&#39;</span><span class="p">:</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">PowerTransformer</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;yeo-johnson&#39;</span><span class="p">)</span>
                    <span class="n">transformed</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">((</span><span class="o">-</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;transformer&#39;</span><span class="p">:</span> <span class="n">pt</span><span class="p">}</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;clipping&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="c1">#print(f&quot;Warning: unknown method &#39;{m}&#39; at Y={iy}, X={ix}&quot;)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span></div>


<div class="viewcode-block" id="WAS_TransformData.inverse_transform">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.inverse_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse transformations to recover original data scale.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverse_data : xarray.DataArray</span>
<span class="sd">            Data in original scale with same shape as input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no transformation has been applied or required parameters are missing.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Non-invertible methods (&#39;clipping&#39;, &#39;binning&#39;) return unchanged data with a warning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_methods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No transformation applied. Run apply_transformation() first&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_inv</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">method</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">vec</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;clipping&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not invertible&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">vec</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;square_root&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vec</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;box_cox&#39;</span><span class="p">:</span>
                <span class="n">lam</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lambda&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing lambda for Box-Cox inversion&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">inv_boxcox</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;yeo_johnson&#39;</span><span class="p">:</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transformer&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">tr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing transformer for Yeo-Johnson inversion&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tr</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;reflect_&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reflect_log&#39;</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reflect_square_root&#39;</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># reflect_yeo_johnson</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transformer&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">tr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing transformer for reflect_yeo_johnson&quot;</span><span class="p">)</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">temp</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_inv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_methods</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]],</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dask</span><span class="o">=</span><span class="s1">&#39;parallelized&#39;</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">)</span></div>





<div class="viewcode-block" id="WAS_TransformData.fit_best_distribution_grid_onlycluster">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.fit_best_distribution_grid_onlycluster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_best_distribution_grid_onlycluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit best distributions by homogeneous zones (clusters) and map to each grid cell.</span>
<span class="sd">    </span>
<span class="sd">        Clustering:</span>
<span class="sd">            - Done on simple distributional features per grid cell (mean, std over T).</span>
<span class="sd">            - Produces n_clusters homogeneous zones.</span>
<span class="sd">    </span>
<span class="sd">        For each cluster:</span>
<span class="sd">            - Pool all time series values from its grid cells.</span>
<span class="sd">            - For each candidate distribution in self.distribution_map:</span>
<span class="sd">                * Fit parameters by MLE (SciPy).</span>
<span class="sd">                * Compute AIC = 2k - 2 logL on that cluster sample.</span>
<span class="sd">            - Select distribution with minimum AIC.</span>
<span class="sd">            - Assign its (code, shape, loc, scale) to all grid cells in that cluster.</span>
<span class="sd">    </span>
<span class="sd">        Supports (if present in distribution_map):</span>
<span class="sd">            - &#39;norm&#39;        -&gt; code 1</span>
<span class="sd">            - &#39;lognorm&#39;     -&gt; code 2</span>
<span class="sd">            - &#39;expon&#39;       -&gt; code 3</span>
<span class="sd">            - &#39;gamma&#39;       -&gt; code 4</span>
<span class="sd">            - &#39;weibull_min&#39; -&gt; code 5</span>
<span class="sd">            - &#39;t&#39;           -&gt; code 6</span>
<span class="sd">            - &#39;poisson&#39;     -&gt; code 7</span>
<span class="sd">            - &#39;nbinom&#39;      -&gt; code 8</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_transformed : bool, optional</span>
<span class="sd">            If True, use self.transformed_data; otherwise use original self.data.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_code  : xarray.DataArray, shape (Y, X)</span>
<span class="sd">            Code of best distribution per grid cell.</span>
<span class="sd">        best_shape : xarray.DataArray, shape (Y, X)</span>
<span class="sd">            Primary shape param (e.g., &#39;a&#39; in gamma, &#39;mu&#39; in poisson, &#39;n&#39; in nbinom).</span>
<span class="sd">        best_loc   : xarray.DataArray, shape (Y, X)</span>
<span class="sd">            Location parameter.</span>
<span class="sd">        best_scale : xarray.DataArray, shape (Y, X)</span>
<span class="sd">            Scale parameter (e.g., &#39;p&#39; in nbinom).</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Continuous (precip-like):</span>
<span class="sd">            * &#39;lognorm&#39;, &#39;gamma&#39;, &#39;weibull_min&#39;, &#39;expon&#39; are fitted on non-negative values with loc=0.</span>
<span class="sd">        - Continuous (unbounded):</span>
<span class="sd">            * &#39;norm&#39; and &#39;t&#39; are fitted on all finite values (no non-negativity constraint).</span>
<span class="sd">        - Discrete (counts):</span>
<span class="sd">            * &#39;poisson&#39;, &#39;nbinom&#39; are fitted on non-negative INTEGER values with loc=0.</span>
<span class="sd">        - Requires enough valid data per cluster; if not, affected cells get NaNs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">norm</span><span class="p">,</span>
            <span class="n">lognorm</span><span class="p">,</span>
            <span class="n">expon</span><span class="p">,</span>
            <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_dist</span><span class="p">,</span>
            <span class="n">weibull_min</span><span class="p">,</span>
            <span class="n">t</span> <span class="k">as</span> <span class="n">t_dist</span><span class="p">,</span>
            <span class="n">poisson</span><span class="p">,</span>
            <span class="n">nbinom</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="c1"># -------- Select working data --------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="k">if</span> <span class="p">(</span><span class="n">use_transformed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Internal error: data must be an xarray.DataArray&quot;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dim</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must have dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)&quot;</span><span class="p">)</span>
    
        <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">}</span>
    
        <span class="c1"># Map distribution names to scipy objects</span>
        <span class="n">dist_objs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;lognorm&quot;</span><span class="p">:</span> <span class="n">lognorm</span><span class="p">,</span>
            <span class="s2">&quot;expon&quot;</span><span class="p">:</span> <span class="n">expon</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma_dist</span><span class="p">,</span>
            <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span> <span class="n">weibull_min</span><span class="p">,</span>
            <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="n">t_dist</span><span class="p">,</span>
            <span class="s2">&quot;poisson&quot;</span><span class="p">:</span> <span class="n">poisson</span><span class="p">,</span>
            <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span> <span class="n">nbinom</span><span class="p">,</span>
        <span class="p">}</span>
    
        <span class="c1"># -------- 1. Build clustering features (mean, std) per grid cell --------</span>
        <span class="n">mean_da</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">std_da</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
        <span class="n">feat_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">mean_da</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">std_da</span><span class="p">})</span>
        <span class="n">feat_df</span> <span class="o">=</span> <span class="n">feat_ds</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>  <span class="c1"># index: (Y, X), cols: mean, std</span>
    
        <span class="k">if</span> <span class="n">feat_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="c1"># Not enough valid cells for the requested clusters</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: insufficient valid grid cells for clustering; returning NaNs.&quot;</span><span class="p">)</span>
            <span class="n">nan_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nan_arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
                <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nan_arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
                <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nan_arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
                <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nan_arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
            <span class="p">)</span>
    
        <span class="c1"># Run KMeans on [mean, std]</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">feat_df</span><span class="p">[[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">feat_df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    
        <span class="c1"># -------- 2. Map cluster labels back to full (Y, X) grid --------</span>
        <span class="n">cluster_da</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">feat_df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">Y</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Note: Removed the .where(valid_mask) as it was redundant with .dropna()</span>
    
        <span class="c1"># -------- 3. For each cluster, fit best distribution on pooled values --------</span>
        <span class="n">best_params_by_cluster</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># cl -&gt; (code, shape, loc, scale)</span>
    
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_da</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">unique_clusters</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)]</span>
    
        <span class="k">for</span> <span class="n">cl_val</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cl_val</span><span class="p">)</span>
    
            <span class="c1"># Extract pooled values for this cluster</span>
            <span class="n">mask_cl</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">cl</span><span class="p">)</span>
            <span class="n">cl_vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_cl</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">cl_vals</span> <span class="o">=</span> <span class="n">cl_vals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cl_vals</span><span class="p">)]</span>
    
            <span class="k">if</span> <span class="n">cl_vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="n">best_params_by_cluster</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
    
            <span class="c1"># Create specific subsets for different distribution families</span>
            <span class="n">cl_vals_pos</span> <span class="o">=</span> <span class="n">cl_vals</span><span class="p">[</span><span class="n">cl_vals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cl_vals_int</span> <span class="o">=</span> <span class="n">cl_vals_pos</span><span class="p">[(</span><span class="n">cl_vals_pos</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cl_vals_pos</span><span class="p">))]</span>
    
            <span class="n">best_aic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">best_choice</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Will store (code, (shape, loc, scale))</span>
    
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dist_objs</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_objs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">is_discrete</span> <span class="o">=</span> <span class="kc">False</span>
                
                <span class="c1"># Choose appropriate sample for this distribution</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">cl_vals_int</span>
                    <span class="n">is_discrete</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">cl_vals_pos</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># &#39;norm&#39; and &#39;t&#39; work on full sample</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">cl_vals</span>
    
                <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># --- Fit parameters and get k (number of estimated params) ---</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                        <span class="c1"># Manual MLE fit for Poisson (mu=mean), loc is fixed</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Only mu is estimated</span>
                    
                    <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">,</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">):</span>
                        <span class="c1"># Fit with fixed location at 0</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># loc is fixed, not estimated</span>
                    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># &#39;norm&#39; and &#39;t&#39; (and any others with free loc)</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="c1"># All params (loc, scale, shapes) are estimated</span>
    
                    <span class="c1"># --- Calculate Log-Likelihood ---</span>
                    <span class="k">if</span> <span class="n">is_discrete</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1"># nbinom</span>
                            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span>
    
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logL</span><span class="p">):</span>
                        <span class="k">continue</span>
                        
                    <span class="n">aic</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">logL</span>
    
                    <span class="k">if</span> <span class="n">aic</span> <span class="o">&lt;</span> <span class="n">best_aic</span><span class="p">:</span>
                        <span class="n">best_aic</span> <span class="o">=</span> <span class="n">aic</span>
                        <span class="c1"># --- Standardize parameters to (shape, loc, scale) ---</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                            <span class="c1"># params = (mu, loc)</span>
                            <span class="n">best_choice</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span>
                            <span class="c1"># params = (n, p, loc)</span>
                            <span class="c1"># Store as (shape=n, loc=loc, scale=p)</span>
                            <span class="n">best_choice</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;norm&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                            <span class="c1"># params = (loc, scale)</span>
                            <span class="c1"># Store as (shape=nan, loc=loc, scale=scale)</span>
                            <span class="n">best_choice</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span> 
                            <span class="c1"># &#39;t&#39;, &#39;gamma&#39;, &#39;lognorm&#39;, &#39;weibull_min&#39;</span>
                            <span class="c1"># params = (shape, loc, scale)</span>
                            <span class="n">best_choice</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">continue</span> <span class="c1"># Fitting failed</span>
    
            <span class="k">if</span> <span class="n">best_choice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_params_by_cluster</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">code</span><span class="p">,</span> <span class="n">params_tuple</span> <span class="o">=</span> <span class="n">best_choice</span>
                <span class="c1"># params_tuple is already (shape, loc, scale)</span>
                <span class="n">best_params_by_cluster</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">params_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
        <span class="c1"># -------- 4. Broadcast cluster-level params to each grid cell (Vectorized) --------</span>
        
        <span class="c1"># Create empty arrays with the correct coordinates and NaNs</span>
        <span class="n">best_code_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
        <span class="n">best_shape_da</span> <span class="o">=</span> <span class="n">best_code_da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">best_loc_da</span> <span class="o">=</span> <span class="n">best_code_da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">best_code_da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
        <span class="c1"># Loop over the few clusters, not the millions of pixels</span>
        <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">best_params_by_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># Leave these cells as NaN</span>
    
            <span class="c1"># Create a boolean mask for all cells belonging to this cluster</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">cl</span><span class="p">)</span>
            
            <span class="c1"># Unpack the parameters</span>
            <span class="n">code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span>
            
            <span class="c1"># &quot;Paint&quot; the values onto the grid where the mask is True</span>
            <span class="n">best_code_da</span> <span class="o">=</span> <span class="n">best_code_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
            <span class="n">best_shape_da</span> <span class="o">=</span> <span class="n">best_shape_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
            <span class="n">best_loc_da</span> <span class="o">=</span> <span class="n">best_loc_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">best_scale_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span> <span class="n">cluster_da</span></div>

        
   
    
<div class="viewcode-block" id="WAS_TransformData.fit_best_distribution_grid_onlygrid">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.fit_best_distribution_grid_onlygrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_best_distribution_grid_onlygrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit candidate distributions per grid cell and select best by AIC.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_transformed : bool, optional</span>
<span class="sd">            If True, use self.transformed_data; otherwise use original data.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_code  : xarray.DataArray  (Y, X)</span>
<span class="sd">            Code of best distribution per grid (per self.distribution_map).</span>
<span class="sd">        best_shape : xarray.DataArray  (Y, X)</span>
<span class="sd">        best_loc   : xarray.DataArray  (Y, X)</span>
<span class="sd">        best_scale : xarray.DataArray  (Y, X)</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Fits are done independently per grid cell (no clustering).</span>
<span class="sd">        - For precip-like variables:</span>
<span class="sd">            * &#39;lognorm&#39;, &#39;gamma&#39;, &#39;weibull_min&#39;, &#39;expon&#39; are fitted on positive values with loc=0.</span>
<span class="sd">            * &#39;norm&#39; and &#39;t&#39; are fitted on all finite values.</span>
<span class="sd">        - AIC = 2k - 2 ln(L) is used for model selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">gamma</span> <span class="k">as</span> <span class="n">gamma_dist</span><span class="p">,</span> <span class="n">weibull_min</span><span class="p">,</span> <span class="n">t</span> <span class="k">as</span> <span class="n">t_dist</span>
    
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="k">if</span> <span class="p">(</span><span class="n">use_transformed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must be an xarray.DataArray&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dim</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must have dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)&quot;</span><span class="p">)</span>
    
        <span class="c1"># Map distribution names to scipy.stats objects</span>
        <span class="n">dist_objs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;lognorm&quot;</span><span class="p">:</span> <span class="n">lognorm</span><span class="p">,</span>
            <span class="s2">&quot;expon&quot;</span><span class="p">:</span> <span class="n">expon</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma_dist</span><span class="p">,</span>
            <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span> <span class="n">weibull_min</span><span class="p">,</span>
            <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="n">t_dist</span><span class="p">,</span>
        <span class="p">}</span>
    
        <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
    
        <span class="n">best_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">best_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">best_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">best_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vals</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="c1"># Positive subset for positive-support distributions</span>
                <span class="n">vals_pos</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    
                <span class="n">best_aic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">best</span> <span class="o">=</span> <span class="kc">None</span>
    
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dist_objs</span><span class="p">:</span>
                        <span class="k">continue</span>
    
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_objs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    
                    <span class="c1"># Choose sample depending on support</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                        <span class="n">sample</span> <span class="o">=</span> <span class="n">vals_pos</span>
                        <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;norm&#39;, &#39;t&#39;, or any other real-line distribution</span>
                        <span class="n">sample</span> <span class="o">=</span> <span class="n">vals</span>
                        <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                            <span class="k">continue</span>
    
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Fit parameters</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                            <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># norm, t: free loc/scale; t has (df, loc, scale)</span>
                            <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
    
                        <span class="c1"># Compute AIC</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                        <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span>
                        <span class="n">aic</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">logL</span>
    
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">aic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">aic</span> <span class="o">&lt;</span> <span class="n">best_aic</span><span class="p">:</span>
                            <span class="n">best_aic</span> <span class="o">=</span> <span class="n">aic</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="c1"># Skip distributions that fail to fit at this grid</span>
                        <span class="k">continue</span>
    
                <span class="k">if</span> <span class="n">best</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">code</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">best</span>
                    <span class="c1"># Normalise to (shape, loc, scale)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># e.g. norm, expon when not forcing shape</span>
                        <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># e.g. gamma (k, loc, scale), t (df, loc, scale), etc.</span>
                        <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
                    <span class="n">best_code</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
                    <span class="n">best_shape</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
                    <span class="n">best_loc</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
                    <span class="n">best_scale</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
    
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">}</span>
        <span class="n">best_code_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">best_code</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
        <span class="n">best_shape_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">best_shape</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
        <span class="n">best_loc_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">best_loc</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
        <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">best_scale</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">))</span>
    
        <span class="k">return</span> <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span></div>



<div class="viewcode-block" id="WAS_TransformData.fit_best_distribution_grid_two_options">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.fit_best_distribution_grid_two_options">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_best_distribution_grid_two_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit best distributions either by:</span>
<span class="sd">          - homogeneous zones (mode=&#39;cluster&#39;), or</span>
<span class="sd">          - per grid cell (mode=&#39;grid&#39;).</span>
<span class="sd">    </span>
<span class="sd">        Uses AIC for model selection and supports:</span>
<span class="sd">          &#39;norm&#39;, &#39;lognorm&#39;, &#39;expon&#39;, &#39;gamma&#39;, &#39;weibull_min&#39;, &#39;t&#39;, &#39;poisson&#39;, &#39;nbinom&#39;</span>
<span class="sd">        (if present in self.distribution_map).</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_transformed : bool, optional</span>
<span class="sd">            If True, use self.transformed_data, else self.data.</span>
<span class="sd">        mode : {&#39;cluster&#39;, &#39;grid&#39;}, optional</span>
<span class="sd">            &#39;cluster&#39; : KMeans on (mean,std) → one distribution per cluster.</span>
<span class="sd">            &#39;grid&#39;    : independent fit at each (Y,X) via xr.apply_ufunc.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_code  : xarray.DataArray (Y, X)</span>
<span class="sd">        best_shape : xarray.DataArray (Y, X)</span>
<span class="sd">        best_loc   : xarray.DataArray (Y, X)</span>
<span class="sd">        best_scale : xarray.DataArray (Y, X)</span>
<span class="sd">        cluster_da : xarray.DataArray (Y, X)</span>
<span class="sd">            Cluster labels for mode=&#39;cluster&#39;; all-NaN for mode=&#39;grid&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Select data</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="k">if</span> <span class="p">(</span><span class="n">use_transformed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must be an xarray.DataArray&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dim</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`data` must have dimensions (&#39;T&#39;, &#39;Y&#39;, &#39;X&#39;)&quot;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;distribution_map&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`self.distribution_map` must be a dict of {name: code}&quot;</span><span class="p">)</span>
    
        <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">}</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Map distribution names in distribution_map to scipy.stats objects</span>
        <span class="c1"># (allow aliases like &#39;t_dist&#39; → t)</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">name_to_dist</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;lognorm&quot;</span><span class="p">:</span> <span class="n">lognorm</span><span class="p">,</span>
            <span class="s2">&quot;expon&quot;</span><span class="p">:</span> <span class="n">expon</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma_dist</span><span class="p">,</span>
            <span class="s2">&quot;weibull_min&quot;</span><span class="p">:</span> <span class="n">weibull_min</span><span class="p">,</span>
            <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="n">t_dist</span><span class="p">,</span>
            <span class="s2">&quot;t_dist&quot;</span><span class="p">:</span> <span class="n">t_dist</span><span class="p">,</span>
            <span class="s2">&quot;poisson&quot;</span><span class="p">:</span> <span class="n">poisson</span><span class="p">,</span>
            <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span> <span class="n">nbinom</span><span class="p">,</span>
        <span class="p">}</span>
    
        <span class="c1"># Helper: filter only supported distributions</span>
        <span class="n">dist_candidates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">name_to_dist</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">code</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_to_dist</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dist_candidates</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid distributions found in distribution_map&quot;</span><span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Core 1D fitter using AIC</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_fit_best</span><span class="p">(</span><span class="n">sample_1d</span><span class="p">,</span> <span class="n">min_n</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Fit all candidate distributions to a 1D sample; return (code, shape, loc, scale)</span>
<span class="sd">            for the best by AIC. If no fit, return NaNs.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sample_1d</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vals</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_n</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
            <span class="n">vals_pos</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">vals_int</span> <span class="o">=</span> <span class="n">vals_pos</span><span class="p">[(</span><span class="n">vals_pos</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vals_pos</span><span class="p">))]</span>
    
            <span class="n">best_aic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">best</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (code, (shape, loc, scale))</span>
    
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dist_candidates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">is_discrete</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">)</span>
    
                <span class="c1"># respect support</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">vals_int</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">vals_pos</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># norm, t, etc.</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">vals</span>
    
                <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_n</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># ---- fit parameters ----</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                        <span class="c1"># MLE: mu = mean, loc=0</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">mu</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># only mu</span>
    
                    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span>
                        <span class="c1"># fit (n, p, loc=0)</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="c1"># (n, p, loc) with loc fixed</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
                    <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lognorm&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;weibull_min&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                        <span class="c1"># positive-support, loc=0 fixed</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># norm, t: all params free</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    
                    <span class="c1"># ---- log-likelihood ----</span>
                    <span class="k">if</span> <span class="n">is_discrete</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                            <span class="n">mu</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">params</span>
                            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># nbinom</span>
                            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span>
    
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logL</span><span class="p">):</span>
                        <span class="k">continue</span>
    
                    <span class="n">aic</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">logL</span>
                    <span class="k">if</span> <span class="n">aic</span> <span class="o">&lt;</span> <span class="n">best_aic</span><span class="p">:</span>
                        <span class="n">best_aic</span> <span class="o">=</span> <span class="n">aic</span>
    
                        <span class="c1"># normalize to (shape, loc, scale)</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                            <span class="n">mu</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">params</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nbinom&quot;</span><span class="p">:</span>
                            <span class="n">n_</span><span class="p">,</span> <span class="n">p_</span><span class="p">,</span> <span class="n">loc_</span> <span class="o">=</span> <span class="n">params</span>  <span class="c1"># (n, p, loc)</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">n_</span><span class="p">,</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">p_</span><span class="p">))</span>  <span class="c1"># shape=n, loc=loc, scale=p</span>
                        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;norm&quot;</span><span class="p">,</span> <span class="s2">&quot;expon&quot;</span><span class="p">):</span>
                            <span class="n">loc_</span><span class="p">,</span> <span class="n">scale_</span> <span class="o">=</span> <span class="n">params</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">scale_</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># (shape, loc, scale): t, gamma, lognorm, weibull_min</span>
                            <span class="n">shape_</span><span class="p">,</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">scale_</span> <span class="o">=</span> <span class="n">params</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">shape_</span><span class="p">,</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">scale_</span><span class="p">))</span>
    
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">continue</span>
    
            <span class="k">if</span> <span class="n">best</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
            <span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span> <span class="o">=</span> <span class="n">best</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Mode: per-grid using xr.apply_ufunc</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;grid&quot;</span><span class="p">:</span>
            <span class="n">min_n_grid</span> <span class="o">=</span> <span class="mi">15</span>
    
            <span class="k">def</span><span class="w"> </span><span class="nf">_fit_best_grid</span><span class="p">(</span><span class="n">cell_ts</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_fit_best</span><span class="p">(</span><span class="n">cell_ts</span><span class="p">,</span> <span class="n">min_n_grid</span><span class="p">)</span>
    
            <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_fit_best_grid</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;T&quot;</span><span class="p">]],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="p">)</span>
    
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">best_code_da</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">best_code_da</span><span class="p">,</span>
                <span class="n">best_shape_da</span><span class="p">,</span>
                <span class="n">best_loc_da</span><span class="p">,</span>
                <span class="n">best_scale_da</span><span class="p">,</span>
                <span class="n">cluster_da</span><span class="p">,</span>
            <span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Mode: homogeneous zones via KMeans clustering</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For mode=&#39;cluster&#39;, self.n_clusters must be defined.&quot;</span><span class="p">)</span>
    
            <span class="n">min_n_cluster</span> <span class="o">=</span> <span class="mi">30</span>

            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">data_dropna</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
            <span class="n">variable_column</span> <span class="o">=</span> <span class="n">data_dropna</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">data_dropna</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
               <span class="n">data_dropna</span><span class="p">[[</span><span class="n">variable_column</span><span class="p">]]</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert cluster assignments back into an xarray structure</span>
            <span class="n">df_unique</span> <span class="o">=</span> <span class="n">data_dropna</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">df_unique</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">Cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
                   
            <span class="c1"># Align cluster array with the predictand array</span>
            <span class="n">xarray1</span><span class="p">,</span> <span class="n">xarray2</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Cluster</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            
            <span class="c1"># Identify unique cluster labels</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xarray2</span><span class="p">)</span>
            <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">clusters</span><span class="p">)]</span>
            <span class="n">cluster_da</span> <span class="o">=</span> <span class="n">xarray2</span>
    
    
            <span class="c1"># 4) Fit best distribution for each cluster (pooled values)</span>
            <span class="n">best_params_by_cluster</span> <span class="o">=</span> <span class="p">{}</span>
    
            <span class="k">for</span> <span class="n">cl_val</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
                <span class="n">cl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cl_val</span><span class="p">)</span>
                <span class="n">mask_cl</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da</span> <span class="o">==</span> <span class="n">cl</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]})</span>
                <span class="n">cl_vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_cl</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">cl_vals</span> <span class="o">=</span> <span class="n">cl_vals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cl_vals</span><span class="p">)]</span>
                <span class="n">code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">_fit_best</span><span class="p">(</span><span class="n">cl_vals</span><span class="p">,</span> <span class="n">min_n_cluster</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
                    <span class="n">best_params_by_cluster</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">best_params_by_cluster</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
    
            <span class="c1"># 5) Broadcast cluster-level params back to (Y,X) using xarray masks</span>
            <span class="n">cluster_da_</span> <span class="o">=</span> <span class="n">cluster_da</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
            <span class="n">best_code_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">best_shape_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">best_loc_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cluster_da_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
            <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">best_params_by_cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">code</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span>
                <span class="n">mask_cl_</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_da_</span> <span class="o">==</span> <span class="n">cl</span><span class="p">)</span>
    
                <span class="n">best_code_da</span> <span class="o">=</span> <span class="n">best_code_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask_cl_</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
                <span class="n">best_shape_da</span> <span class="o">=</span> <span class="n">best_shape_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask_cl_</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                <span class="n">best_loc_da</span> <span class="o">=</span> <span class="n">best_loc_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask_cl_</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="n">best_scale_da</span> <span class="o">=</span> <span class="n">best_scale_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask_cl_</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
    
            <span class="k">return</span> <span class="n">best_code_da</span><span class="p">,</span> <span class="n">best_shape_da</span><span class="p">,</span> <span class="n">best_loc_da</span><span class="p">,</span> <span class="n">best_scale_da</span><span class="p">,</span> <span class="n">cluster_da_</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Invalid mode</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be &#39;cluster&#39; or &#39;grid&#39;&quot;</span><span class="p">)</span></div>


    

<div class="viewcode-block" id="WAS_TransformData.find_best_distribution_grid___">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.find_best_distribution_grid___">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_best_distribution_grid___</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit distributions to data using KMeans clustering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_transformed : bool, optional</span>
<span class="sd">            If True, use transformed data; otherwise, use original data. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist_codes : xarray.DataArray</span>
<span class="sd">            Numeric codes for best-fitting distributions per grid cell.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `fitter.Fitter` to fit distributions (e.g., normal, lognormal) to clustered data.</span>
<span class="sd">        Clusters are determined by mean values using KMeans.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="k">if</span> <span class="n">use_transformed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">dist_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">df_mean</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_mean</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Insufficient data for clustering, returning NaN array&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">},</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">df_mean</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_mean</span><span class="p">[[</span><span class="s1">&#39;value&#39;</span><span class="p">]])</span>
        <span class="c1"># clusters_da = df_mean.set_index([&#39;Y&#39;, &#39;X&#39;])[&#39;cluster&#39;].to_xarray()</span>
        <span class="n">clusters_da</span> <span class="o">=</span> <span class="n">df_mean</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">clusters_da</span> <span class="o">=</span> <span class="n">clusters_da</span> <span class="o">*</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">clusters_aligned</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters_da</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="n">dist_codes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters_aligned</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cl</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
            <span class="n">cl_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clusters_aligned</span> <span class="o">==</span> <span class="n">cl</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">cl_data</span> <span class="o">=</span> <span class="n">cl_data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cl_data</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">cl_data</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dist_codes</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ftr</span> <span class="o">=</span> <span class="n">Fitter</span><span class="p">(</span><span class="n">cl_data</span><span class="p">,</span> <span class="n">distributions</span><span class="o">=</span><span class="n">dist_names</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
                <span class="n">ftr</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
                <span class="n">best_name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">ftr</span><span class="o">.</span><span class="n">get_best</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;sumsquare_error&#39;</span><span class="p">)))</span>
                <span class="n">dist_codes</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_map</span><span class="p">[</span><span class="n">best_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="n">dist_codes</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dist_codes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">clusters_aligned</span><span class="p">,</span>
            <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WAS_TransformData.plot_best_fit_map">
<a class="viewcode-back" href="../../api.html#wass2s.was_transformdata.WAS_TransformData.plot_best_fit_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_best_fit_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_array</span><span class="p">,</span>
        <span class="n">map_dict</span><span class="p">,</span>
        <span class="n">output_file</span><span class="o">=</span><span class="s1">&#39;map.png&#39;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Categorical Map&#39;</span><span class="p">,</span>
        <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a categorical map of distributions or skewness classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_array : xarray.DataArray</span>
<span class="sd">            Data to plot (e.g., distribution codes or skewness classes) with dimensions (Y, X).</span>
<span class="sd">        map_dict : dict</span>
<span class="sd">            Mapping of category names to numeric codes (e.g., distribution_map).</span>
<span class="sd">        output_file : str, optional</span>
<span class="sd">            Path to save the plot. Default is &#39;map.png&#39;.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Plot title. Default is &#39;Categorical Map&#39;.</span>
<span class="sd">        colors : list, optional</span>
<span class="sd">            Colors for each code. Default is [&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;, &#39;purple&#39;, &#39;orange&#39;].</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            Figure size (width, height) in inches. Default is (10, 6).</span>
<span class="sd">        extent : tuple, optional</span>
<span class="sd">            Map extent (lon_min, lon_max, lat_min, lat_max). Default is data bounds.</span>
<span class="sd">        show_plot : bool, optional</span>
<span class="sd">            If True, display the plot interactively. Default is False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If insufficient colors are provided for the number of categories.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `cartopy` for geospatial visualization with PlateCarree projection.</span>
<span class="sd">        Saves the plot as a PNG file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">]</span>
        <span class="n">code2name</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">map_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">values</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Need at least </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span><span class="si">}</span><span class="s2"> colors, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">([</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">))])</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">codes</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">]])</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">BoundaryNorm</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">cfeature</span><span class="o">.</span><span class="n">COASTLINE</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">cfeature</span><span class="o">.</span><span class="n">BORDERS</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">gridlines</span><span class="p">(</span><span class="n">draw_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">add_colorbar</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">codes</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([</span><span class="n">code2name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;unknown&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">])</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;Category&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Longitude&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Latitude&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mandela C. M. HOUNGNIBO.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>